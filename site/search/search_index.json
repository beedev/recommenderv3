{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ESAB Welding Equipment Configurator","text":"<p>AI-Powered Welding Equipment Configuration System - A production-ready configurator using a configuration-driven state-machine architecture with multi-agent orchestration.</p>"},{"location":"#overview","title":"Overview","text":"<p>The ESAB Configurator is a sophisticated AI-powered system that guides users through a sequential S1\u2192SN workflow to build compatible welding equipment packages. The system combines:</p> <ul> <li>3-Agent Architecture: LLM parameter extraction + Neo4j graph search + multilingual response generation</li> <li>Dynamic State Machine: Configuration-driven S1\u2192SN flow with automatic state skipping</li> <li>Component Applicability: Y/N flags determining which components are needed based on power source selection</li> <li>Multi-Strategy Search: Cypher, Lucene, Vector, and LLM-based search with compatibility validation</li> <li>Multilingual Support: 7 languages (English, Spanish, French, German, Portuguese, Italian, Swedish)</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":""},{"location":"#architecture-documentation","title":"\ud83d\udcda Architecture Documentation","text":"<ul> <li>Code Architecture Overview - System-wide architecture and design patterns</li> <li>State Flow Architecture - S1\u2192SN dynamic state machine detailed flow</li> <li>Orchestrator Architecture - State orchestration with processors, ranker, and graph</li> <li>Search Strategies - Multi-strategy search system with context-based selection</li> <li>Master Parameter JSON - Data models and schema design</li> <li>Multilingual Flow - Translation and internationalization architecture</li> </ul>"},{"location":"#system-components","title":"\ud83d\udd27 System Components","text":"<ul> <li>Configuration System - Configuration management with LRU caching and hot reload</li> <li>Observability - LangSmith tracing and monitoring for all agents</li> </ul>"},{"location":"#operations","title":"\ud83d\ude80 Operations","text":"<ul> <li>Deployment Guide - Complete deployment documentation</li> <li>Testing Guide - Comprehensive testing practices</li> <li>Operations Runbook - Day-to-day operations and maintenance</li> </ul>"},{"location":"#system-architecture","title":"System Architecture","text":""},{"location":"#3-agent-system","title":"3-Agent System","text":"<p>Agent 1: ParameterExtractor (LLM-based) - Extracts welding parameters from natural language - Updates MasterParameterJSON with user requirements - Uses OpenAI GPT-4 with structured prompts</p> <p>Agent 2: ProductSearch (Neo4j graph database) - Searches for compatible products across 6 component types - Validates COMPATIBLE_WITH relationships - Returns ranked results with priority scoring</p> <p>Agent 3: MessageGenerator (Templates + LLM) - Generates user-friendly responses - Supports 7 languages via LLM translation - Context-aware state prompts</p>"},{"location":"#s1sn-state-flow","title":"S1\u2192SN State Flow","text":"<pre><code>S1: Power Source (MANDATORY)\n    \u2193\nS2: Feeder (Conditional - based on applicability)\n    \u2193\nS3: Cooler (Conditional)\n    \u2193\nS4: Interconnector (Conditional)\n    \u2193\nS5: Torch (Conditional)\n    \u2193\nS6: Accessories (Optional - Multi-select)\n    \u2193\nS7: Finalize (Package summary)\n</code></pre> <p>Component Applicability: After S1 (Power Source) selection, system loads <code>component_applicability.json</code> to determine which downstream components are needed (Y/N flags).</p>"},{"location":"#key-technologies","title":"Key Technologies","text":"<ul> <li>Backend: Python 3.11+, FastAPI 0.104.1, async/await</li> <li>Database: Neo4j 5.14.1 (graph database for products and compatibility)</li> <li>Cache: Redis 5.0+ (session storage with TTL)</li> <li>Archival: PostgreSQL 12+ (long-term session storage)</li> <li>LLM: OpenAI GPT-4o-mini (parameter extraction and Q&amp;A)</li> <li>Search: Multi-strategy (Cypher, Lucene, Vector, LLM)</li> <li>Observability: LangSmith tracing (optional)</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li> <p>Clone Repository <pre><code>git clone &lt;repository-url&gt;\ncd Ayna_ESAB_Nov7\n</code></pre></p> </li> <li> <p>Set Up Backend <pre><code>cd src/backend\npython -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\npip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Configure Environment <pre><code>cp deployment/env/.env.example src/backend/.env\n# Edit .env with your credentials:\n# - OPENAI_API_KEY\n# - NEO4J_URI, NEO4J_USERNAME, NEO4J_PASSWORD\n# - REDIS_URL or REDIS_HOST/REDIS_PORT\n# - POSTGRES_HOST, POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD\n</code></pre></p> </li> <li> <p>Run Server <pre><code>uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload\n</code></pre></p> </li> <li> <p>Access Documentation</p> </li> <li>API Docs: http://localhost:8000/docs</li> <li>Health Check: http://localhost:8000/health</li> </ol>"},{"location":"#testing","title":"Testing","text":"<pre><code>cd src/backend\n\n# Run all tests\npytest\n\n# Run specific test suites\npytest tests/unit -v              # Unit tests (&lt; 100ms)\npytest tests/integration -v       # Integration tests (&lt; 5s)\npytest tests/e2e -v               # End-to-end tests (&gt; 5s)\n\n# Run with coverage\npytest --cov=app --cov-report=html\n</code></pre> <p>See Testing Guide for detailed testing practices.</p>"},{"location":"#core-features","title":"Core Features","text":""},{"location":"#configuration-driven-architecture","title":"\u2705 Configuration-Driven Architecture","text":"<ul> <li>All state transitions driven by JSON configuration files</li> <li>Component applicability loaded from <code>component_applicability.json</code></li> <li>State prompts defined in <code>state_prompts.json</code></li> <li>Component types specified in <code>component_types.json</code></li> </ul>"},{"location":"#multi-strategy-search","title":"\u2705 Multi-Strategy Search","text":"<ul> <li>Cypher Strategy: Graph-based search with query-level compatibility filtering</li> <li>Lucene Strategy: Fulltext search with Neo4j indexes</li> <li>Vector Strategy: Semantic search using embeddings</li> <li>LLM Strategy: Intelligent search using GPT-4 analysis</li> </ul>"},{"location":"#compatibility-validation","title":"\u2705 Compatibility Validation","text":"<ul> <li>All searches enforce Neo4j COMPATIBLE_WITH relationships</li> <li>PowerSource \u2194 Feeder/Cooler compatibility</li> <li>Feeder \u2194 Torch compatibility</li> <li>Triple compatibility for Interconnector (PowerSource + Feeder + Cooler)</li> </ul>"},{"location":"#compound-request-handling","title":"\u2705 Compound Request Handling","text":"<ul> <li>Users can specify multiple components in a single message</li> <li>Auto-selection for exact matches (1 result)</li> <li>Disambiguation required for multiple matches (2+ results)</li> <li>Example: \"Aristo 500ix with RobustFeed U6\" \u2192 auto-selects both if unique</li> </ul>"},{"location":"#multilingual-support","title":"\u2705 Multilingual Support","text":"<ul> <li>7 languages: en, es, fr, de, pt, it, sv</li> <li>LLM-based translation with context preservation</li> <li>Language-specific response formatting</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<ul> <li>Version: 2.0 (Recommender_v2)</li> <li>Port: 8000 (production-ready backend API)</li> <li>Python: 3.11+ (3.12+ fully supported)</li> <li>Production Status: Active development</li> </ul>"},{"location":"#documentation-updates","title":"Documentation Updates","text":"<p>Latest Changes (January 2025): - \u2705 Comprehensive Google-style docstrings added to 24 methods across 4 files:   - <code>parameter_extractor.py</code> (7 methods) - Agent 1   - <code>search/orchestrator.py</code> (2 methods) - Agent 2   - <code>message_generator.py</code> (9 methods) - Agent 3   - <code>state_processors.py</code> (6 methods) - State machine - \u2705 MkDocs configuration with mkdocstrings for automatic API documentation - \u2705 Material theme with dark mode support - \u2705 Comprehensive architecture documentation - \u2705 Testing guide with best practices</p>"},{"location":"#contributing","title":"Contributing","text":"<p>This is a production codebase for ESAB welding equipment configuration. For development:</p> <ol> <li>Follow the testing guide for all code changes</li> <li>Add comprehensive docstrings (Google-style) for new methods</li> <li>Update architecture documentation for significant changes</li> <li>Run full test suite before committing</li> <li>Follow existing code patterns and conventions</li> </ol>"},{"location":"#license","title":"License","text":"<p>Copyright \u00a9 2025 ESAB</p>"},{"location":"#support","title":"Support","text":"<p>For issues, questions, or contributions: - Check the Operations Runbook - Review Troubleshooting Guide - See Deployment Documentation</p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/","title":"Agent 1: ParameterExtractor Architecture","text":"<p>File: <code>src/backend/app/services/intent/parameter_extractor.py</code></p> <p>Agent 1 (ParameterExtractor) is the LLM-based natural language understanding component that converts user messages into structured MasterParameterJSON. It uses OpenAI GPT-4 to extract welding specifications, product names, and technical parameters from conversational queries.</p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#overview","title":"Overview","text":"<p>The ParameterExtractor is a sophisticated NLU agent that bridges natural language and structured data. It performs:</p> <ul> <li>Intent Detection: Identifies product selection vs. specification requests</li> <li>Parameter Extraction: Converts \"500A MIG welder for aluminum\" \u2192 structured JSON</li> <li>Product Name Recognition: Fuzzy matching against 200+ known products</li> <li>Operator Extraction: Interprets \"max 300A\", \"at least 500A\", \"between 300-500A\"</li> <li>Multilingual Support: Translates queries to English for Lucene search</li> <li>Selection Prevention: Clears previous parameters within same state</li> </ul> <p>Key Metrics: - Prompt Size: ~750 lines (~10K tokens) - Extraction Accuracy: 95%+ for structured queries - Product Name Match Rate: 90%+ with fuzzy matching - LLM Model: GPT-4 (temperature: 0.3) - Observable: LangSmith @traceable decorator</p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#core-responsibilities","title":"Core Responsibilities","text":""},{"location":"AGENT1_PARAMETER_EXTRACTOR/#1-initialization-and-configuration","title":"1. Initialization and Configuration","text":"<pre><code>def __init__(self, openai_api_key: str, config_service=None):\n    \"\"\"\n    Initialize parameter extractor with OpenAI client\n\n    Args:\n        openai_api_key: OpenAI API key\n        config_service: Optional config service (will use fallback if not provided)\n\n    ENHANCED: Now supports optional config_service for better testability\n    \"\"\"\n    self.client = AsyncOpenAI(api_key=openai_api_key)\n\n    # ORIGINAL: Use config service (with optional fallback)\n    if config_service is None:\n        try:\n            self.config_service = get_config_service()\n            logger.info(\"Using provided config service\")\n        except Exception as e:\n            logger.warning(f\"Config service not available, using fallback config: {e}\")\n            self.config_service = self._get_fallback_config()\n    else:\n        self.config_service = config_service\n\n    # ORIGINAL: Load product names for fuzzy matching\n    self.product_names = self._load_product_names()\n\n    logger.info(\"Parameter Extractor initialized with product name knowledge\")\n</code></pre> <p>Key Features: - Async OpenAI Client: Non-blocking LLM calls - Fallback Configuration: Works without full ConfigurationService (testing-friendly) - Product Name Knowledge: Pre-loaded 200+ products from llm_context.json - Fuzzy Matching Config: Loads enabled components from component_types.json</p> <p>Fallback Configuration: <pre><code>class FallbackConfig:\n    \"\"\"Simple fallback config for testing/standalone operation\"\"\"\n\n    def get_fuzzy_match_config(self):\n        # Rationalized Nov 15, 2025: components_enabled no longer in search_config\n        # Load from component_types.json instead\n        from app.config.schema_loader import load_component_config\n        component_types = load_component_config()\n        enabled_components = [\n            key for key, data in component_types.items()\n            if data.get(\"fuzzy_matching_enabled\", False)\n        ]\n        return {\n            \"enabled\": True,\n            \"components_enabled\": enabled_components\n        }\n\n    def get_llm_config(self, name):\n        return {\n            \"model\": \"gpt-4\",\n            \"temperature\": 0.3,\n            \"max_tokens\": 2000\n        }\n\n    def get_prompt(self, name):\n        return \"You are a welding equipment expert. Extract technical parameters from user queries into component-based JSON structure.\"\n</code></pre></p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#2-product-name-knowledge-loading","title":"2. Product Name Knowledge Loading","text":"<pre><code>def _load_product_names(self) -&gt; Dict[str, List[str]]:\n    \"\"\"\n    Load product names from llm_context.json filtered by fuzzy matching configuration.\n\n    Loads product names for fuzzy matching and selection intent detection. Only includes\n    components enabled for fuzzy matching in component_types.json to avoid huge prompts.\n\n    Returns:\n        Dict[str, List[str]]: Product names organized by component category.\n            Example: {\n                \"power_source\": [\"Aristo 500ix CE\", \"Warrior 400i CC/CV\", ...],\n                \"feeder\": [\"RobustFeed U6 Water-cooled Euro\", ...],\n                \"cooler\": [\"Cool2 Cooling Unit\", ...]\n            }\n\n    Note:\n        - Consolidated Nov 15, 2025: Moved from product_names.json to llm_context.json\n        - Only loads components with fuzzy_matching_enabled=true in component_types.json\n        - Returns empty dict if llm_context.json cannot be loaded (logs warning)\n    \"\"\"\n    try:\n        config_path = os.path.join(\n            os.path.dirname(__file__),\n            \"../../config/llm_context.json\"\n        )\n\n        with open(config_path, \"r\") as f:\n            llm_context = json.load(f)\n            all_products = llm_context.get(\"product_names\", {})\n\n        # Get components enabled for fuzzy matching from component_types.json (rationalized Nov 15, 2025)\n        fuzzy_config = self.config_service.get_fuzzy_match_config()\n        # For backward compatibility, try to get from fuzzy_config first, else load from component_types\n        components_enabled = fuzzy_config.get(\"components_enabled\")\n        if not components_enabled:\n            from app.config.schema_loader import load_component_config\n            component_types = load_component_config()\n            components_enabled = [\n                key for key, data in component_types.items()\n                if data.get(\"fuzzy_matching_enabled\", False)\n            ]\n\n        # Only include enabled components to avoid huge prompts\n        limited_products = {}\n        for component in components_enabled:\n            if component in all_products:\n                limited_products[component] = all_products[component]\n\n        logger.info(f\"Loaded product names: {sum(len(v) for v in limited_products.values())} total (components: {components_enabled})\")\n        return limited_products\n\n    except Exception as e:\n        logger.warning(f\"Could not load product names: {e}\")\n        return {}\n</code></pre> <p>Purpose: Load 200+ product names for fuzzy matching and prompt context</p> <p>Optimization: Only loads components with fuzzy_matching_enabled=true to keep prompts under 10K tokens</p> <p>Example Output: <pre><code>{\n    \"power_source\": [\n        \"Aristo 500ix CE\",\n        \"Warrior 400i CC/CV\",\n        \"Renegade ES 300i Kit w/welding cables\",\n        ...\n    ],\n    \"feeder\": [\n        \"RobustFeed U6 Water-cooled Euro\",\n        \"Pulse U82 SuperPulse\",\n        ...\n    ],\n    \"cooler\": [\n        \"Cool2 Cooling Unit\",\n        \"Cool3 Cooling Unit\",\n        ...\n    ]\n}\n</code></pre></p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#3-main-parameter-extraction-flow","title":"3. Main Parameter Extraction Flow","text":"<pre><code>@traceable(name=\"extract_parameters\", run_type=\"llm\")\nasync def extract_parameters(\n    self,\n    user_message: str,\n    current_state: str,\n    master_parameters: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Extract parameters from user message using LLM\n    Returns complete updated MasterParameterJSON\n\n    Args:\n        user_message: User's natural language input\n        current_state: Current state (e.g., \"power_source_selection\")\n        master_parameters: Existing MasterParameterJSON dict\n\n    Returns:\n        Updated complete MasterParameterJSON dict with optional _selection_metadata\n\n    ENHANCED: Added selection intent detection for numbers and product names\n    FIXED (Nov 15, 2025): Clear current state component before extraction to prevent accumulation\n    \"\"\"\n\n    try:\n        logger.info(f\"Extracting parameters for state: {current_state}\")\n\n        # \u2728 NEW: Check for selection intent BEFORE LLM call\n        selection_metadata = self._detect_selection_intent(user_message)\n        if selection_metadata and selection_metadata.get(\"is_selection\"):\n            logger.info(f\"Selection detected: {selection_metadata}\")\n            # Return master parameters with selection metadata\n            result = dict(master_parameters)\n            result[\"_selection_metadata\"] = selection_metadata\n            return result\n\n        # \ud83d\udd27 FIX (Nov 15, 2025): Clear current state's component to prevent accumulation\n        # User requirement: \"Within a state, each new query should REPLACE parameters, not accumulate\"\n        # Example: In PowerSource state, \"Aristo\" then \"Renegade\" \u2192 show only Renegade\n        master_parameters_cleared = self._clear_current_state_component(\n            master_parameters,\n            current_state\n        )\n\n        # Build extraction prompt based on current state\n        prompt = self._build_extraction_prompt(\n            user_message,\n            current_state,\n            master_parameters_cleared\n        )\n\n        # ORIGINAL: Get LLM config for parameter extraction\n        llm_config = self.config_service.get_llm_config(\"parameter_extraction\")\n        system_prompt = self.config_service.get_prompt(\"parameter_extraction_system\")\n\n        # ORIGINAL: Call OpenAI for parameter extraction\n        response = await self.client.chat.completions.create(\n            model=llm_config.get(\"model\", \"gpt-4\"),\n            messages=[\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": prompt}\n            ],\n            temperature=llm_config.get(\"temperature\", 0.3),\n            max_tokens=llm_config.get(\"max_tokens\", 2000)\n        )\n\n        # Parse LLM response\n        extracted_text = response.choices[0].message.content\n        updated_master = self._parse_llm_response(extracted_text, master_parameters)\n\n        logger.info(f\"Extraction complete. Updated components: {list(updated_master.keys())}\")\n        return updated_master\n\n    except Exception as e:\n        logger.error(f\"Parameter extraction failed: {e}\")\n\n        # Return unchanged master_parameters on error\n        return master_parameters\n</code></pre> <p>Processing Flow: 1. Selection Intent Detection: Fast pre-LLM check for numbers/product names 2. Current State Clearing: Prevents parameter accumulation (\"Aristo\" + \"Renegade\" \u2192 show only \"Renegade\") 3. Prompt Building: State-specific ~750-line prompt with examples 4. LLM Call: GPT-4 with temperature=0.3 for consistent extraction 5. Response Parsing: JSON extraction, operator validation, component normalization</p> <p>Key Optimizations: - Early Exit: Selection detection avoids expensive LLM call for \"2\", \"option 3\", \"Aristo 500ix\" - State Clearing: User requirement from Nov 15, 2025 - replace don't accumulate - LangSmith Tracing: @traceable decorator for LLM observability</p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#4-selection-intent-detection","title":"4. Selection Intent Detection","text":"<pre><code>def _detect_selection_intent(self, user_message: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Detect if user input is a product selection (number index or product name).\n\n    Fast pre-LLM detection for common selection patterns to avoid unnecessary LLM calls.\n    Matches pure numbers (1-10), numbers with context (\"option 2\"), and explicit product\n    names from the loaded product catalog.\n\n    Args:\n        user_message: User's input text to analyze\n\n    Returns:\n        Optional[Dict[str, Any]]: Selection metadata dict if selection detected, None otherwise.\n            Structure when detected:\n            {\n                \"is_selection\": True,\n                \"selected_index\": int (1-10) or None,\n                \"selected_product_name\": str or None,\n                \"skip_intent\": False\n            }\n\n    Detection Patterns:\n        Pattern 1 - Pure number: \"2\", \"3\" (range 1-10)\n        Pattern 2 - Number with context: \"option 2\", \"3rd one\", \"give me 1\", \"i want 4\"\n        Pattern 3 - Explicit product name: Partial match against loaded product names\n\n    Examples:\n        &gt;&gt;&gt; extractor._detect_selection_intent(\"2\")\n        {\"is_selection\": True, \"selected_index\": 2, \"selected_product_name\": None, ...}\n\n        &gt;&gt;&gt; extractor._detect_selection_intent(\"option 3\")\n        {\"is_selection\": True, \"selected_index\": 3, \"selected_product_name\": None, ...}\n\n        &gt;&gt;&gt; extractor._detect_selection_intent(\"Aristo 500ix\")\n        {\"is_selection\": True, \"selected_index\": None, \"selected_product_name\": \"Aristo 500ix CE\", ...}\n\n        &gt;&gt;&gt; extractor._detect_selection_intent(\"I need 500A MIG welder\")\n        None  # Not a selection, requires LLM extraction\n    \"\"\"\n    import re\n\n    message = user_message.strip().lower()\n\n    # Pattern 1: Pure number (e.g., \"2\", \"3\")\n    if re.match(r'^\\d+$', message):\n        index = int(message)\n        if 1 &lt;= index &lt;= 10:  # Reasonable range\n            logger.info(f\"\u26a1 Pure number selection detected: {index}\")\n            return {\n                \"is_selection\": True,\n                \"selected_index\": index,\n                \"selected_product_name\": None,\n                \"skip_intent\": False\n            }\n\n    # Pattern 2: Number with context (e.g., \"option 2\")\n    number_patterns = [\n        r'^\\s*(?:option|number|item|product|choice)\\s+(\\d+)\\s*$',\n        r'^\\s*(\\d+)\\s*(?:st|nd|rd|th)?\\s*(?:option|one)?\\s*$',\n        r'^\\s*i\\s*(?:want|need|choose|select|pick)\\s+(\\d+)\\s*$',\n        r'^\\s*give\\s+me\\s+(\\d+)\\s*$'\n    ]\n\n    for pattern in number_patterns:\n        match = re.match(pattern, message)\n        if match:\n            index = int(match.group(1))\n            if 1 &lt;= index &lt;= 10:\n                logger.info(f\"\u26a1 Number selection with context detected: {index}\")\n                return {\n                    \"is_selection\": True,\n                    \"selected_index\": index,\n                    \"selected_product_name\": None,\n                    \"skip_intent\": False\n                }\n\n    # Pattern 3: Explicit product name (partial match)\n    for category, names in self.product_names.items():\n        for product_name in names:\n            if product_name.lower() in message:\n                logger.info(f\"\u26a1 Product name selection detected: {product_name}\")\n                return {\n                    \"is_selection\": True,\n                    \"selected_index\": None,\n                    \"selected_product_name\": product_name,\n                    \"skip_intent\": False\n                }\n\n    return None\n</code></pre> <p>Purpose: Fast pre-LLM detection to avoid expensive GPT-4 calls for simple selections</p> <p>Performance Impact: - Saves ~$0.01 per selection (GPT-4 call avoided) - Reduces latency from ~2s to ~10ms - 80%+ of user interactions are selections after initial search</p> <p>Pattern Examples: - Pure numbers: \"2\", \"3\", \"5\" - Context numbers: \"option 2\", \"give me 1\", \"3<sup>rd</sup> one\" - Product names: \"Aristo 500ix\", \"RobustFeed\", \"Cool2\"</p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#5-current-state-component-clearing","title":"5. Current State Component Clearing","text":"<pre><code>def _clear_current_state_component(\n    self,\n    master_parameters: Dict[str, Any],\n    current_state: str\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Clear component parameters for current state to prevent accumulation.\n\n    Implements replacement behavior: within a state, each new query replaces previous\n    parameters instead of accumulating them. Prevents \"Aristo\" + \"Renegade\" showing\n    both products when user only wants the latest request.\n\n    Args:\n        master_parameters: Existing MasterParameterJSON dict\n        current_state: Current configurator state (e.g., \"power_source_selection\")\n\n    Returns:\n        Dict[str, Any]: Modified master_parameters with current state's component cleared to empty dict {}\n\n    State-to-Component Mapping:\n        - power_source_selection \u2192 power_source\n        - feeder_selection \u2192 feeder\n        - cooler_selection \u2192 cooler\n        - interconnector_selection \u2192 interconnector\n        - torch_selection \u2192 torch\n        - accessories_selection \u2192 accessories\n        - (and other accessory/remote states)\n\n    Examples:\n        &gt;&gt;&gt; master_params = {\"power_source\": {\"product_name\": \"Aristo 500ix\"}, \"feeder\": {}}\n        &gt;&gt;&gt; cleared = extractor._clear_current_state_component(master_params, \"power_source_selection\")\n        &gt;&gt;&gt; cleared[\"power_source\"]\n        {}  # Cleared for replacement\n        &gt;&gt;&gt; cleared[\"feeder\"]\n        {}  # Unchanged (different state)\n\n    Note:\n        User requirement (Nov 15, 2025): \"Within a state, each new query should REPLACE\n        parameters, not accumulate. For example, in PowerSource state, asking for 'Aristo'\n        then 'Renegade' should show only Renegade, not both.\"\n\n        States that don't map to a component (e.g., \"finalize\") return parameters unchanged.\n    \"\"\"\n    # Map state to component\n    state_to_component = {\n        \"power_source_selection\": \"power_source\",\n        \"feeder_selection\": \"feeder\",\n        \"cooler_selection\": \"cooler\",\n        \"interconnector_selection\": \"interconnector\",\n        \"torch_selection\": \"torch\",\n        \"accessories_selection\": \"accessories\",\n        \"powersource_accessories_selection\": \"powersource_accessories\",\n        \"feeder_accessories_selection\": \"feeder_accessories\",\n        \"feeder_conditional_accessories_selection\": \"feeder_conditional_accessories\",\n        \"interconnector_accessories_selection\": \"interconnector_accessories\",\n        \"remote_selection\": \"remote\",\n        \"remote_accessories_selection\": \"remote_accessories\",\n        \"remote_conditional_accessories_selection\": \"remote_conditional_accessories\",\n        \"connectivity_selection\": \"connectivity\"\n    }\n\n    # Get component for current state\n    component_to_clear = state_to_component.get(current_state)\n\n    if component_to_clear:\n        # Make a copy to avoid modifying original\n        cleared_params = dict(master_parameters)\n\n        # Clear the component\n        if component_to_clear in cleared_params:\n            logger.info(f\"\ud83d\udd04 Clearing '{component_to_clear}' parameters for state '{current_state}' (preventing accumulation)\")\n            cleared_params[component_to_clear] = {}\n\n        return cleared_params\n    else:\n        # State doesn't map to a component (e.g., finalize), return as-is\n        logger.debug(f\"State '{current_state}' does not map to a component, keeping all parameters\")\n        return master_parameters\n</code></pre> <p>Critical Fix (Nov 15, 2025): Prevents parameter accumulation within same state</p> <p>User Scenario: <pre><code>User in PowerSource state:\n1. Query: \"Aristo\" \u2192 Shows Aristo products\n2. Query: \"Renegade\" \u2192 Should show ONLY Renegade, not Aristo + Renegade\n\nBEFORE FIX: Both Aristo AND Renegade parameters accumulated \u2192 showed both product families\nAFTER FIX: Renegade clears Aristo parameters \u2192 shows only Renegade family\n</code></pre></p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#6-massive-prompt-building-750-lines","title":"6. Massive Prompt Building (~750 Lines)","text":"<pre><code>def _build_extraction_prompt(\n    self,\n    user_message: str,\n    current_state: str,\n    master_parameters: Dict[str, Any]\n) -&gt; str:\n    \"\"\"\n    Build comprehensive LLM prompt for parameter extraction from user query.\n\n    Creates a massive ~750-line prompt with state-specific guidance, technical pattern examples,\n    product name fuzzy matching instructions, and operator extraction rules. This is the core\n    intelligence behind converting natural language to structured MasterParameterJSON.\n\n    Args:\n        user_message: User's natural language input (e.g., \"500A MIG welder for aluminum\")\n        current_state: Current configurator state (e.g., \"power_source_selection\")\n        master_parameters: Existing MasterParameterJSON dict (for context preservation)\n\n    Returns:\n        str: Complete prompt for OpenAI GPT-4 with:\n            - State-specific extraction guidance\n            - Technical specification patterns (current, voltage, duty cycle, etc.)\n            - Product name fuzzy matching instructions\n            - Comparison operator extraction rules (lte, gte, lt, gt, eq, range, approx)\n            - Compound request handling\n            - Known product names reference (from llm_context.json)\n            - Existing parameters for context\n            - Output format instructions\n\n    Prompt Sections:\n        1. State-Specific Guidance: Focused extraction based on current state\n        2. Product Name Reference: Top 10 known products per component (fuzzy matching)\n        3. Technical Specification Patterns: Current/duty cycle, process types, voltage, features\n        4. Comparison Operators: lte, gte, lt, gt, eq, range, approx with keyword examples\n        5. Compound Request Handling: Multi-component extraction in single message\n        6. Output Format: JSON structure with all components + english_query field\n    \"\"\"\n\n    # Enhanced state-specific extraction guidance with detailed patterns\n    state_guidance = {\n        \"power_source_selection\": \"\"\"\nFOCUS: Extract requirements for POWER SOURCE component\nLook for:\n  - Process types: MIG (GMAW), MAG, MMA/Stick, TIG (GTAW), DC TIG, Lift TIG, pulse\n  - Current ratings with duty cycles: \"500A @60%\", \"300A at 40%\", \"400A at 100%\"\n  - Voltage specifications: \"380-460V\", \"dual voltage\", \"230-480V\", \"single/three phase\"\n  - Inverter technology: \"inverter\", \"inverter-based\", \"portable inverter\"\n  - Advanced features: \"synergic\", \"pulse\", \"super pulse\", \"double pulse\", \"multiprocess\"\n  - Design attributes: \"portable\", \"heavy duty\", \"robust\", \"compact\", \"high power-to-weight\"\n  - Applications: \"shipyard\", \"industrial\", \"on-site\", \"robotic\", \"field work\"\n  - Integration: \"robot interface\", \"cloud connectivity\", \"WeldCloud\"\n  - Accessories included: \"with cables\", \"welding and return cables\"\nProduct Names: Extract specific model names (e.g., \"Warrior 400i\", \"Aristo 500ix\", \"Renegade ES 300i\")\n\"\"\",\n        \"feeder_selection\": \"\"\"\nFOCUS: Extract requirements for FEEDER component\nLook for:\n  - Process type: MIG, MAG, GMAW, wire feed\n  - Material: aluminum, steel, stainless steel\n  - Thickness: \"6mm\", \"3-12mm\", \"thin\", \"thick\"\n  - Cooling type: \"water cooled\", \"liquid cooled\", \"gas cooled\", \"air cooled\"\n  - Wire diameter: \"0.8-1.6mm\", \"1.0mm\", \"1.2mm\"\n  - Features: \"synergic\", \"digital\", \"push-pull\", \"SuperPulse\"\nProduct Names: Extract specific feeder models (e.g., \"RobustFeed U6\", \"Pulse U82\")\n\"\"\",\n        # ... (other states)\n    }\n\n    guidance = state_guidance.get(current_state, \"Extract any welding-related requirements\")\n\n    # Build product name reference\n    product_reference = \"\"\n    if self.product_names:\n        product_reference = \"\\n\\nKNOWN PRODUCT NAMES (for reference):\\n\"\n\n        if self.product_names.get(\"power_source\"):\n            product_reference += \"\\nPower Sources:\\n\"\n            product_reference += \"\\n\".join([f\"  - {name}\" for name in self.product_names[\"power_source\"][:10]])\n            if len(self.product_names[\"power_source\"]) &gt; 10:\n                product_reference += f\"\\n  ... and {len(self.product_names['power_source']) - 10} more\"\n\n    # ... (similar for feeder, cooler)\n\n    prompt = f\"\"\"\nTASK: Extract welding equipment requirements from user query and update the Master Parameter JSON.\n\nUSER QUERY: \"{user_message}\"\n\nCURRENT STATE: {current_state}\n\n{guidance}\n\nEXISTING MASTER PARAMETER JSON:\n{json.dumps(serializable_params, indent=2)}\n{product_reference}\n\nCOMPREHENSIVE EXTRACTION INSTRUCTIONS:\n\n1. COMPONENT-BASED EXTRACTION:\n   - Each component (power_source, feeder, cooler, interconnector, torch, accessories) has its own dict.\n   - Extract requirements into the appropriate component dict based on current state.\n   - Use string keys and string values (e.g., {{\"current_rating\": \"500A @60%\", \"process\": \"MIG (GMAW)\"}}).\n\n2. TECHNICAL SPECIFICATION PATTERNS (CRITICAL):\n\n   a) CURRENT &amp; DUTY CYCLE WITH COMPARISON OPERATORS:\n      - \"500A @60%\" \u2192 {{\"current_rating\": \"500A\", \"duty_cycle\": \"60%\"}}\n      - \"300A at 40%\" \u2192 {{\"current_rating\": \"300A\", \"duty_cycle\": \"40%\"}}\n      - \"max 300A\" \u2192 {{\"current_rating\": {{\"value\": 300, \"operator\": \"lte\", \"unit\": \"A\"}}}}\n      - \"at least 500A\" \u2192 {{\"current_rating\": {{\"value\": 500, \"operator\": \"gte\", \"unit\": \"A\"}}}}\n      - \"more than 400A\" \u2192 {{\"current_rating\": {{\"value\": 400, \"operator\": \"gt\", \"unit\": \"A\"}}}}\n      - \"between 300-500A\" \u2192 {{\"current_rating\": {{\"min\": 300, \"max\": 500, \"operator\": \"range\", \"unit\": \"A\"}}}}\n\n      OPERATOR KEYWORDS (extract when present):\n      * \"lte\" (\u2264): max, maximum, up to, no more than, at most\n      * \"gte\" (\u2265): min, minimum, at least, no less than\n      * \"lt\" (&lt;): less than, below, under, smaller than\n      * \"gt\" (&gt;): more than, above, over, greater than, larger than\n      * \"eq\" (=): exactly, only, precisely\n      * \"range\": between X and Y, X-Y, X to Y\n      * \"approx\" (\u2248): around, about, approximately (default)\n\n3. PRODUCT NAME RECOGNITION (CRITICAL - HIGHEST PRIORITY):\n   - **ALWAYS check if the user mentions a specific product name from the KNOWN PRODUCT NAMES list above**\n   - **This is CRITICAL for accurate product matching - exact product names enable 100x search boosting**\n   - Use key \"product_name\" in the appropriate component dict\n\n   FUZZY MATCHING &amp; INFERENCE RULES:\n   - **NEVER invent or hallucinate product names that don't exist in the KNOWN PRODUCT NAMES list**\n   - **ALWAYS infer and match to the CLOSEST product name from the KNOWN PRODUCT NAMES list above**\n   - **Your job is to FIND the best match, not copy the user's exact words**\n\n   FUZZY MATCHING EXAMPLES:\n   - User says: \"Renegade ES30\" \u2192 Infer: \"Renegade ES 300i Kit w/welding cables\" (ES30 \u2248 ES 300i)\n   - User says: \"Aristo 500\" \u2192 Infer: \"Aristo 500ix CE\" (only one Aristo 500 variant)\n   - User says: \"Warrior400i\" \u2192 Infer: \"Warrior 400i CC/CV\" (400i matches)\n   - User says: \"RobustFeed\" \u2192 Infer: \"RobustFeed U6 Water-cooled Euro\" (pick most common variant)\n\n8. GIN NUMBER DETECTION (CRITICAL):\n   - If user provides a 7\u201310 digit number (e.g., \"0465350883\", \"0446200880\"), treat it as a GIN product identifier.\n   - Add it as \"product_name\" in the appropriate component dict.\n   - Keep leading zeros intact (do NOT modify or format it).\n\n10. ENGLISH TRANSLATION (CRITICAL FOR MULTILINGUAL SUPPORT):\n   - Translate the user query to English (if not already in English)\n   - Keep technical terms unchanged (e.g., \"MIG\", \"TIG\", \"500A\", \"60%\")\n   - Remove only conversational words (e.g., \"I need\" \u2192 \"\", \"Can you\" \u2192 \"\")\n   - Include \"english_query\" field in the output\n   - Examples:\n     * Spanish: \"Necesito un soldador MIG de 500A\" \u2192 \"MIG welder 500A\"\n     * French: \"J'ai besoin d'un soudeur MIG de 500A\" \u2192 \"MIG welder 500A\"\n\nRETURN COMPLETE UPDATED JSON WITH ENGLISH TRANSLATION:\n{{\n  \"power_source\": {{...}},\n  \"feeder\": {{...}},\n  \"cooler\": {{...}},\n  \"interconnector\": {{...}},\n  \"torch\": {{...}},\n  \"accessories\": {{...}},\n  \"english_query\": \"translated English version of user query\"\n}}\n\"\"\"\n    return prompt\n</code></pre> <p>Prompt Highlights: - State-Specific Guidance: Custom instructions per component (power_source, feeder, cooler, etc.) - Product Name Fuzzy Matching: \"Renegade ES30\" \u2192 \"Renegade ES 300i Kit w/welding cables\" - Operator Extraction: \"max 300A\" \u2192 <code>{\"value\": 300, \"operator\": \"lte\", \"unit\": \"A\"}</code> - Technical Patterns: 50+ examples for current/duty cycle, voltage, features - GIN Detection: 7-10 digit numbers treated as product identifiers - Multilingual: english_query field for Lucene search - Comprehensive: ~750 lines, ~10K tokens</p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#7-operator-validation-and-normalization","title":"7. Operator Validation and Normalization","text":"<pre><code>def _validate_and_normalize_operators(self, component_data: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Validate and normalize comparison operator format in extracted parameters.\n\n    Ensures operator-based parameters follow correct structure and validates operator types.\n    Supports dual-mode: structured operator dict and backward-compatible string format.\n\n    Supported Operators:\n        - lte (\u2264): Less than or equal (max, maximum, up to, at most)\n        - gte (\u2265): Greater than or equal (min, minimum, at least)\n        - lt (&lt;): Less than (below, under, smaller than)\n        - gt (&gt;): Greater than (above, over, larger than)\n        - eq (=): Exactly equal (only, precisely, exactly)\n        - range: Between min and max (X-Y, X to Y, between X and Y)\n        - approx (\u2248): Approximate (around, about, roughly, or no operator)\n\n    Examples:\n        Valid operator dict:\n        &gt;&gt;&gt; component = {\"current_rating\": {\"value\": 300, \"operator\": \"lte\", \"unit\": \"A\"}}\n        &gt;&gt;&gt; normalized = extractor._validate_and_normalize_operators(component)\n        &gt;&gt;&gt; normalized[\"current_rating\"][\"operator\"]\n        \"lte\"\n\n        Invalid operator (corrected):\n        &gt;&gt;&gt; component = {\"current_rating\": {\"value\": 300, \"operator\": \"invalid\", \"unit\": \"A\"}}\n        &gt;&gt;&gt; normalized = extractor._validate_and_normalize_operators(component)\n        &gt;&gt;&gt; normalized[\"current_rating\"][\"operator\"]\n        \"approx\"  # Defaulted\n    \"\"\"\n    VALID_OPERATORS = {\"lte\", \"gte\", \"lt\", \"gt\", \"eq\", \"range\", \"approx\"}\n\n    normalized = {}\n\n    # Convert Pydantic model to dict before iterating\n    component_dict = component_data.dict() if hasattr(component_data, 'dict') else component_data\n\n    for key, value in component_dict.items():\n        # Check if value is dict format (potential operator format)\n        if isinstance(value, dict):\n            # Check if it has operator field\n            if \"operator\" in value:\n                operator = value.get(\"operator\", \"approx\")\n\n                # Validate operator\n                if operator not in VALID_OPERATORS:\n                    logger.warning(f\"Invalid operator '{operator}' for {key}, defaulting to 'approx'\")\n                    value[\"operator\"] = \"approx\"\n\n                # Validate structure based on operator\n                if operator == \"range\":\n                    # Range requires min and max\n                    if \"min\" not in value or \"max\" not in value:\n                        logger.warning(f\"Range operator missing min/max for {key}, converting to approx\")\n                        if \"value\" in value:\n                            value[\"operator\"] = \"approx\"\n                        else:\n                            # Invalid range, skip\n                            logger.warning(f\"Invalid range format for {key}, skipping\")\n                            continue\n                else:\n                    # Non-range operators require value\n                    if \"value\" not in value:\n                        logger.warning(f\"Operator format missing 'value' for {key}, skipping\")\n                        continue\n\n                # Valid operator format\n                normalized[key] = value\n                logger.debug(f\"Validated operator for {key}: {value}\")\n            else:\n                # Dict without operator field - keep as-is (nested dict)\n                normalized[key] = value\n        else:\n            # String or other format - keep as-is (backward compatible)\n            normalized[key] = value\n\n    return normalized\n</code></pre> <p>Operator Structure: <pre><code># Comparison operators\n{\"value\": 300, \"operator\": \"lte\", \"unit\": \"A\"}  # max 300A\n{\"value\": 500, \"operator\": \"gte\", \"unit\": \"A\"}  # at least 500A\n{\"min\": 300, \"max\": 500, \"operator\": \"range\", \"unit\": \"A\"}  # 300-500A\n\n# Backward compatible string\n\"500A\"  # Defaults to approx operator\n</code></pre></p> <p>Usage in Neo4j Queries: Operators are converted to Cypher WHERE clauses by query builder</p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#8-llm-response-parsing","title":"8. LLM Response Parsing","text":"<pre><code>def _parse_llm_response(\n    self,\n    llm_response: str,\n    fallback_master: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Parse LLM text response into validated MasterParameterJSON dict.\n\n    Extracts JSON from LLM response (with or without code fences), validates structure,\n    normalizes operators, and ensures all required components exist. Handles multilingual\n    english_query extraction for Lucene search.\n\n    Parsing Steps:\n        1. Extract JSON from response (try ```json fences first, then regex)\n        2. Parse JSON string to dict\n        3. Extract and remove english_query field (temporary metadata)\n        4. Ensure all required components exist (from schema_loader)\n        5. Validate and normalize operators in each component\n        6. Add _english_query as temporary metadata if present\n        7. Log operator count and total features extracted\n\n    Examples:\n        LLM response with code fences:\n        &gt;&gt;&gt; llm_response = '''```json\n        ... {\n        ...   \"power_source\": {\"current_rating\": \"500A\", \"process\": \"MIG (GMAW)\"},\n        ...   \"feeder\": {},\n        ...   \"english_query\": \"MIG welder 500A\"\n        ... }\n        ... ```'''\n        &gt;&gt;&gt; parsed = extractor._parse_llm_response(llm_response, fallback)\n        &gt;&gt;&gt; parsed[\"power_source\"][\"current_rating\"]\n        \"500A\"\n        &gt;&gt;&gt; parsed[\"_english_query\"]\n        \"MIG welder 500A\"\n    \"\"\"\n    import re\n\n    try:\n        json_match = re.search(r'```json\\s*(.*?)\\s*```', llm_response, re.DOTALL)\n        if json_match:\n            json_str = json_match.group(1)\n        else:\n            json_match = re.search(r'\\{.*\\}', llm_response, re.DOTALL)\n            if json_match:\n                json_str = json_match.group(0)\n            else:\n                raise ValueError(\"No JSON found in LLM response\")\n\n        parsed_data = json.loads(json_str)\n\n        # Extract english_query from LLM response (for multilingual Lucene search)\n        english_query = parsed_data.pop(\"english_query\", None)\n\n        required_components = get_component_list()\n        for component in required_components:\n            if component not in parsed_data:\n                parsed_data[component] = {}\n\n        # Validate and normalize operators for each component\n        for component in required_components:\n            if parsed_data[component]:  # Only process non-empty components\n                parsed_data[component] = self._validate_and_normalize_operators(parsed_data[component])\n                if parsed_data[component]:  # Log if operators found\n                    operator_count = sum(1 for v in parsed_data[component].values()\n                                       if isinstance(v, dict) and \"operator\" in v)\n                    if operator_count &gt; 0:\n                        logger.info(f\"\u2713 Validated {operator_count} operator(s) in {component}\")\n\n        # Add english_query as temporary metadata (will be extracted by orchestrator)\n        if english_query:\n            parsed_data[\"_english_query\"] = english_query\n            logger.info(f\"\ud83c\udf10 Extracted English query: '{english_query}'\")\n\n        logger.info(f\"\u2705 Successfully parsed LLM response with {sum(len(v) for v in parsed_data.values() if isinstance(v, dict))} total features\")\n        return parsed_data\n\n    except Exception as e:\n        logger.error(f\"\u274c Failed to parse LLM response: {e}\")\n        logger.error(f\"LLM response was: {llm_response}\")\n        return fallback_master\n</code></pre> <p>Parsing Features: - Code Fence Detection: Handles ```json fences or plain JSON - Operator Validation: Ensures correct operator structure - Component Normalization: All required components present (empty dict if not specified) - Multilingual Support: Extracts english_query for Lucene search - Error Handling: Returns fallback on parse failure</p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#integration-points","title":"Integration Points","text":""},{"location":"AGENT1_PARAMETER_EXTRACTOR/#agent-2-productsearch-integration","title":"Agent 2 (ProductSearch) Integration","text":"<p>The extracted MasterParameterJSON is passed directly to Agent 2 for product search:</p> <pre><code># In orchestrator\nmaster_parameters = await self.parameter_extractor.extract_parameters(\n    user_message=user_message,\n    current_state=conversation_state.current_state,\n    master_parameters=conversation_state.master_parameters,\n)\n\n# Pass to Agent 2\nproducts = await self.search_orchestrator.search(\n    component_type=component_type,\n    master_parameters=master_parameters,\n    selected_components=conversation_state.response_json,\n)\n</code></pre> <p>Data Flow: 1. User: \"500A MIG welder for aluminum\" 2. Agent 1: <code>{\"power_source\": {\"current_rating\": \"500A\", \"process\": \"MIG (GMAW)\", \"material\": \"aluminum\"}}</code> 3. Agent 2: Searches Neo4j with these parameters 4. Agent 3: Generates response with found products</p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#error-handling","title":"Error Handling","text":"<p>LLM Call Failures: <pre><code>except Exception as e:\n    logger.error(f\"Parameter extraction failed: {e}\")\n    # Return unchanged master_parameters on error\n    return master_parameters\n</code></pre></p> <p>Parse Failures: <pre><code>except Exception as e:\n    logger.error(f\"Failed to parse LLM response: {e}\")\n    logger.error(f\"LLM response was: {llm_response}\")\n    return fallback_master\n</code></pre></p> <p>Operator Validation: <pre><code>if operator not in VALID_OPERATORS:\n    logger.warning(f\"Invalid operator '{operator}' for {key}, defaulting to 'approx'\")\n    value[\"operator\"] = \"approx\"\n</code></pre></p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#langsmith-observability","title":"LangSmith Observability","text":"<p>Tracing Decorator: <pre><code>@traceable(name=\"extract_parameters\", run_type=\"llm\")\nasync def extract_parameters(...):\n</code></pre></p> <p>Environment Variables: <pre><code>LANGSMITH_API_KEY=ls_...\nLANGSMITH_PROJECT=Recommender\nLANGSMITH_TRACING=true\n</code></pre></p> <p>What's Tracked: - LLM prompt (full ~750-line prompt) - LLM response (raw GPT-4 output) - Parsed MasterParameterJSON - Execution time - Token usage - Error traces</p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#configuration-dependencies","title":"Configuration Dependencies","text":"<p>Required Configuration: - <code>llm_context.json</code>: Product names for fuzzy matching (200+ products) - <code>component_types.json</code>: Fuzzy matching enabled components - <code>master_parameter_schema.json</code>: Component list and structure</p> <p>LLM Configuration (from ConfigurationService): <pre><code>llm_config = {\n    \"model\": \"gpt-4\",\n    \"temperature\": 0.3,\n    \"max_tokens\": 2000\n}\n\nsystem_prompt = \"You are a welding equipment expert. Extract technical parameters...\"\n</code></pre></p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#performance-metrics","title":"Performance Metrics","text":"<p>Typical Performance: - Selection Detection: ~10ms (pre-LLM fast path) - LLM Call: ~1-3s (GPT-4 extraction) - Parse &amp; Validate: ~50-100ms - Total Latency: ~2-4s for extraction</p> <p>Token Usage: - Prompt: ~10K tokens (~750-line prompt) - Response: ~500-1000 tokens - Cost per extraction: ~$0.15 (GPT-4 pricing)</p> <p>Accuracy: - Structured queries: 95%+ extraction accuracy - Product name fuzzy matching: 90%+ match rate - Operator extraction: 85%+ correct operator detection</p>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#related-documentation","title":"Related Documentation","text":"<ul> <li>Orchestrator Architecture - How Agent 1 integrates with orchestrator</li> <li>Agent 2: ProductSearch - How extracted parameters drive search</li> <li>Agent 3: MessageGenerator - Response generation</li> <li>Master Parameter JSON Architecture - Data model design</li> <li>Multilingual Flow - Translation and english_query usage</li> </ul>"},{"location":"AGENT1_PARAMETER_EXTRACTOR/#file-location","title":"File Location","text":"<p>Source: <code>src/backend/app/services/intent/parameter_extractor.py</code></p> <p>Related Files: - <code>app/config/llm_context.json</code> - Product names for fuzzy matching - <code>app/config/component_types.json</code> - Fuzzy matching configuration - <code>app/config/master_parameter_schema.json</code> - Component structure - <code>app/services/config/configuration_service.py</code> - LLM config and prompts</p>"},{"location":"AGENT2_PRODUCT_SEARCH/","title":"Agent 2: ProductSearch Architecture","text":"<p>Files: - <code>src/backend/app/services/neo4j/product_search.py</code> (Thin facade - 488 lines) - <code>src/backend/app/services/search/components/component_service.py</code> (Core implementation - 509+ lines) - <code>src/backend/app/services/search/components/query_builder.py</code> (Query generation)</p> <p>Agent 2 (ProductSearch) is the Neo4j graph database search engine that finds compatible welding products based on extracted parameters from Agent 1 and validates COMPATIBLE_WITH relationships.</p>"},{"location":"AGENT2_PRODUCT_SEARCH/#overview","title":"Overview","text":"<p>The ProductSearch is a configuration-driven search architecture that eliminates code duplication across 13+ component types through generic, reusable search logic. It uses Neo4j Cypher queries to traverse the product compatibility graph.</p> <p>Key Architecture: Configuration-Driven + Strategy Pattern - Neo4jProductSearch: Thin backward-compatible facade (488 lines) - ComponentSearchService: Generic search engine for all components (509+ lines) - Neo4jQueryBuilder: Cypher query construction - Configuration: Loaded from <code>component_types.json</code> (13+ components)</p> <p>Key Metrics: - Query Time: &lt;100ms for compatibility search - Graph Database: Neo4j 5.14.1 (async driver) - Components Supported: 13 (PowerSource, Feeder, Cooler, Interconnector, Torch, etc.) - Search Strategies: Cypher-based + Lucene full-text</p>"},{"location":"AGENT2_PRODUCT_SEARCH/#core-responsibilities","title":"Core Responsibilities","text":""},{"location":"AGENT2_PRODUCT_SEARCH/#1-neo4jproductsearch-facade-layer","title":"1. Neo4jProductSearch - Facade Layer","text":"<pre><code>class Neo4jProductSearch:\n    \"\"\"\n    Neo4j product search service - thin facade over ComponentSearchService.\n\n    Provides backward-compatible API while delegating all search logic to\n    the generic ComponentSearchService.\n\n    ALL DEPRECATED METHODS REMOVED:\n    - search_power_source_lucene (use LuceneStrategy instead)\n    - search_power_source_smart (use SmartStrategy instead)\n    - search_feeder_lucene (use LuceneStrategy instead)\n    - search_feeder_smart (use SmartStrategy instead)\n    ... (20+ deprecated methods removed)\n    \"\"\"\n\n    def __init__(self, driver):\n        \"\"\"\n        Initialize Neo4jProductSearch with shared driver.\n\n        Args:\n            driver: Neo4j AsyncDriver instance from neo4j_manager\n\n        Note:\n            Driver is managed externally by neo4j_manager - this class does not own it.\n            Do not close the driver from this class.\n        \"\"\"\n        self.driver = driver\n        self.component_service = ComponentSearchService(self.driver)\n        logger.info(\"Neo4jProductSearch initialized with shared driver\")\n</code></pre> <p>Purpose: Thin facade providing backward-compatible API while delegating to ComponentSearchService</p> <p>Design Pattern: Facade Pattern - simplifies interface to complex ComponentSearchService</p>"},{"location":"AGENT2_PRODUCT_SEARCH/#2-core-component-search-methods-s1s5","title":"2. Core Component Search Methods (S1\u2192S5)","text":"<pre><code>async def search_power_source(\n    self,\n    master_parameters: Dict[str, Any],\n    selected_components: Dict[str, Any],\n    limit: int = 10,\n    offset: int = 0\n) -&gt; SearchResults:\n    \"\"\"\n    S1: Search for power sources.\n\n    Args:\n        master_parameters: MasterParameterJSON dict\n        selected_components: ResponseJSON dict\n        limit: Maximum results\n        offset: Pagination offset\n\n    Returns:\n        SearchResults with power sources\n    \"\"\"\n    return await self.component_service.search(\n        component_type=\"power_source\",\n        master_parameters=master_parameters,\n        selected_components=selected_components,\n        limit=limit,\n        offset=offset\n    )\n</code></pre> <p>All S1\u2192S5 Methods: 1. <code>search_power_source()</code> - S1: First mandatory component 2. <code>search_feeder()</code> - S2: Compatible with PowerSource 3. <code>search_cooler()</code> - S3: Compatible with PowerSource 4. <code>search_interconnector()</code> - S4: Compatible with PowerSource + Feeder + Cooler 5. <code>search_torch()</code> - S5: Compatible with Feeder</p> <p>Common Pattern: All delegate to <code>ComponentSearchService.search()</code> with different <code>component_type</code></p>"},{"location":"AGENT2_PRODUCT_SEARCH/#3-componentsearchservice-core-search-engine","title":"3. ComponentSearchService - Core Search Engine","text":"<pre><code>class ComponentSearchService:\n    \"\"\"\n    Generic component search service for all product types.\n\n    Responsibilities:\n    - Execute Cypher-based searches using Neo4jQueryBuilder\n    - Execute Lucene full-text searches\n    - Handle GIN direct lookups\n    - Handle product name matching\n    - Parse and return search results\n\n    Used by both CypherStrategy and LuceneStrategy.\n    \"\"\"\n\n    def __init__(self, driver: AsyncGraphDatabase.driver):\n        \"\"\"\n        Initialize component search service.\n\n        Args:\n            driver: Neo4j async driver instance\n        \"\"\"\n        self.driver = driver\n\n        # Load component configuration from centralized config directory\n        self.component_config = load_component_config()\n\n        # Initialize query builder\n        self.query_builder = Neo4jQueryBuilder(self.component_config)\n\n        logger.info(f\"ComponentSearchService initialized with {len(self.component_config)} component types\")\n</code></pre> <p>Configuration-Driven: All component-specific logic defined in <code>component_types.json</code>: <pre><code>{\n  \"power_source\": {\n    \"neo4j_label\": \"Product\",\n    \"category\": \"Power Source\",\n    \"master_param_key\": \"power_source\",\n    \"requires_compatibility\": false,\n    \"lucene_enabled\": true,\n    \"fuzzy_matching_enabled\": true\n  },\n  \"feeder\": {\n    \"neo4j_label\": \"Product\",\n    \"category\": \"Feeder\",\n    \"master_param_key\": \"feeder\",\n    \"requires_compatibility\": true,\n    \"lucene_enabled\": true,\n    \"fuzzy_matching_enabled\": true\n  }\n}\n</code></pre></p>"},{"location":"AGENT2_PRODUCT_SEARCH/#4-main-search-flow","title":"4. Main Search Flow","text":"<pre><code>async def search(\n    self,\n    component_type: str,\n    master_parameters: Dict[str, Any],\n    selected_components: Dict[str, Any],\n    limit: int = 10,\n    offset: int = 0\n) -&gt; SearchResults:\n    \"\"\"\n    Generic component search using Cypher queries.\n\n    This is the primary search method used by CypherStrategy.\n\n    Flow:\n    1. Check for GIN in component parameters \u2192 direct lookup\n    2. Check for product_name \u2192 name-based search\n    3. Build search terms from component parameters\n    4. Execute search with fallback logic\n\n    Args:\n        component_type: Type of component (e.g., \"power_source\", \"feeder\")\n        master_parameters: MasterParameterJSON dict\n        selected_components: ResponseJSON dict (already selected components)\n        limit: Maximum results to return\n        offset: Pagination offset\n\n    Returns:\n        SearchResults with products, filters_applied, and pagination metadata\n    \"\"\"\n    # Get component parameters\n    config = self.component_config.get(component_type)\n    if not config:\n        raise ValueError(f\"Unknown component type: {component_type}\")\n\n    master_param_key = config[\"master_param_key\"]\n    # Convert Pydantic model to dict if needed\n    master_params_dict = master_parameters.model_dump() if hasattr(master_parameters, 'model_dump') else master_parameters\n    component_dict = master_params_dict.get(master_param_key, {})\n\n    # STEP 1: Check for GIN direct lookup\n    detected_gin = component_dict.get(\"_detected_gin\")\n    if detected_gin:\n        logger.info(f\"Using GIN-based search for {component_type}: {detected_gin}\")\n        product = await self._search_by_gin_direct(detected_gin, config[\"category\"])\n        if product:\n            return SearchResults(\n                products=[product],\n                total_count=1,\n                filters_applied={\n                    \"search_method\": \"gin_direct\",\n                    \"gin\": detected_gin\n                },\n                compatibility_validated=config.get(\"requires_compatibility\", False),\n                offset=offset,\n                limit=limit,\n                has_more=False\n            )\n\n    # STEP 2: Check for product name \u2192 name-based search\n    product_name = component_dict.get(\"product_name\")\n    if product_name and isinstance(product_name, str) and product_name.strip():\n        logger.info(f\"Product name provided for {component_type}: {product_name}\")\n\n        # Build name-based query\n        query, params = self.query_builder.build_base_query(component_type, \"p\")\n\n        # Add product name filter (SPACE-INSENSITIVE - Nov 15, 2024)\n        # Removes all spaces before comparison to handle \"Renegade ES 300i\" vs \"Renegade ES300i\"\n        query += f\"\\nAND replace(toLower(p.item_name), ' ', '') CONTAINS replace(toLower($product_name), ' ', '')\"\n        params[\"product_name\"] = product_name.strip()\n\n        logger.info(f\"Added SPACE-INSENSITIVE product_name filter: '{product_name}'\")\n\n        # Add compatibility filters if needed\n        if config.get(\"requires_compatibility\"):\n            query, params, _ = self.query_builder.add_compatibility_filters(\n                query, params, component_type, selected_components, \"p\"\n            )\n\n        # Add ordering and pagination\n        query = self.query_builder.add_priority_ordering(query, \"p\", \"r\")\n        query += f\"\\nSKIP $offset LIMIT $limit\"\n        params[\"offset\"] = offset\n        params[\"limit\"] = limit + 1  # Query one extra to check has_more\n\n        # Add RETURN clause\n        query += self.query_builder.build_return_clause(\"p\", include_score=False)\n\n        # Execute name-based search\n        products = await self._execute_search(query, params)\n\n        if products:\n            has_more = len(products) &gt; limit\n            if has_more:\n                products = products[:limit]\n\n            return SearchResults(\n                products=products,\n                total_count=len(products),\n                filters_applied={\n                    \"search_method\": \"name_based\",\n                    \"product_name\": product_name\n                },\n                compatibility_validated=config.get(\"requires_compatibility\", False),\n                offset=offset,\n                limit=limit,\n                has_more=has_more\n            )\n\n    # STEP 3: Build search terms from component parameters\n    search_terms_dict = self.query_builder.build_search_terms_from_component(\n        component_dict, component_type\n    )\n\n    # STEP 4: Build primary query WITH search term filters\n    primary_query, primary_params = self.query_builder.build_base_query(component_type, \"p\")\n\n    # Add compatibility filters if needed\n    if config.get(\"requires_compatibility\"):\n        primary_query, primary_params, _ = self.query_builder.add_compatibility_filters(\n            primary_query, primary_params, component_type, selected_components, \"p\"\n        )\n\n    # Add search term filters\n    primary_query, primary_params = self.query_builder.add_search_term_filters(\n        primary_query, primary_params, search_terms_dict, \"p\"\n    )\n\n    # Add ordering\n    primary_query = self.query_builder.add_priority_ordering(primary_query, \"p\", \"r\")\n\n    # Add pagination\n    primary_query, primary_params = self.query_builder.add_pagination(\n        primary_query, primary_params, offset, limit + 1\n    )\n\n    # Add RETURN clause\n    primary_query += self.query_builder.build_return_clause(\"p\", include_score=False)\n\n    # STEP 5: Build fallback query WITHOUT search term filters\n    fallback_query, fallback_params = self.query_builder.build_base_query(component_type, \"p\")\n\n    # Add compatibility filters\n    if config.get(\"requires_compatibility\"):\n        fallback_query, fallback_params, _ = self.query_builder.add_compatibility_filters(\n            fallback_query, fallback_params, component_type, selected_components, \"p\"\n        )\n\n    # Add ordering and pagination\n    fallback_query = self.query_builder.add_priority_ordering(fallback_query, \"p\", \"r\")\n    fallback_query, fallback_params = self.query_builder.add_pagination(\n        fallback_query, fallback_params, offset, limit + 1\n    )\n    fallback_query += self.query_builder.build_return_clause(\"p\", include_score=False)\n\n    # STEP 6: Execute search with fallback\n    products, filters_applied = await self._execute_search_with_fallback(\n        primary_query, primary_params,\n        fallback_query, fallback_params,\n        search_terms_dict.get(\"feature_terms\", []),\n        {\"search_method\": \"cypher\"},\n        config[\"neo4j_label\"]\n    )\n\n    # Check for pagination\n    has_more = len(products) &gt; limit\n    if has_more:\n        products = products[:limit]\n\n    return SearchResults(\n        products=products,\n        total_count=len(products),\n        filters_applied=filters_applied,\n        compatibility_validated=config.get(\"requires_compatibility\", False),\n        offset=offset,\n        limit=limit,\n        has_more=has_more\n    )\n</code></pre> <p>Search Flow Summary: 1. GIN Direct Lookup: Fastest path - direct GIN match (10-digit product ID) 2. Product Name Search: Space-insensitive matching on <code>item_name</code> field 3. Feature-Based Search: Extract search terms from parameters \u2192 build Cypher WHERE clauses 4. Compatibility Validation: Add COMPATIBLE_WITH relationship filters 5. Fallback Logic: If no results with filters \u2192 try without filters 6. Pagination: Support for offset/limit with <code>has_more</code> flag</p>"},{"location":"AGENT2_PRODUCT_SEARCH/#5-gin-direct-lookup","title":"5. GIN Direct Lookup","text":"<pre><code>async def _search_by_gin_direct(\n    self,\n    gin: str,\n    category: Optional[str] = None\n) -&gt; Optional[ProductResult]:\n    \"\"\"\n    Direct GIN lookup without category/compatibility restrictions.\n\n    Flexible category matching - returns product even if category doesn't match.\n\n    Args:\n        gin: Product GIN (10-digit identifier)\n        category: Optional expected category (for logging/validation)\n\n    Returns:\n        ProductResult if found, None otherwise\n    \"\"\"\n    query = \"\"\"\n    MATCH (p:Product)\n    WHERE p.gin = $gin\n    RETURN p.gin as gin, p.item_name as name, p.category as category,\n        p.clean_description as description,\n        p.attributes_ruleset as specifications_json,\n        p as specifications\n    LIMIT 1\n    \"\"\"\n\n    params = {\"gin\": gin}\n\n    try:\n        async with self.driver.session() as session:\n            result = await session.run(query, params)\n            records = await result.data()\n\n            if records:\n                record = records[0]\n                found_category = record[\"category\"]\n\n                logger.info(f\"\ud83d\udd0d GIN {gin} found with category: '{found_category}'\")\n\n                # Log category mismatch (if specified)\n                if category:\n                    category_normalized = category.lower().replace(\" \", \"\")\n                    found_normalized = found_category.lower().replace(\" \", \"\")\n\n                    if category_normalized not in found_normalized and found_normalized not in category_normalized:\n                        logger.warning(\n                            f\"\u26a0\ufe0f GIN {gin} category mismatch: \"\n                            f\"Expected '{category}', Found '{found_category}'\"\n                        )\n\n                # Build product result\n                specs = record.get(\"specifications\", {})\n                if hasattr(specs, \"__dict__\"):\n                    specs = dict(specs)\n                specs = self._clean_neo4j_types(specs)\n\n                product = ProductResult(\n                    gin=record[\"gin\"],\n                    name=record[\"name\"],\n                    category=record[\"category\"],\n                    description=record.get(\"description\"),\n                    specifications=specs\n                )\n\n                logger.info(f\"\u2705 Found product by GIN: {product.name} ({product.category})\")\n                return product\n            else:\n                logger.warning(f\"\u274c No product found for GIN: {gin}\")\n                return None\n\n    except Exception as e:\n        logger.error(f\"GIN search failed: {e}\")\n        return None\n</code></pre> <p>Purpose: Fastest search path for known GIN identifiers</p> <p>Performance: ~10-20ms (direct index lookup in Neo4j)</p> <p>Usage Example: User says \"I need 0446200880\" \u2192 Agent 1 extracts GIN \u2192 Agent 2 direct lookup</p>"},{"location":"AGENT2_PRODUCT_SEARCH/#6-fallback-search-logic","title":"6. Fallback Search Logic","text":"<pre><code>async def _execute_search_with_fallback(\n    self,\n    primary_query: str,\n    primary_params: Dict[str, Any],\n    fallback_query: str,\n    fallback_params: Dict[str, Any],\n    search_terms: List[str],\n    filters_applied: Dict[str, Any],\n    category: str\n) -&gt; Tuple[List[ProductResult], Dict[str, Any]]:\n    \"\"\"\n    Execute search with fallback logic.\n\n    If primary query returns 0 results and search terms were applied,\n    falls back to query without search term filters.\n\n    Args:\n        primary_query: Query WITH search term filters\n        primary_params: Primary query parameters\n        fallback_query: Query WITHOUT search term filters\n        fallback_params: Fallback query parameters\n        search_terms: List of search terms that were applied\n        filters_applied: Metadata dict to update\n        category: Component category for logging\n\n    Returns:\n        Tuple of (products, updated_filters_applied)\n    \"\"\"\n    # Execute primary query\n    products = await self._execute_search(primary_query, primary_params)\n\n    # Fallback logic\n    if search_terms and len(products) == 0:\n        logger.info(\n            f\"No {category} found matching search terms, \"\n            f\"falling back to all compatible {category}\"\n        )\n        products = await self._execute_search(fallback_query, fallback_params)\n\n        if products:\n            filters_applied[\"fallback_used\"] = True\n            filters_applied[\"original_search_terms\"] = search_terms\n            filters_applied[\"message\"] = (\n                f\"No exact matches found for '{', '.join(search_terms)}'. \"\n                f\"Below are alternative {category} options based on compatibility and features.\"\n            )\n\n    return products, filters_applied\n</code></pre> <p>Fallback Strategy: 1. Primary Query: Search with all feature filters (e.g., \"water-cooled\", \"500A\", \"MIG\") 2. Fallback Query: Search with only compatibility filters (if primary returns 0 results) 3. User Feedback: Clear message explaining fallback behavior</p> <p>User Experience: <pre><code>User: \"water-cooled feeder for Aristo 500ix\"\nAgent 1: Extracts {\"cooling_type\": \"water-cooled\"}\nAgent 2 Primary: Searches for water-cooled feeders compatible with Aristo\nAgent 2 Fallback (if 0 results): Shows ALL feeders compatible with Aristo\n\nResponse: \"No exact matches found for 'water-cooled'. Below are alternative Feeder options based on compatibility and features.\"\n</code></pre></p>"},{"location":"AGENT2_PRODUCT_SEARCH/#7-lucene-full-text-search","title":"7. Lucene Full-Text Search","text":"<pre><code>async def search_with_lucene(\n    self,\n    component_type: str,\n    user_message: str,\n    selected_components: Dict[str, Any],\n    limit: int = 10,\n    offset: int = 0\n) -&gt; SearchResults:\n    \"\"\"\n    Generic component search using Lucene full-text search.\n\n    This is the method used by LuceneStrategy.\n\n    Args:\n        component_type: Type of component\n        user_message: User's search message (raw query)\n        selected_components: ResponseJSON dict (already selected components)\n        limit: Maximum results to return\n        offset: Pagination offset\n\n    Returns:\n        SearchResults with products and Lucene scores\n    \"\"\"\n    config = self.component_config.get(component_type)\n    if not config:\n        raise ValueError(f\"Unknown component type: {component_type}\")\n\n    if not config.get(\"lucene_enabled\"):\n        raise ValueError(f\"Lucene search not enabled for {component_type}\")\n\n    # Build Lucene query\n    query, params = self.query_builder.build_lucene_query(\n        component_type, user_message, \"p\"\n    )\n\n    # Add compatibility filters if needed\n    if config.get(\"requires_compatibility\"):\n        query, params, _ = self.query_builder.add_compatibility_filters(\n            query, params, component_type, selected_components, \"p\"\n        )\n\n    # Add ordering and pagination\n    query += f\"\\nORDER BY score DESC, p.item_name\"\n    query, params = self.query_builder.add_pagination(query, params, offset, limit + 1)\n\n    # Add RETURN clause with score\n    query += self.query_builder.build_return_clause(\"p\", include_score=True)\n\n    # Execute Lucene search\n    products = await self._execute_search(query, params)\n\n    # Check for pagination\n    has_more = len(products) &gt; limit\n    if has_more:\n        products = products[:limit]\n\n    return SearchResults(\n        products=products,\n        total_count=len(products),\n        filters_applied={\n            \"search_method\": \"lucene\",\n            \"query\": user_message\n        },\n        compatibility_validated=config.get(\"requires_compatibility\", False),\n        offset=offset,\n        limit=limit,\n        has_more=has_more\n    )\n</code></pre> <p>Purpose: Full-text search using Neo4j's Lucene index</p> <p>Lucene Query Example: <pre><code>CALL db.index.fulltext.queryNodes('productIndex', $search_query)\nYIELD node AS p, score\nWHERE p.category = $category\nRETURN p.gin, p.item_name as name, p.category,\n       p.clean_description as description,\n       p as specifications,\n       score\nORDER BY score DESC, p.item_name\n</code></pre></p> <p>Use Case: When user query is natural language without structured parameters</p>"},{"location":"AGENT2_PRODUCT_SEARCH/#8-query-execution-and-result-parsing","title":"8. Query Execution and Result Parsing","text":"<pre><code>async def _execute_search(\n    self,\n    query: str,\n    params: Dict[str, Any]\n) -&gt; List[ProductResult]:\n    \"\"\"\n    Execute Neo4j search query and return results.\n\n    Args:\n        query: Cypher query string\n        params: Query parameters\n\n    Returns:\n        List of ProductResult objects\n    \"\"\"\n    # DETAILED LOGGING for query troubleshooting (Nov 15, 2024)\n    logger.info(\"=\" * 80)\n    logger.info(\"\ud83d\udd0d EXECUTING NEO4J CYPHER QUERY\")\n    logger.info(f\"Query:\\n{query}\")\n    logger.info(f\"Params: {params}\")\n    logger.info(\"=\" * 80)\n\n    try:\n        async with self.driver.session() as session:\n            result = await session.run(query, params)\n            records = await result.data()\n\n            products = []\n            for record in records:\n                specs = record.get(\"specifications\", {})\n                if hasattr(specs, \"__dict__\"):\n                    specs = dict(specs)\n                specs = self._clean_neo4j_types(specs)\n\n                # \ud83d\udd27 FIX (Nov 15, 2024): Preserve native Lucene fulltext scores\n                # Root cause: Lucene queries return score field but it was being discarded\n                # Solution: Extract score from Neo4j result and store in specifications\n                if \"score\" in record:\n                    lucene_score = float(record[\"score\"])\n                    specs[\"lucene_score\"] = lucene_score\n                    logger.info(f\"  \u2192 Product {record['gin']} native Lucene score: {lucene_score}\")\n\n                product = ProductResult(\n                    gin=record[\"gin\"],\n                    name=record[\"name\"],\n                    category=record[\"category\"],\n                    description=record.get(\"description\"),\n                    specifications=specs\n                )\n                products.append(product)\n\n            logger.info(f\"Search returned {len(products)} products\")\n            return products\n\n    except Exception as e:\n        logger.error(f\"Neo4j search failed: {e}\")\n        logger.error(f\"Query: {query}\")\n        logger.error(f\"Params: {params}\")\n        return []\n</code></pre> <p>Key Features: - Detailed Logging: Full Cypher query and parameters logged for debugging - Lucene Score Preservation: Native Lucene scores preserved in specifications - Neo4j Type Cleaning: Converts Neo4j-specific types to JSON-serializable types - Error Handling: Returns empty list on error (logs details for debugging)</p>"},{"location":"AGENT2_PRODUCT_SEARCH/#integration-with-agent-1-and-agent-3","title":"Integration with Agent 1 and Agent 3","text":""},{"location":"AGENT2_PRODUCT_SEARCH/#data-flow-from-agent-1-to-agent-2","title":"Data Flow from Agent 1 to Agent 2","text":"<pre><code># Agent 1 extracts parameters\nmaster_parameters = await parameter_extractor.extract_parameters(\n    user_message=\"500A MIG welder for aluminum\",\n    current_state=\"power_source_selection\",\n    master_parameters=existing_master_params\n)\n\n# Result:\n{\n    \"power_source\": {\n        \"current_rating\": \"500A\",\n        \"process\": \"MIG (GMAW)\",\n        \"material\": \"aluminum\"\n    },\n    \"feeder\": {},\n    ...\n}\n\n# Agent 2 searches based on extracted parameters\nsearch_results = await product_search.search_power_source(\n    master_parameters=master_parameters,\n    selected_components=response_json,\n    limit=10,\n    offset=0\n)\n\n# Result:\nSearchResults(\n    products=[\n        ProductResult(gin=\"0446200880\", name=\"Aristo 500ix CE\", ...),\n        ProductResult(gin=\"0465350883\", name=\"Warrior 500i\", ...),\n        ...\n    ],\n    total_count=3,\n    filters_applied={\n        \"search_method\": \"cypher\",\n        \"search_terms\": [\"500A\", \"MIG\", \"aluminum\"]\n    },\n    compatibility_validated=False,\n    has_more=False\n)\n</code></pre>"},{"location":"AGENT2_PRODUCT_SEARCH/#data-flow-from-agent-2-to-agent-3","title":"Data Flow from Agent 2 to Agent 3","text":"<pre><code># Agent 2 returns search results\nsearch_results = SearchResults(\n    products=[...],\n    filters_applied={...},\n    compatibility_validated=True\n)\n\n# Agent 3 generates user-friendly response\nresponse = await message_generator.generate_response(\n    current_state=\"power_source_selection\",\n    search_results=search_results.products,  # List of ProductResult\n    master_parameters=master_parameters,\n    response_json=response_json,\n    language=\"en\"\n)\n\n# Agent 3 formats products into readable list with names, descriptions, and selection instructions\n</code></pre>"},{"location":"AGENT2_PRODUCT_SEARCH/#compatibility-validation","title":"Compatibility Validation","text":"<p>COMPATIBLE_WITH Relationships: <pre><code>// Example: Feeder compatibility with PowerSource\nMATCH (ps:Product {gin: $power_source_gin})\nMATCH (feeder:Product)-[r:COMPATIBLE_WITH]-&gt;(ps)\nWHERE feeder.category = \"Feeder\"\nRETURN feeder\nORDER BY r.priority\n</code></pre></p> <p>Compatibility Matrix: - PowerSource \u2192 No compatibility required (first component) - Feeder \u2192 Must be compatible with PowerSource - Cooler \u2192 Must be compatible with PowerSource - Interconnector \u2192 Must be compatible with PowerSource + Feeder + Cooler - Torch \u2192 Must be compatible with Feeder - Accessories \u2192 Compatible with any selected components</p> <p>Triple Compatibility Example (Interconnector): <pre><code>MATCH (ps:Product {gin: $power_source_gin})\nMATCH (f:Product {gin: $feeder_gin})\nMATCH (c:Product {gin: $cooler_gin})\nMATCH (interconn:Product)-[:COMPATIBLE_WITH]-&gt;(ps)\nMATCH (interconn)-[:COMPATIBLE_WITH]-&gt;(f)\nMATCH (interconn)-[:COMPATIBLE_WITH]-&gt;(c)\nWHERE interconn.category = \"Interconnector\"\nRETURN interconn\n</code></pre></p>"},{"location":"AGENT2_PRODUCT_SEARCH/#performance-optimization","title":"Performance Optimization","text":"<p>Index Strategy: - Primary Key: <code>gin</code> (10-digit product identifier) - Category Index: <code>category</code> field for category filtering - Lucene Full-Text Index: <code>item_name</code>, <code>clean_description</code>, <code>attributes_ruleset</code></p> <p>Query Performance: - GIN Direct Lookup: ~10-20ms - Compatibility Search: ~50-100ms - Lucene Full-Text Search: ~100-200ms - Typical Total Latency: &lt;100ms</p> <p>Async Architecture: - Non-blocking I/O with Neo4j async driver - Connection pooling for concurrent requests - Parallel searches for compound requests</p>"},{"location":"AGENT2_PRODUCT_SEARCH/#error-handling","title":"Error Handling","text":"<p>Query Execution Failures: <pre><code>except Exception as e:\n    logger.error(f\"Neo4j search failed: {e}\")\n    logger.error(f\"Query: {query}\")\n    logger.error(f\"Params: {params}\")\n    return []\n</code></pre></p> <p>Unknown Component Type: <pre><code>if not config:\n    raise ValueError(f\"Unknown component type: {component_type}\")\n</code></pre></p> <p>Lucene Disabled: <pre><code>if not config.get(\"lucene_enabled\"):\n    raise ValueError(f\"Lucene search not enabled for {component_type}\")\n</code></pre></p>"},{"location":"AGENT2_PRODUCT_SEARCH/#configuration-dependencies","title":"Configuration Dependencies","text":"<p>Required Configuration Files: - <code>component_types.json</code>: Component definitions (13+ components)   - neo4j_label, category, master_param_key   - requires_compatibility, lucene_enabled, fuzzy_matching_enabled</p> <p>Neo4j Database Requirements: - Product nodes with properties: <code>gin</code>, <code>item_name</code>, <code>category</code>, <code>clean_description</code> - COMPATIBLE_WITH relationships with optional <code>priority</code> property - Lucene full-text index on Product nodes</p> <p>Environment Variables: <pre><code>NEO4J_URI=neo4j://localhost:7687  # or bolt+s://xxxxx.databases.neo4j.io\nNEO4J_USERNAME=neo4j\nNEO4J_PASSWORD=password\n</code></pre></p>"},{"location":"AGENT2_PRODUCT_SEARCH/#related-documentation","title":"Related Documentation","text":"<ul> <li>Orchestrator Architecture - How Agent 2 integrates with orchestrator</li> <li>Agent 1: ParameterExtractor - How parameters drive search</li> <li>Agent 3: MessageGenerator - How search results are formatted</li> <li>Master Parameter JSON Architecture - Data model design</li> <li>Context-Based Search Strategies - Cypher vs Lucene strategies</li> </ul>"},{"location":"AGENT2_PRODUCT_SEARCH/#file-locations","title":"File Locations","text":"<p>Source Files: - <code>src/backend/app/services/neo4j/product_search.py</code> - Neo4jProductSearch facade (488 lines) - <code>src/backend/app/services/search/components/component_service.py</code> - ComponentSearchService (509+ lines) - <code>src/backend/app/services/search/components/query_builder.py</code> - Neo4jQueryBuilder</p> <p>Related Files: - <code>app/config/component_types.json</code> - Component configuration - <code>app/models/product_search.py</code> - ProductResult and SearchResults models</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/","title":"Agent 3: MessageGenerator - Response Generation Architecture","text":"<p>File: <code>src/backend/app/services/response/message_generator.py</code></p> <p>The MessageGenerator is the third and final agent in the 3-agent system, responsible for generating user-friendly multilingual responses from search results and state transitions. It combines template-based prompts with LLM-powered translation and Q&amp;A capabilities.</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/#overview","title":"Overview","text":"<p>Agent 3 generates natural language responses for the S1\u2192SN configurator workflow. It bridges the gap between technical product data (from Agent 2) and user-facing conversation, supporting 7 languages and maintaining conversational context throughout the configuration process.</p> <p>Architecture Pattern: Template-Based + LLM Translation + Q&amp;A Capability</p> <p>Key Metrics: - Languages: 7 supported (en, es, fr, de, pt, it, sv) - Prompt Types: 13+ state-specific prompts + 9 accessory categories - Response Types: State prompts, search results, selections, confirmations, errors, Q&amp;A - Translation: GPT-4o-mini with context-aware prompting - Q&amp;A Model: GPT-4o-mini with ESAB-only system prompt (3-layer anti-hallucination)</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/#core-responsibilities","title":"Core Responsibilities","text":""},{"location":"AGENT3_MESSAGE_GENERATOR/#1-initialization-and-configuration","title":"1. Initialization and Configuration","text":"<pre><code>def __init__(self, openai_api_key: Optional[str] = None):\n    \"\"\"Initialize message generator\"\"\"\n    self.translator = get_translator()\n    self.openai_client = AsyncOpenAI(api_key=openai_api_key)\n    self.config_service = get_config_service()\n    self.prompt_service = get_prompt_service()\n\n    # Load LLM-extracted category features for intelligent guidance\n    self.category_features = self._load_category_features()\n\n    logger.info(\"\u2705 Message Generator initialized with multilingual support + Accessory Categories + Anti-Hallucination Guards + LLM Feature Guidance\")\n</code></pre> <p>Key Components: - <code>MultilingualTranslator</code>: LLM-based translation service (7 languages) - <code>OpenAI AsyncClient</code>: GPT-4o-mini for Q&amp;A and translation - <code>ConfigurationService</code>: Loads state_prompts.json and component_types.json - <code>PromptService</code>: Template rendering and error message formatting - <code>category_features</code>: LLM-extracted feature guidance from llm_context.json</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/#2-unified-response-generation-router","title":"2. Unified Response Generation Router","text":"<p>The <code>generate_response()</code> method is the main entry point for all response generation, routing to appropriate handlers based on message type.</p> <pre><code>async def generate_response(\n    self,\n    message_type: str,\n    state: str,\n    products: List[Dict[str, Any]] = None,\n    selected_product: Dict[str, Any] = None,\n    language: str = \"en\",\n    custom_message: str = None,\n    error_type: str = None,\n    details: str = \"\",\n    response_json: Dict[str, Any] = None,\n    zero_results_message: str = None,\n    compatibility_skip_message: str = None,\n) -&gt; str:\n    \"\"\"\n    Unified response generation router - maps message types to appropriate methods.\n\n    Args:\n        message_type: Type of message (\"selection\", \"auto_selection\", \"search_results\", \"error\", \"finalize\", \"skip\")\n        state: Current configurator state\n        products: List of products (for search_results)\n        selected_product: Selected product (for selection/auto_selection)\n        language: Response language\n        custom_message: Optional custom message to prepend\n        error_type: Error type (for error messages)\n        details: Error details (for error messages)\n        response_json: Response JSON (for finalize)\n        zero_results_message: Message to display when no products found\n        compatibility_skip_message: Message explaining compatibility validation yielded no results\n\n    Returns:\n        Generated message string\n    \"\"\"\n    # Convert Pydantic model to dict if needed (similar to parameter_extractor.py fix)\n    if selected_product and hasattr(selected_product, 'dict'):\n        selected_product = selected_product.dict()\n\n    if message_type in [\"selection\", \"auto_selection\"]:\n        # Use custom message if provided, otherwise generate confirmation\n        if custom_message:\n            return custom_message\n        elif selected_product:\n            component_type = selected_product.get(\"category\", \"Component\")\n            return self.generate_selection_confirmation(\n                component_type,\n                selected_product.get(\"name\", \"\"),\n                selected_product.get(\"gin\", \"\")\n            )\n        else:\n            return \"Selection confirmed.\"\n\n    elif message_type == \"search_results\":\n        # Prepend compatibility skip message if provided\n        prefix = f\"{compatibility_skip_message}\\n\\n\" if compatibility_skip_message else \"\"\n\n        # Generate search results message from product list\n        if products and len(products) &gt; 0:\n            # Format product list (simplified version)\n            component_name = self._get_component_name(state)\n            message = f\"Here are the {component_name} options:\\n\\n\"\n\n            # List top 5 products\n            for idx, product in enumerate(products[:5], 1):\n                message += f\"{idx}. **{product.get('name', 'Unknown')}** (GIN: {product.get('gin', 'N/A')})\\n\"\n\n            message += f\"\\n\u2705 Please select a {component_name} or say 'skip' if not needed.\"\n            return prefix + message\n        elif zero_results_message:\n            return prefix + zero_results_message\n        else:\n            state_prompt = await self.generate_state_prompt(state, response_json or {}, language)\n            return prefix + state_prompt\n\n    elif message_type == \"error\":\n        # Generate error message\n        return self.generate_error_message(error_type or \"unknown\", details)\n\n    elif message_type == \"finalize\":\n        # Generate finalization message\n        finalize_prompt = await self.generate_state_prompt(\"finalize\", response_json or {}, language)\n\n        # Prepend compatibility skip message if provided\n        if compatibility_skip_message:\n            return f\"{compatibility_skip_message}\\n\\n{finalize_prompt}\"\n\n        return finalize_prompt\n\n    elif message_type == \"skip\":\n        # Generate skip confirmation\n        component_key = state.replace(\"_selection\", \"\")\n        return self.generate_skip_confirmation(component_key, component_key)\n\n    else:\n        # Unknown message type - return generic message\n        return f\"Message type '{message_type}' not recognized.\"\n</code></pre> <p>Message Type Routing: - selection/auto_selection: Product selection confirmation with GIN - search_results: Product list formatting (top 5 with numbered display) - error: User-friendly error messages with context - finalize: Configuration summary (package generation in progress) - skip: Skip confirmation for optional components</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/#3-qa-capability-with-anti-hallucination-safeguards","title":"3. Q&amp;A Capability with Anti-Hallucination Safeguards","text":"<p>Agent 3 can answer user questions about welding equipment using LLM with 3-layer protection against hallucination.</p> <pre><code>async def generate_qa_response(\n    self,\n    question: str,\n    context: Dict[str, Any],\n    language: str = \"en\",\n) -&gt; str:\n    \"\"\"\n    Generate LLM-powered answer to user questions.\n    \ud83d\udd12 THREE-LAYER ANTI-HALLUCINATION PROTECTION:\n    - Layer 1: Competitor query blocking\n    - Layer 2: Vague query normalization with ESAB fallbacks\n    - Layer 3: ESAB-only system prompt enforcement\n\n    Args:\n        question: User's question\n        context: Current session context with keys:\n            - current_state: Current configuration state\n            - response_json: Selected components\n            - master_parameters: User requirements\n        language: Target language for response\n\n    Returns:\n        Natural language answer maintaining conversational flow\n    \"\"\"\n    try:\n        # \ud83d\udd12 LAYER 1 \u2014 Competitor guard (prevent brand hallucination)\n        if self._is_competitor_query(question):\n            logger.info(\"\ud83d\udeab Competitor query blocked for domain safety\")\n            return (\n                \"Sorry, I can only recommend ESAB welding equipment and accessories \"\n                \"compatible with your current setup.\"\n            )\n\n        # \ud83d\udd12 LAYER 2 \u2014 Normalize vague \"best/good/suggest\" questions\n        # Prevents hallucination by providing concrete ESAB examples\n        lower_q = question.lower()\n        if any(keyword in lower_q for keyword in [\"best\", \"good\", \"suggest\", \"recommend\"]):\n            # Optional quick ESAB-based fallback from Neo4j\n            try:\n                from ..neo4j.product_search import Neo4jProductSearch\n                search = Neo4jProductSearch(\"bolt://localhost:7687\", \"neo4j\", \"test\")\n                products = await search._simple_neo4j_search(\"PowerSource\", [\"aristo\"], [])\n                if products:\n                    top = \", \".join(p.name for p in products[:3])\n                    return f\"ESAB offers excellent power sources such as {top}.\"\n            except Exception:\n                pass\n\n            # Fallback to hardcoded ESAB examples\n            return (\n                \"ESAB offers several high-performance power sources such as \"\n                \"Aristo 500ix, Warrior 500i, and Renegade ES300i.\"\n            )\n\n        # \ud83d\udd12 LAYER 3 \u2014 Build contextual prompt with ESAB-only enforcement\n        prompt = self._build_qa_prompt(question, context)\n\n        # Get response from model with ESAB-only system prompt\n        answer = await self._call_llm_for_qa(prompt, language)\n\n        if not answer.endswith(('.', '!', '?')):\n            answer += '.'\n\n        logger.info(f\"\u2705 Q&amp;A response generated for question: {question[:50]}...\")\n        return answer\n\n    except Exception as e:\n        logger.error(f\"\u274c Q&amp;A generation failed: {e}\", exc_info=True)\n        return self._fallback_qa_response(question)\n</code></pre> <p>3-Layer Anti-Hallucination Protection: 1. Competitor Blocking: Detects competitor brand mentions (Lincoln, Miller, Fronius, etc.) 2. Vague Query Normalization: Handles \"best/good/suggest\" with concrete ESAB examples 3. ESAB-Only System Prompt: Restricts LLM to ESAB domain knowledge only</p> <pre><code># \ud83d\udd12 COMPETITOR BLOCKING - Prevents hallucination about other brands\nCOMPETITOR_KEYWORDS = [\n    \"lincoln\", \"miller\", \"fronius\", \"panasonic\", \"ewm\",\n    \"kemppi\", \"hypertherm\", \"otc\", \"riland\", \"eset\", \"thermal arc\"\n]\n\n# \ud83d\udd12 ESAB-ONLY SYSTEM PROMPT - Restricts LLM to domain knowledge\nESAB_ONLY_SYSTEM_PROMPT = \"\"\"\nYou are an ESAB Welding Configurator assistant.\nYou must answer ONLY using ESAB product data or the user's configuration context.\nNever mention, compare with, or suggest non-ESAB brands such as Lincoln, Miller, Fronius, etc.\nIf the user asks about other brands or generic \"best\" products, reply:\n\"Sorry, I can only recommend ESAB welding equipment and accessories compatible with your setup.\"\nBe concise, factual, and stay strictly within ESAB's ecosystem.\n\"\"\"\n\ndef _is_competitor_query(self, text: str) -&gt; bool:\n    \"\"\"\n    \ud83d\udd12 LAYER 1: Detect if user mentioned another manufacturer\n    Prevents hallucination about competitor products\n    \"\"\"\n    return any(brand in text.lower() for brand in self.COMPETITOR_KEYWORDS)\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#4-llm-qa-call-with-esab-only-enforcement","title":"4. LLM Q&amp;A Call with ESAB-Only Enforcement","text":"<pre><code>async def _call_llm_for_qa(self, prompt: str, language: str) -&gt; str:\n    \"\"\"\n    Call OpenAI GPT-4o-mini for Q&amp;A responses with anti-hallucination safeguards.\n\n    Executes LLM query using ESAB-only system prompt to prevent brand hallucination\n    and ensure responses stay within domain boundaries. Configured for factual,\n    concise responses with lower temperature.\n\n    Args:\n        prompt: Complete user prompt with question and context (from _build_qa_prompt)\n        language: ISO 639-1 language code for response (e.g., \"en\", \"es\", \"fr\")\n\n    Returns:\n        str: LLM-generated answer text (stripped of whitespace).\n            - Factual and concise (max 300 tokens)\n            - ESAB-only domain (no competitor mentions)\n            - Translated to target language if not English\n\n    System Prompt Configuration:\n        - **Base**: ESAB_ONLY_SYSTEM_PROMPT (Lines 52-60)\n        - **Language Suffix**: \"Respond in {language}\" if not English\n        - **Domain Restriction**: \"Never mention, compare with, or suggest non-ESAB brands\"\n\n    LLM Configuration:\n        - Model: gpt-4o-mini (fast and cost-effective for Q&amp;A)\n        - Temperature: 0.4 (lower for more factual responses)\n        - Max Tokens: 300 (concise answers)\n        - Timeout: 10.0 seconds\n\n    Note:\n        - This is Layer 3 of the 3-layer anti-hallucination protection:\n            * Layer 1: _is_competitor_query() (pre-filter)\n            * Layer 2: Vague query normalization\n            * Layer 3: ESAB-only system prompt (this method)\n        - System prompt is the strongest safeguard against LLM hallucination\n        - Translation directive added to system prompt for non-English responses\n        - Response stripped of leading/trailing whitespace before return\n    \"\"\"\n    # Use ESAB-restricted system prompt\n    system_prompt = self.ESAB_ONLY_SYSTEM_PROMPT\n\n    if language != \"en\":\n        system_prompt += f\"\\nRespond in {language}.\"\n\n    response = await self.openai_client.chat.completions.create(\n        model=\"gpt-4o-mini\",\n        messages=[\n            {\"role\": \"system\", \"content\": system_prompt},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        temperature=0.4,  # Lower temperature for more factual responses\n        max_tokens=300,\n        timeout=10.0\n    )\n\n    return response.choices[0].message.content.strip()\n</code></pre> <p>LLM Configuration for Q&amp;A: - Model: gpt-4o-mini (fast, cost-effective) - Temperature: 0.4 (more factual, less creative) - Max Tokens: 300 (concise answers) - Timeout: 10 seconds - System Prompt: ESAB-only enforcement</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/#5-qa-prompt-building-with-context","title":"5. Q&amp;A Prompt Building with Context","text":"<pre><code>def _build_qa_prompt(self, question: str, context: Dict[str, Any]) -&gt; str:\n    \"\"\"\n    Build context-aware LLM prompt for question answering with welding configuration state.\n\n    Constructs a comprehensive prompt that includes the user's question, current configurator\n    state, selected components, and user requirements. This contextual prompt enables the LLM\n    to provide relevant, configuration-aware answers to welding equipment questions.\n\n    Args:\n        question: User's question text (e.g., \"What amperage do I need for aluminum?\")\n        context: Session context dict with keys:\n            - current_state: Current configurator state\n            - response_json: Selected components (ResponseJSON)\n            - master_parameters: User requirements (MasterParameterJSON)\n\n    Returns:\n        str: Complete LLM prompt structured with:\n            - Question text\n            - Current configuration stage\n            - Selected components list (formatted)\n            - User requirements summary (formatted)\n            - Answer quality guidelines (4 criteria)\n    \"\"\"\n    current_state = context.get(\"current_state\", \"unknown\")\n    selected_components = context.get(\"response_json\", {})\n    master_params = context.get(\"master_parameters\", {})\n\n    # Format selected components\n    selections_text = self._format_selections(selected_components)\n\n    # Format user requirements\n    requirements_text = self._format_requirements(\n        master_params.dict() if hasattr(master_params, \"dict\") else master_params\n    )\n\n    # Build comprehensive prompt\n    prompt = f\"\"\"Answer this welding equipment question:\n\nQuestion: {question}\n\nCurrent Configuration Context:\n- Stage: {self._get_component_name(current_state)}\n- Selected Components: {selections_text}\n- User Requirements: {requirements_text}\n\nProvide a helpful, specific answer that:\n1. Directly addresses the question\n2. References their configuration if relevant\n3. Uses welding industry terminology appropriately\n4. Stays focused on their current selection stage\n\nAnswer:\"\"\"\n\n    return prompt\n</code></pre> <p>Prompt Structure: - Question: User's exact question - Context: Current stage, selected components, requirements - Guidelines: 4 criteria for answer quality - Format: Markdown-friendly with clear sections</p> <p>Context Formatting Methods:</p> <pre><code>def _format_selections(self, response_json: Dict[str, Any]) -&gt; str:\n    \"\"\"\n    Format selected components into human-readable text for Q&amp;A context display.\n    Returns: \"Power Source: Aristo 500ix, Feeder: RobustFeed U6\" or \"None selected yet\"\n    \"\"\"\n    if hasattr(response_json, 'dict'):\n        response_json = response_json.dict()\n    elif hasattr(response_json, '__dict__'):\n        response_json = vars(response_json)\n\n    if not response_json:\n        return \"None selected yet\"\n\n    selections = []\n    component_map = {\n        \"PowerSource\": \"Power Source\",\n        \"Feeder\": \"Feeder\",\n        \"Cooler\": \"Cooler\",\n        \"Interconnector\": \"Interconnector\",\n        \"Torch\": \"Torch\",\n        \"Accessories\": \"Accessories\",\n        \"PowerSourceAccessories\": \"PowerSource Accessories\",\n        \"FeederAccessories\": \"Feeder Accessories\",\n        # ... 14 component types total\n    }\n\n    for comp_key, data in response_json.items():\n        if not data:\n            continue\n\n        display_name = component_map.get(comp_key, comp_key)\n\n        if isinstance(data, dict):\n            name = data.get(\"name\", \"Unknown\")\n            selections.append(f\"{display_name}: {name}\")\n        elif isinstance(data, list) and data:\n            count = len(data)\n            selections.append(f\"{display_name}: {count} items\")\n\n    return \", \".join(selections) if selections else \"None selected yet\"\n\ndef _format_requirements(self, master_parameters: Dict[str, Any]) -&gt; str:\n    \"\"\"\n    Format user requirements into human-readable text for Q&amp;A context display.\n    Returns: \"Process: MIG (GMAW), Amperage: 500 A\" or \"Not specified yet\"\n    \"\"\"\n    if not master_parameters:\n        return \"Not specified yet\"\n\n    requirements = []\n\n    # Power source requirements\n    ps_params = master_parameters.get(\"power_source\", {})\n    if ps_params:\n        process = ps_params.get(\"welding_process\")\n        amperage = ps_params.get(\"amperage\")\n        if process:\n            requirements.append(f\"Process: {process}\")\n        if amperage:\n            requirements.append(f\"Amperage: {amperage}\")\n\n    return \", \".join(requirements) if requirements else \"Not specified yet\"\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#6-state-prompt-generation-core-method","title":"6. State Prompt Generation (Core Method)","text":"<p>The <code>generate_state_prompt()</code> method is the core of Agent 3, generating contextual prompts for each configurator state.</p> <pre><code>async def generate_state_prompt(\n    self,\n    current_state: str,\n    master_parameters: Dict[str, Any],\n    response_json: Dict[str, Any],\n    language: str = \"en\"\n) -&gt; str:\n    \"\"\"\n    Generate state-specific prompt message using configuration-driven templates.\n\n    Core method for S1\u2192SN conversational flow that generates contextual prompts for each\n    configurator state. Fully config-driven using state_prompts.json, supports accessory\n    categories, and provides multilingual responses via LLM translation.\n\n    Args:\n        current_state: Current configurator state (e.g., \"power_source_selection\", \"finalize\")\n        master_parameters: User requirements dict from parameter extraction\n        response_json: Selected components dict (ResponseJSON)\n        language: ISO 639-1 language code for response (default: \"en\")\n\n    Returns:\n        str: Localized prompt message appropriate for current state.\n            - Accessory states: Dynamic prompts based on selected components\n            - Finalize state: Configuration summary with all selections\n            - Core states: Config-driven prompts with template rendering\n            - Translated to target language if not English\n\n    State Handling:\n        - **Accessory States** (9 categories): Uses _build_accessory_prompt() for context-aware prompts\n        - **Finalize State**: Generates package summary using _build_finalize_prompt()\n        - **Core States** (S1-S5): Uses ConfigurationService.get_state_prompt_config()\n        - **Dynamic States** (Feeder, Cooler): Checks for existing details and adjusts prompt\n\n    Template Variables:\n        - {power_source_name}: Name of selected power source\n        - {step_number}: State step number (e.g., \"Step 1\")\n        - {title}: State title (e.g., \"Power Source Selection\")\n    \"\"\"\n    # Generate English prompt using configuration\n    try:\n        # Handle accessory category states with dynamic prompts\n        if current_state in self._get_accessory_states():\n            english_prompt = self._build_accessory_prompt(\n                current_state, master_parameters, response_json\n            )\n        # Handle finalize state - build JSON summary\n        elif current_state == \"finalize\":\n            state_config = self.config_service.get_state_prompt_config(current_state)\n            english_prompt = self._build_finalize_prompt(response_json, state_config)\n        else:\n            # Get state config from configuration for core components\n            state_config = self.config_service.get_state_prompt_config(current_state)\n\n            # Build context for template rendering\n            context = self._build_prompt_context(current_state, master_parameters, response_json, state_config)\n\n            # Use simple prompt or template-based\n            if \"prompt_simple\" in state_config:\n                # Use simple prompt template\n                english_prompt = state_config[\"prompt_simple\"]\n\n                # For dynamic prompts (feeder, cooler), check if details exist\n                if current_state in [\"feeder_selection\", \"cooler_selection\"]:\n                    english_prompt = self._build_component_prompt(\n                        current_state, master_parameters, response_json, state_config\n                    )\n                else:\n                    # Format with power source name if available\n                    if \"{power_source_name}\" in english_prompt and response_json.get(\"PowerSource\"):\n                        english_prompt = english_prompt.format(\n                            power_source_name=response_json[\"PowerSource\"].get(\"name\", \"Unknown\")\n                        )\n            else:\n                # Render template with context\n                english_prompt = self.prompt_service.render_template(\n                    state_config.get(\"prompt_template\", \"\"),\n                    **context\n                )\n\n    except Exception as e:\n        logger.error(f\"Failed to generate state prompt for {current_state}: {e}\")\n        english_prompt = f\"Please provide information for {current_state.replace('_', ' ')}.\"\n\n    # Translate if not English\n    if language != \"en\":\n        try:\n            translated_prompt = await self.translator.translate(\n                english_prompt,\n                language,\n                context=f\"State: {current_state} - Welding equipment configurator prompt\"\n            )\n            return translated_prompt\n        except Exception as e:\n            logger.error(f\"Translation failed for {language}: {e}, returning English\")\n            return english_prompt\n\n    return english_prompt\n</code></pre> <p>Key Features: - Configuration-Driven: Uses <code>state_prompts.json</code> for all core state prompts - Template Rendering: Supports Jinja2-like variable substitution via PromptService - Dynamic Prompts: Adjusts prompts based on existing user data (Feeder/Cooler) - Accessory Routing: Delegates to specialized accessory prompt builders (9 categories) - Finalize Handling: Special handling for configuration summary state - Multilingual: Automatic translation if language != \"en\"</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/#7-search-results-formatting","title":"7. Search Results Formatting","text":"<pre><code>async def generate_search_results_message(\n    self,\n    current_state: str,\n    search_results: SearchResults,\n    master_parameters: Dict[str, Any],\n    language: str = \"en\"\n) -&gt; str:\n    \"\"\"\n    Generate user-friendly message presenting search results with selection instructions.\n\n    Formats product search results into a numbered list with contextual selection instructions\n    based on state type (core components vs accessories). Supports multilingual translation\n    and compatibility validation messaging.\n\n    Returns:\n        str: Formatted search results message with:\n            - Component name and requirement summary\n            - Numbered product list (top 5 results)\n            - Compatibility validation note (if applicable)\n            - State-specific selection instructions\n            - Translated to target language if not English\n\n    Selection Instructions by State Type:\n        - **Core Components** (S1-S5): \"select a {component}\" + \"skip if not needed\"\n        - **Accessory States**: \"select a {component}\" + \"next\" + \"done\" options\n        - **PowerSource**: No skip option (mandatory first component)\n\n    Product Display Format:\n        1. **Product Name** (GIN: 0446200880)\n        2. **Product Name** (GIN: 0460520880)\n        ...\n    \"\"\"\n\n    if not search_results.products:\n        return await self._generate_no_results_message(current_state, language)\n\n    # Get component name from configuration\n    component_name = self._get_component_name(current_state)\n\n    message = f\"Here are the {component_name} options matching your requirements\"\n\n    # Add compatibility note if validated\n    if search_results.compatibility_validated:\n        message += \" that are compatible with your selected components\"\n\n    message += \":\\n\\n\"\n\n    # List products (names and GINs stay in English for consistency)\n    for idx, product in enumerate(search_results.products[:5], 1):  # Show top 5\n        message += f\"{idx}. **{product.name}** (GIN: {product.gin})\\n\"\n\n    # Add selection instruction based on state type\n    if current_state in self._get_accessory_states():\n        # Accessory categories allow multiple selections\n        message += f\"\\n\u2705 select a {component_name}:\"\n        message += \"\\n- Or say 'next' to move to the next category\"\n        message += \"\\n- Say 'done' to finalize your configuration\"\n    else:\n        # Core components (single selection)\n        message += f\"\\n\u2705 select a {component_name}:\"\n\n        # PowerSource cannot be skipped (check from config)\n        power_source_config = self.config_service.get_component_type(\"power_source\")\n        if power_source_config and power_source_config.get(\"state_name\") != current_state:\n            feeder_source_config = self.config_service.get_component_type(\"feeder\")\n            if feeder_source_config and feeder_source_config.get('state_name') != current_state:\n                cooler_source_config = self.config_service.get_component_type(\"cooler\")\n                if cooler_source_config and cooler_source_config.get('state_name') != current_state:\n                    message += \"\\n- Or say 'skip' if not needed\"\n\n    # Translate if not English\n    if language != \"en\":\n        try:\n            translated_message = await self.translator.translate(\n                message,\n                language,\n                context=\"Product search results message\"\n            )\n            return translated_message\n        except Exception as e:\n            logger.error(f\"Translation failed for {language}: {e}, returning English\")\n            return message\n\n    return message\n</code></pre> <p>Key Features: - Top 5 Display: Shows only top 5 products (configurable) - Numbered List: User-friendly numbered format (1., 2., 3., ...) - Compatibility Note: Indicates if products are compatibility-validated - Context-Aware Instructions: Different instructions for core vs accessory states - Skip Logic: PowerSource cannot be skipped (mandatory) - Multilingual: Automatic translation if language != \"en\"</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/#8-accessory-category-prompt-system-9-categories","title":"8. Accessory Category Prompt System (9 Categories)","text":"<p>Agent 3 supports 9 accessory categories with dynamic context-aware prompts that reference previously selected components.</p> <pre><code>def _get_accessory_states(self) -&gt; List[str]:\n    \"\"\"Return list of all accessory category states\"\"\"\n    return [\n        \"powersource_accessories_selection\",\n        \"feeder_accessories_selection\",\n        \"feeder_conditional_accessories\",\n        \"interconnector_accessories_selection\",\n        \"remote_selection\",\n        \"remote_accessories_selection\",\n        \"remote_conditional_accessories\",\n        \"connectivity_selection\",\n        \"feeder_wears_selection\"\n    ]\n\ndef _build_accessory_prompt(\n    self,\n    current_state: str,\n    master_parameters: Dict[str, Any],\n    response_json: Dict[str, Any]\n) -&gt; str:\n    \"\"\"\n    Build dynamic context-aware prompt for accessory category selection states.\n\n    Routes to appropriate accessory-specific prompt builder based on current state.\n    Each builder generates a personalized prompt that references previously selected\n    components, creating a cohesive configurator experience.\n\n    Supported Accessory States (9 Categories):\n        1. powersource_accessories_selection \u2192 _build_powersource_accessories_prompt()\n        2. feeder_accessories_selection \u2192 _build_feeder_accessories_prompt()\n        3. feeder_conditional_accessories \u2192 _build_feeder_conditional_accessories_prompt()\n        4. interconnector_accessories_selection \u2192 _build_interconnector_accessories_prompt()\n        5. remote_selection \u2192 _build_remote_prompt()\n        6. remote_accessories_selection \u2192 _build_remote_accessories_prompt()\n        7. remote_conditional_accessories \u2192 _build_remote_conditional_accessories_prompt()\n        8. connectivity_selection \u2192 _build_connectivity_prompt()\n        9. feeder_wears_selection \u2192 _build_feeder_wears_prompt()\n    \"\"\"\n\n    # Map state to prompt builder\n    prompt_builders = {\n        \"powersource_accessories_selection\": self._build_powersource_accessories_prompt,\n        \"feeder_accessories_selection\": self._build_feeder_accessories_prompt,\n        \"feeder_conditional_accessories\": self._build_feeder_conditional_accessories_prompt,\n        \"interconnector_accessories_selection\": self._build_interconnector_accessories_prompt,\n        \"remote_selection\": self._build_remote_prompt,\n        \"remote_accessories_selection\": self._build_remote_accessories_prompt,\n        \"remote_conditional_accessories\": self._build_remote_conditional_accessories_prompt,\n        \"connectivity_selection\": self._build_connectivity_prompt,\n        \"feeder_wears_selection\": self._build_feeder_wears_prompt\n    }\n\n    builder = prompt_builders.get(current_state)\n    if builder:\n        return builder(response_json)\n\n    return f\"Would you like to add accessories for this component? or say 'skip' to move to next category or say 'done' finalize configuration.\"\n</code></pre> <p>Example Accessory Prompt Builders:</p> <pre><code>def _build_powersource_accessories_prompt(self, response_json: Dict[str, Any]) -&gt; str:\n    \"\"\"Generate PowerSource Accessories prompt\"\"\"\n\n    power_source = response_json.get(\"PowerSource\", {})\n    ps_name = power_source.get(\"name\", \"your power source\")\n\n    return f\"\"\"\ud83d\udd0c **PowerSource Accessories**\n\nWould you like to add accessories for **{ps_name}**?\n\nor say 'skip' to move to next category.\nor say 'done' finalize configuration.\"\"\"\n\ndef _build_feeder_accessories_prompt(self, response_json: Dict[str, Any]) -&gt; str:\n    \"\"\"Generate Feeder Accessories prompt\"\"\"\n\n    feeder = response_json.get(\"Feeder\", {})\n\n    if not feeder:\n        return \"\u23ed\ufe0f No feeder selected. Skipping feeder accessories.\"\n\n    feeder_name = feeder.get(\"name\", \"your feeder\")\n\n    return f\"\"\"\ud83d\udce6 **Feeder Accessories**\n\nWould you like accessories for **{feeder_name}**?\n\nor say 'skip' to move to next category.\nor say 'done' finalize configuration\"\"\"\n\ndef _build_remote_prompt(self, response_json: Dict[str, Any]) -&gt; str:\n    \"\"\"Generate Remote Control prompt\"\"\"\n\n    power_source = response_json.get(\"PowerSource\", {})\n    ps_name = power_source.get(\"name\", \"your power source\")\n\n    return f\"\"\"\ud83c\udfae **Remote Controls**\n\nWould you like to add a remote control for **{ps_name}**?\n\nor say 'skip' to move to next category\nor say 'done' finalize configuration.\"\"\"\n</code></pre> <p>Key Features: - Context-Aware: References previously selected components by name - Conditional Logic: Checks for prerequisites (e.g., Feeder must exist for Feeder Accessories) - Skip Messages: Automatic skip if prerequisite not met - Multi-Select Options: Always includes 'skip', 'next', 'done' options - Emoji Icons: Visual category indicators (\ud83d\udd0c, \ud83d\udce6, \ud83c\udfae, etc.)</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/#9-finalize-prompt-configuration-summary","title":"9. Finalize Prompt (Configuration Summary)","text":"<pre><code>def _build_finalize_prompt(\n    self,\n    response_json: Dict[str, Any],\n    state_config: Dict[str, Any]\n) -&gt; str:\n    \"\"\"\n    Simplified finalize prompt.\n    Returns a user-friendly message while the package is being generated.\n    \"\"\"\n    return (\n        \"\u23f3 Please wait, your package is being generated... \"\n        \"Once it is ready, you can click on the packages to view or edit them.\"\n    )\n</code></pre> <p>Note: The finalize prompt is simplified to a \"package generation in progress\" message. The actual configuration summary (JSON format) is generated by the backend and displayed in the frontend UI.</p> <p>Previous Implementation (commented out): - Formatted all selected components in human-readable text - Included core components and accessory categories - Used <code>finalize_header</code> and <code>finalize_footer</code> from state_prompts.json</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/#10-component-name-mapping","title":"10. Component Name Mapping","text":"<pre><code>def _get_component_name(self, state: str) -&gt; str:\n    \"\"\"\n    Get user-friendly component display name from configurator state name.\n\n    Translates internal state identifiers to human-readable component names for\n    user-facing messages. Supports both core components (via ConfigurationService)\n    and accessory categories (via hardcoded mapping).\n\n    Accessory Category Mapping:\n        - powersource_accessories_selection \u2192 \"PowerSource Accessory\"\n        - feeder_accessories_selection \u2192 \"Feeder Accessory\"\n        - feeder_conditional_accessories \u2192 \"Feeder Conditional Accessory\"\n        - interconnector_accessories_selection \u2192 \"Interconnector Accessory\"\n        - remote_selection \u2192 \"Remote Control\"\n        - remote_accessories_selection \u2192 \"Remote Accessory\"\n        - remote_conditional_accessories \u2192 \"Remote Conditional Accessory\"\n        - connectivity_selection \u2192 \"Connectivity Module\"\n        - feeder_wears_selection \u2192 \"Feeder Wear Part\"\n\n    Core Component Mapping (from config):\n        - power_source_selection \u2192 \"Power Source\" (via component_types.json)\n        - feeder_selection \u2192 \"Feeder\"\n        - cooler_selection \u2192 \"Cooler\"\n        - interconnector_selection \u2192 \"Interconnector\"\n        - torch_selection \u2192 \"Torch\"\n    \"\"\"\n\n    # Special mapping for accessory categories\n    accessory_names = {\n        \"powersource_accessories_selection\": \"PowerSource Accessory\",\n        \"feeder_accessories_selection\": \"Feeder Accessory\",\n        \"feeder_conditional_accessories\": \"Feeder Conditional Accessory\",\n        \"interconnector_accessories_selection\": \"Interconnector Accessory\",\n        \"remote_selection\": \"Remote Control\",\n        \"remote_accessories_selection\": \"Remote Accessory\",\n        \"remote_conditional_accessories\": \"Remote Conditional Accessory\",\n        \"connectivity_selection\": \"Connectivity Module\",\n        \"feeder_wears_selection\": \"Feeder Wear Part\"\n    }\n\n    if state in accessory_names:\n        return accessory_names[state]\n\n    # Find component by state_name in config\n    component_types = self.config_service.get_component_types()\n    for comp_key, comp_data in component_types.get(\"component_types\", {}).items():\n        if comp_data.get(\"state_name\") == state:\n            return comp_data.get(\"display_name\", \"Component\")\n\n    return \"Component\"\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#11-llm-context-loading-category-features","title":"11. LLM Context Loading (Category Features)","text":"<pre><code>def _load_category_features(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Load LLM-extracted category features from llm_context.json for intelligent guidance.\n\n    Reads pre-extracted feature guidance text for each component category from the\n    consolidated llm_context.json file. Features provide context-aware guidance to users\n    about available specifications and options for each component type.\n\n    File Location:\n        Path: app/config/llm_context.json\n        Section: \"category_features\" top-level key\n\n    Consolidated File Structure:\n        llm_context.json contains:\n        - product_names: Known product names per category\n        - category_features: Feature guidance text per category\n        - Other LLM context data\n\n    Supported Categories:\n        - Powersource: Power source specifications\n        - Feeder: Wire feeder specifications\n        - Cooler: Cooling system specifications\n        - Interconn: Interconnector cable specifications\n        - Torches: Welding torch specifications\n        - Powersource Accessories: Power source add-ons\n        - Feeder Accessories: Feeder add-ons\n        - Feeder Conditional Accessories: Conditional feeder accessories\n        - Interconn Accessories: Interconnector accessories\n        - Remotes: Remote control units\n        - Remote Accessories: Remote control add-ons\n        - Remote Conditional Accessories: Conditional remote accessories\n        - Connectivity: Connectivity modules\n        - Feeder Wears: Feeder wear parts\n    \"\"\"\n    try:\n        # Build path to LLM context file\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        llm_context_file = os.path.join(\n            current_dir, \"..\", \"..\", \"config\", \"llm_context.json\"\n        )\n\n        if not os.path.exists(llm_context_file):\n            logger.warning(f\"\u26a0\ufe0f LLM context file not found at {llm_context_file}\")\n            return {}\n\n        with open(llm_context_file, 'r', encoding='utf-8') as f:\n            llm_context = json.load(f)\n            features = llm_context.get(\"category_features\", {})\n\n        logger.info(f\"\u2705 Loaded LLM-extracted features for {len(features)} categories\")\n        return features\n\n    except Exception as e:\n        logger.error(f\"\u274c Failed to load category features: {e}\")\n        return {}\n</code></pre> <p>Note: Category features were consolidated into <code>llm_context.json</code> on Nov 15, 2025 (previously in <code>category_features_llm.json</code>).</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/#12-simple-confirmation-and-error-messages","title":"12. Simple Confirmation and Error Messages","text":"<pre><code>def generate_selection_confirmation(\n    self,\n    component_type: str,\n    product_name: str,\n    product_gin: str\n) -&gt; str:\n    \"\"\"Generate confirmation message for product selection\"\"\"\n\n    return f\"\u2705 Selected **{product_name}** (GIN: {product_gin}) for {component_type}.\"\n\ndef generate_skip_confirmation(self, component_type: str, key: str) -&gt; str:\n    \"\"\"Generate confirmation message for skipping a component\"\"\"\n    if key.lower().strip() == 'skip':\n        return f\"\u23ed\ufe0f Skipped {component_type}.\"\n    return f\"\u23ed\ufe0f Moved to next category from {component_type}.\"\n\ndef generate_error_message(self, error_type: str, details: str = \"\") -&gt; str:\n    \"\"\"Generate user-friendly error messages from configuration\"\"\"\n\n    return self.prompt_service.format_error_message(error_type, details)\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#integration-with-other-agents","title":"Integration with Other Agents","text":""},{"location":"AGENT3_MESSAGE_GENERATOR/#agent-1-agent-3-parameter-context","title":"Agent 1 \u2192 Agent 3 (Parameter Context)","text":"<p>Agent 3 receives extracted parameters from Agent 1 to generate context-aware prompts:</p> <pre><code>User Message: \"I need a 500A MIG welder for aluminum\"\n    \u2193\nAgent 1 (ParameterExtractor) extracts:\n{\n    \"power_source\": {\n        \"welding_process\": \"MIG (GMAW)\",\n        \"amperage\": \"500 A\",\n        \"material\": \"Aluminum\"\n    }\n}\n    \u2193\nAgent 3 (MessageGenerator) uses parameters for:\n- Q&amp;A context (_format_requirements)\n- Dynamic prompts (_build_component_prompt)\n- Feature guidance (_get_category_features)\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#agent-2-agent-3-search-results","title":"Agent 2 \u2192 Agent 3 (Search Results)","text":"<p>Agent 3 formats search results from Agent 2 into user-friendly messages:</p> <pre><code>Agent 2 (ProductSearch) returns SearchResults:\n{\n    \"products\": [\n        {\"gin\": \"0446200880\", \"name\": \"Aristo 500ix\", \"category\": \"PowerSource\"},\n        {\"gin\": \"0446200881\", \"name\": \"Warrior 500i\", \"category\": \"PowerSource\"},\n        ...\n    ],\n    \"compatibility_validated\": true,\n    \"total_count\": 5\n}\n    \u2193\nAgent 3 (MessageGenerator) formats:\n\"\"\"\nHere are the Power Source options matching your requirements that are compatible with your selected components:\n\n1. **Aristo 500ix** (GIN: 0446200880)\n2. **Warrior 500i** (GIN: 0446200881)\n3. **Renegade ES300i** (GIN: 0446200882)\n...\n\n\u2705 select a Power Source:\n- Or say 'skip' if not needed\n\"\"\"\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#agent-3-multilingualtranslator","title":"Agent 3 \u2192 MultilingualTranslator","text":"<p>Agent 3 delegates translation to MultilingualTranslator for non-English responses:</p> <pre><code># Translate if not English\nif language != \"en\":\n    try:\n        translated_prompt = await self.translator.translate(\n            english_prompt,\n            language,\n            context=f\"State: {current_state} - Welding equipment configurator prompt\"\n        )\n        return translated_prompt\n    except Exception as e:\n        logger.error(f\"Translation failed for {language}: {e}, returning English\")\n        return english_prompt\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#error-handling","title":"Error Handling","text":""},{"location":"AGENT3_MESSAGE_GENERATOR/#fallback-qa-response","title":"Fallback Q&amp;A Response","text":"<pre><code>def _fallback_qa_response(self, question: str) -&gt; str:\n    \"\"\"Fallback response when LLM fails\"\"\"\n    return (\n        \"I understand you have a question, but I'm having trouble \"\n        \"generating a detailed response right now. \\n\\n\"\n        \"You can:\\n\"\n        \"- Try rephrasing your question\\n\"\n        \"- Continue with the configuration and ask later\\n\"\n        \"- Request help from a specialist\\n\\n\"\n        \"Would you like to continue with your configuration?\"\n    )\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#no-results-message","title":"No Results Message","text":"<pre><code>async def _generate_no_results_message(self, current_state: str, language: str = \"en\") -&gt; str:\n    \"\"\"Generate message when no search results found\"\"\"\n\n    component_name = self._get_component_name(current_state)\n\n    # Check if this is an accessory category (can be skipped)\n    is_accessory = current_state in self._get_accessory_states()\n\n    if is_accessory:\n        english_message = f\"\"\"\n\u26a0\ufe0f No {component_name} options found matching your requirements.\n\nThis component is optional. You can:\n- Skip this category (say 'skip')\n- Adjust your requirements\n- Continue to the next category\n\nSay 'skip' to continue or 'done' to finalize.\"\"\"\n    else:\n        english_message = f\"\"\"\n\u26a0\ufe0f No {component_name} options found matching your requirements.\n\nThis could mean:\n- No compatible products available\n- Requirements may need adjustment\n- Or you can skip this component (if optional)\n\nWould you like to:\n1. Adjust your requirements\n2. Skip this component (if optional)\n\"\"\"\n\n    # Translate if not English\n    if language != \"en\":\n        try:\n            return await self.translator.translate(\n                english_message,\n                language,\n                context=\"No search results found message\"\n            )\n        except Exception as e:\n            logger.error(f\"Translation failed for {language}: {e}, returning English\")\n\n    return english_message\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#configuration-dependencies","title":"Configuration Dependencies","text":""},{"location":"AGENT3_MESSAGE_GENERATOR/#state_promptsjson","title":"state_prompts.json","text":"<p>Defines state-specific prompts for all configurator states:</p> <pre><code>{\n  \"power_source_selection\": {\n    \"step_number\": \"Step 1\",\n    \"title\": \"Power Source Selection\",\n    \"prompt_simple\": \"Please describe your power source requirements...\",\n    \"prompt_template\": \"{{step_number}}: {{title}}\\n\\nWelding Processes: {{processes}}\\nMaterials: {{materials}}\"\n  },\n  \"feeder_selection\": {\n    \"step_number\": \"Step 2\",\n    \"title\": \"Feeder Selection\",\n    \"prompt_simple\": \"Great! Now let's select a feeder for **{power_source_name}**.\",\n    \"prompt_with_details\": \"I found **{product_name}** ({details}). Let me search for compatible options.\"\n  },\n  ...\n}\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#component_typesjson","title":"component_types.json","text":"<p>Defines component metadata (display names, state names):</p> <pre><code>{\n  \"component_types\": {\n    \"power_source\": {\n      \"display_name\": \"Power Source\",\n      \"state_name\": \"power_source_selection\",\n      \"neo4j_label\": \"Product\",\n      \"category\": \"Powersource\"\n    },\n    ...\n  }\n}\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#llm_contextjson","title":"llm_context.json","text":"<p>Consolidated LLM context file with category features:</p> <pre><code>{\n  \"product_names\": { ... },\n  \"category_features\": {\n    \"Powersource\": {\n      \"guidance\": \"Available features: current rating (200-600A), duty cycle (@40-100%), ...\"\n    },\n    ...\n  }\n}\n</code></pre>"},{"location":"AGENT3_MESSAGE_GENERATOR/#performance-metrics","title":"Performance Metrics","text":"<p>Response Generation: - State Prompt: ~100-200ms (template rendering + config lookup) - Search Results Formatting: ~50-100ms (product list formatting) - Q&amp;A Response: ~2-4 seconds (GPT-4o-mini call + 300 token generation) - Translation: ~1-3 seconds (GPT-4o-mini call for non-English)</p> <p>Token Usage: - Q&amp;A Prompt: ~200-400 tokens (question + context) - Q&amp;A Response: ~100-300 tokens (answer) - Translation Prompt: ~100-500 tokens (English text + context) - Translation Response: ~100-500 tokens (translated text)</p> <p>Cost per Response (GPT-4o-mini): - Q&amp;A: ~0.0005 per question (input + output tokens) - **Translation**: ~0.0003 per message (input + output tokens) - Total per State: ~$0.0008 (Q&amp;A + Translation for non-English)</p>"},{"location":"AGENT3_MESSAGE_GENERATOR/#related-documentation","title":"Related Documentation","text":"<ul> <li>Agent 1: ParameterExtractor - LLM-based parameter extraction</li> <li>Agent 2: ProductSearch - Neo4j graph database search</li> <li>Orchestrator Architecture - StateByStateOrchestrator coordination</li> <li>Multilingual Flow - Translation architecture details</li> <li>Corrected State Flow Architecture - S1\u2192SN dynamic state machine</li> </ul>"},{"location":"AGENT3_MESSAGE_GENERATOR/#file-locations","title":"File Locations","text":"<p>Source: <code>src/backend/app/services/response/message_generator.py</code></p> <p>Dependencies: - <code>app/services/multilingual/translator.py</code> - MultilingualTranslator service - <code>app/services/config/configuration_service.py</code> - ConfigurationService for state_prompts.json - <code>app/services/config/prompt_service.py</code> - PromptService for template rendering - <code>app/config/state_prompts.json</code> - State-specific prompt templates - <code>app/config/component_types.json</code> - Component metadata - <code>app/config/llm_context.json</code> - LLM context and category features - <code>app/models/product_search.py</code> - ProductResult, SearchResults models - OpenAI AsyncClient - GPT-4o-mini for Q&amp;A and translation</p> <p>Related Files: - <code>app/services/intent/parameter_extractor.py</code> - Agent 1 (provides MasterParameterJSON) - <code>app/services/neo4j/product_search.py</code> - Agent 2 (provides SearchResults) - <code>app/services/orchestrator/state_orchestrator.py</code> - Orchestrator (coordinates all 3 agents)</p>"},{"location":"API_DOCUMENTATION/","title":"API Documentation - ESAB Welding Equipment Configurator","text":"<p>File: <code>src/backend/app/api/v1/configurator.py</code></p> <p>Comprehensive REST API documentation for the ESAB Welding Equipment Configurator (Recommender_v2), covering all endpoints, request/response models, application flow, and integration with the 3-agent system.</p>"},{"location":"API_DOCUMENTATION/#overview","title":"Overview","text":"<p>The configurator API provides a conversational state machine interface for building compatible welding equipment packages through a dynamic S1\u2192SN workflow.</p> <p>Architecture Pattern: RESTful API with Session-Based State Management</p> <p>Base URL: <code>http://localhost:8000/api/v1/configurator</code></p> <p>Key Features: - Session-based conversation state (Redis-backed with PostgreSQL archival) - Multi-language support (7 languages: en, es, fr, de, pt, it, sv) - Compound request handling (specify multiple components in one message) - Product selection via natural language or direct GIN - Configuration validation and finalization - Graceful fallback to in-memory storage if Redis unavailable</p>"},{"location":"API_DOCUMENTATION/#api-endpoints","title":"API Endpoints","text":""},{"location":"API_DOCUMENTATION/#1-post-apiv1configuratormessage","title":"1. POST /api/v1/configurator/message","text":"<p>Purpose: Process user message in current conversation state (main interaction endpoint)</p> <p>Flow: User Message \u2192 Session Retrieval \u2192 3-Agent Processing \u2192 Response Generation \u2192 Session Storage</p>"},{"location":"API_DOCUMENTATION/#request-model","title":"Request Model","text":"<pre><code>class MessageRequest(BaseModel):\n    \"\"\"Request model for user message processing.\"\"\"\n    session_id: Optional[str] = Field(\n        None,\n        description=\"Session ID for conversation continuity. Leave null for new session.\"\n    )\n    message: str = Field(\n        ...,\n        min_length=1,\n        description=\"User's natural language message\"\n    )\n    reset: bool = Field(\n        False,\n        description=\"Force new session creation (ignores session_id)\"\n    )\n    language: Optional[str] = Field(\n        \"en\",\n        description=\"ISO 639-1 language code (en, es, fr, de, pt, it, sv)\"\n    )\n</code></pre> <p>Example Request - New Session: <pre><code>{\n  \"message\": \"I need a 500A MIG welder for aluminum\",\n  \"language\": \"en\"\n}\n</code></pre></p> <p>Example Request - Continuing Session: <pre><code>{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"message\": \"I want water-cooled feeder\",\n  \"language\": \"en\"\n}\n</code></pre></p> <p>Example Request - Compound Request (Multi-Component): <pre><code>{\n  \"message\": \"Aristo 500ix with RobustFeed U6\",\n  \"language\": \"en\"\n}\n</code></pre></p> <p>Example Request - Product Selection by Number: <pre><code>{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"message\": \"1\",\n  \"language\": \"en\"\n}\n</code></pre></p> <p>Example Request - Special Commands: <pre><code>{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"message\": \"skip\",  // Skip current component\n  \"language\": \"en\"\n}\n</code></pre></p> <pre><code>{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"message\": \"done\",  // Finalize configuration\n  \"language\": \"en\"\n}\n</code></pre>"},{"location":"API_DOCUMENTATION/#response-model","title":"Response Model","text":"<pre><code>class MessageResponse(BaseModel):\n    \"\"\"Response model for message processing.\"\"\"\n    session_id: str = Field(\n        ...,\n        description=\"Session ID for conversation continuity\"\n    )\n    message: str = Field(\n        ...,\n        description=\"AI-generated response message\"\n    )\n    current_state: str = Field(\n        ...,\n        description=\"Current configurator state (e.g., 'power_source_selection')\"\n    )\n    master_parameters: Dict[str, Any] = Field(\n        ...,\n        description=\"Extracted parameters from all user messages\"\n    )\n    response_json: Dict[str, Any] = Field(\n        ...,\n        description=\"User's current configuration (selected products)\"\n    )\n    products: List[Dict[str, Any]] = Field(\n        default_factory=list,\n        description=\"Search results for current state (if applicable)\"\n    )\n    awaiting_selection: bool = Field(\n        False,\n        description=\"True if user needs to select from multiple products\"\n    )\n    can_finalize: bool = Field(\n        False,\n        description=\"True if configuration is valid for finalization\"\n    )\n</code></pre> <p>Example Response - Power Source Search: <pre><code>{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"message\": \"I found several power sources matching your requirements:\\n\\n1. **Aristo 500ix** (GIN: 0446200880)\\n   - Current: 500 A\\n   - Process: MIG/MAG (GMAW)\\n   - Description: Advanced MIG/MAG power source with 500A output\\n\\n2. **Warrior 500i** (GIN: 0445014880)\\n   - Current: 500 A\\n   - Process: MIG/MAG (GMAW)\\n   - Description: Industrial MIG/MAG power source\\n\\nPlease select a power source by number or tell me more about your requirements.\",\n  \"current_state\": \"power_source_selection\",\n  \"master_parameters\": {\n    \"power_source\": {\n      \"process\": \"MIG (GMAW)\",\n      \"current_output\": \"500 A\",\n      \"material\": \"Aluminum\"\n    }\n  },\n  \"response_json\": {\n    \"PowerSource\": null,\n    \"Feeder\": null,\n    \"Cooler\": null,\n    \"Interconnector\": null,\n    \"Torch\": null,\n    \"Accessories\": []\n  },\n  \"products\": [\n    {\n      \"gin\": \"0446200880\",\n      \"name\": \"Aristo 500ix\",\n      \"category\": \"PowerSource\",\n      \"description\": \"Advanced MIG/MAG power source with 500A output\"\n    },\n    {\n      \"gin\": \"0445014880\",\n      \"name\": \"Warrior 500i\",\n      \"category\": \"PowerSource\",\n      \"description\": \"Industrial MIG/MAG power source\"\n    }\n  ],\n  \"awaiting_selection\": true,\n  \"can_finalize\": false\n}\n</code></pre></p> <p>Example Response - Product Selected: <pre><code>{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"message\": \"\u2705 Power source selected: **Aristo 500ix** (GIN: 0446200880)\\n\\nBased on your power source, the following components are applicable:\\n- \u2705 Feeder: Required\\n- \u2705 Cooler: Required\\n- \u2705 Interconnector: Required\\n- \u2705 Torch: Required\\n- \u2705 Accessories: Optional\\n\\nNow, let's select a wire feeder. What type of feeder do you need?\",\n  \"current_state\": \"feeder_selection\",\n  \"master_parameters\": {\n    \"power_source\": {\n      \"product_name\": \"Aristo 500ix\",\n      \"gin\": \"0446200880\",\n      \"process\": \"MIG (GMAW)\",\n      \"current_output\": \"500 A\"\n    }\n  },\n  \"response_json\": {\n    \"PowerSource\": {\n      \"gin\": \"0446200880\",\n      \"name\": \"Aristo 500ix\",\n      \"category\": \"PowerSource\",\n      \"description\": \"Advanced MIG/MAG power source with 500A output\"\n    },\n    \"Feeder\": null,\n    \"Cooler\": null,\n    \"Interconnector\": null,\n    \"Torch\": null,\n    \"Accessories\": [],\n    \"applicability\": {\n      \"Feeder\": \"Y\",\n      \"Cooler\": \"Y\",\n      \"Interconnector\": \"Y\",\n      \"Torch\": \"Y\",\n      \"Accessories\": \"Y\"\n    }\n  },\n  \"products\": [],\n  \"awaiting_selection\": false,\n  \"can_finalize\": false\n}\n</code></pre></p> <p>Example Response - Compound Request (Auto-Selection): <pre><code>{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"message\": \"\u2705 **PowerSource**: Aristo 500ix (GIN: 0446200880) - Auto-selected (1 exact match)\\n\u2705 **Feeder**: RobustFeed U6 (GIN: 0460520880) - Auto-selected (1 exact match)\\n\\n**Current Package**:\\n\u2022 PowerSource: Aristo 500ix\\n\u2022 Feeder: RobustFeed U6\\n\\n**Next**: Would you like to add a Cooler? (Say 'skip' to skip, or describe your requirements)\",\n  \"current_state\": \"cooler_selection\",\n  \"master_parameters\": {\n    \"power_source\": {\n      \"product_name\": \"Aristo 500ix\",\n      \"gin\": \"0446200880\"\n    },\n    \"feeder\": {\n      \"product_name\": \"RobustFeed U6\",\n      \"gin\": \"0460520880\"\n    }\n  },\n  \"response_json\": {\n    \"PowerSource\": {\n      \"gin\": \"0446200880\",\n      \"name\": \"Aristo 500ix\",\n      \"category\": \"PowerSource\",\n      \"description\": \"Advanced MIG/MAG power source\"\n    },\n    \"Feeder\": {\n      \"gin\": \"0460520880\",\n      \"name\": \"RobustFeed U6\",\n      \"category\": \"Feeder\",\n      \"description\": \"Robust wire feeder\"\n    },\n    \"Cooler\": null,\n    \"Interconnector\": null,\n    \"Torch\": null,\n    \"Accessories\": []\n  },\n  \"products\": [],\n  \"awaiting_selection\": false,\n  \"can_finalize\": false\n}\n</code></pre></p> <p>Example Response - Configuration Complete: <pre><code>{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"message\": \"\u2705 **Configuration Complete!**\\n\\n**Your Welding Equipment Package**:\\n\\n1. **PowerSource**: Aristo 500ix (GIN: 0446200880)\\n   - 500A MIG/MAG power source\\n\\n2. **Feeder**: RobustFeed U6 (GIN: 0460520880)\\n   - Water-cooled wire feeder\\n\\n3. **Cooler**: Cool 50 (GIN: 0460450880)\\n   - 50L cooling system\\n\\n4. **Interconnector**: Interconnector Cable 10m (GIN: 0460470880)\\n   - 10-meter interconnector cable\\n\\n5. **Torch**: TXH 501W (GIN: 0460480880)\\n   - Water-cooled MIG torch, 500A\\n\\n**Total Components**: 5\\n\\nYour configuration is complete! You can:\\n- Add accessories (say 'accessories')\\n- Modify any component (say 'change &lt;component&gt;')\\n- Export this configuration\\n\\nWhat would you like to do next?\",\n  \"current_state\": \"finalize\",\n  \"master_parameters\": { /* ... */ },\n  \"response_json\": {\n    \"PowerSource\": { /* ... */ },\n    \"Feeder\": { /* ... */ },\n    \"Cooler\": { /* ... */ },\n    \"Interconnector\": { /* ... */ },\n    \"Torch\": { /* ... */ },\n    \"Accessories\": []\n  },\n  \"products\": [],\n  \"awaiting_selection\": false,\n  \"can_finalize\": true\n}\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#http-status-codes","title":"HTTP Status Codes","text":"<ul> <li>200 OK: Message processed successfully</li> <li>400 Bad Request: Invalid request (e.g., empty message, invalid language code)</li> <li>500 Internal Server Error: Server error (database failure, agent error)</li> </ul>"},{"location":"API_DOCUMENTATION/#error-response","title":"Error Response","text":"<pre><code>{\n  \"detail\": \"Error processing message: &lt;error description&gt;\"\n}\n</code></pre>"},{"location":"API_DOCUMENTATION/#2-post-apiv1configuratorselect","title":"2. POST /api/v1/configurator/select","text":"<p>Purpose: Explicitly select a product by GIN (alternative to natural language selection)</p> <p>Flow: Product Selection \u2192 Session Retrieval \u2192 Orchestrator Product Selection \u2192 State Transition \u2192 Session Storage</p>"},{"location":"API_DOCUMENTATION/#request-model_1","title":"Request Model","text":"<pre><code>class SelectProductRequest(BaseModel):\n    \"\"\"Request model for explicit product selection.\"\"\"\n    session_id: str = Field(\n        ...,\n        description=\"Active session ID\"\n    )\n    product_gin: str = Field(\n        ...,\n        description=\"Global Identification Number (GIN) of product to select\"\n    )\n    product_data: Dict[str, Any] = Field(\n        ...,\n        description=\"Product details (name, category, description)\"\n    )\n    language: Optional[str] = Field(\n        \"en\",\n        description=\"ISO 639-1 language code\"\n    )\n</code></pre> <p>Example Request: <pre><code>{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"product_gin\": \"0446200880\",\n  \"product_data\": {\n    \"name\": \"Aristo 500ix\",\n    \"category\": \"PowerSource\",\n    \"description\": \"Advanced MIG/MAG power source with 500A output\"\n  },\n  \"language\": \"en\"\n}\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#response-model_1","title":"Response Model","text":"<p>Same as <code>MessageResponse</code> (see above).</p> <p>Example Response: <pre><code>{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"message\": \"\u2705 Power source selected: **Aristo 500ix** (GIN: 0446200880)\\n\\nNow, let's select a wire feeder...\",\n  \"current_state\": \"feeder_selection\",\n  \"master_parameters\": { /* ... */ },\n  \"response_json\": {\n    \"PowerSource\": {\n      \"gin\": \"0446200880\",\n      \"name\": \"Aristo 500ix\",\n      \"category\": \"PowerSource\",\n      \"description\": \"Advanced MIG/MAG power source with 500A output\"\n    }\n  },\n  \"products\": [],\n  \"awaiting_selection\": false,\n  \"can_finalize\": false\n}\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#http-status-codes_1","title":"HTTP Status Codes","text":"<ul> <li>200 OK: Product selected successfully</li> <li>400 Bad Request: Invalid request (missing session_id, invalid GIN)</li> <li>404 Not Found: Session not found</li> <li>500 Internal Server Error: Server error</li> </ul>"},{"location":"API_DOCUMENTATION/#3-get-apiv1configuratorstatesession_id","title":"3. GET /api/v1/configurator/state/{session_id}","text":"<p>Purpose: Retrieve current conversation state (for session resumption or debugging)</p> <p>Flow: Session Retrieval \u2192 State Serialization \u2192 Response</p>"},{"location":"API_DOCUMENTATION/#path-parameters","title":"Path Parameters","text":"<ul> <li><code>session_id</code> (string, required): Session UUID</li> </ul> <p>Example Request: <pre><code>GET /api/v1/configurator/state/550e8400-e29b-41d4-a716-446655440000\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#response-model_2","title":"Response Model","text":"<pre><code>class StateResponse(BaseModel):\n    \"\"\"Response model for state retrieval.\"\"\"\n    session_id: str\n    current_state: str\n    master_parameters: Dict[str, Any]\n    response_json: Dict[str, Any]\n    conversation_history: List[Dict[str, str]]\n    language: str\n    created_at: str\n    last_updated: str\n</code></pre> <p>Example Response: <pre><code>{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"current_state\": \"feeder_selection\",\n  \"master_parameters\": {\n    \"power_source\": {\n      \"product_name\": \"Aristo 500ix\",\n      \"gin\": \"0446200880\",\n      \"process\": \"MIG (GMAW)\",\n      \"current_output\": \"500 A\"\n    }\n  },\n  \"response_json\": {\n    \"PowerSource\": {\n      \"gin\": \"0446200880\",\n      \"name\": \"Aristo 500ix\",\n      \"category\": \"PowerSource\",\n      \"description\": \"Advanced MIG/MAG power source\"\n    },\n    \"Feeder\": null,\n    \"Cooler\": null,\n    \"Interconnector\": null,\n    \"Torch\": null,\n    \"Accessories\": []\n  },\n  \"conversation_history\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"I need a 500A MIG welder for aluminum\",\n      \"timestamp\": \"2025-01-17T10:30:00Z\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"I found several power sources matching your requirements...\",\n      \"timestamp\": \"2025-01-17T10:30:02Z\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"1\",\n      \"timestamp\": \"2025-01-17T10:30:15Z\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"\u2705 Power source selected: Aristo 500ix...\",\n      \"timestamp\": \"2025-01-17T10:30:17Z\"\n    }\n  ],\n  \"language\": \"en\",\n  \"created_at\": \"2025-01-17T10:30:00Z\",\n  \"last_updated\": \"2025-01-17T10:30:17Z\"\n}\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#http-status-codes_2","title":"HTTP Status Codes","text":"<ul> <li>200 OK: State retrieved successfully</li> <li>404 Not Found: Session not found</li> <li>500 Internal Server Error: Server error</li> </ul>"},{"location":"API_DOCUMENTATION/#4-delete-apiv1configuratorsessionsession_id","title":"4. DELETE /api/v1/configurator/session/{session_id}","text":"<p>Purpose: Delete active session from Redis (manual cleanup)</p> <p>Flow: Session Deletion \u2192 Redis Key Removal \u2192 User Mapping Cleanup</p>"},{"location":"API_DOCUMENTATION/#path-parameters_1","title":"Path Parameters","text":"<ul> <li><code>session_id</code> (string, required): Session UUID</li> </ul> <p>Example Request: <pre><code>DELETE /api/v1/configurator/session/550e8400-e29b-41d4-a716-446655440000\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#response-model_3","title":"Response Model","text":"<pre><code>{\n  \"message\": \"Session deleted successfully\",\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\"\n}\n</code></pre>"},{"location":"API_DOCUMENTATION/#http-status-codes_3","title":"HTTP Status Codes","text":"<ul> <li>200 OK: Session deleted successfully</li> <li>404 Not Found: Session not found</li> <li>500 Internal Server Error: Server error</li> </ul>"},{"location":"API_DOCUMENTATION/#5-post-apiv1configuratorarchivesession_id","title":"5. POST /api/v1/configurator/archive/{session_id}","text":"<p>Purpose: Archive completed session to PostgreSQL (long-term storage)</p> <p>Flow: Session Retrieval \u2192 Validation \u2192 PostgreSQL Insert \u2192 Optional Redis Deletion</p>"},{"location":"API_DOCUMENTATION/#path-parameters_2","title":"Path Parameters","text":"<ul> <li><code>session_id</code> (string, required): Session UUID</li> </ul>"},{"location":"API_DOCUMENTATION/#query-parameters","title":"Query Parameters","text":"<ul> <li><code>delete_from_redis</code> (boolean, optional, default: false): Delete from Redis after archival</li> </ul> <p>Example Request: <pre><code>POST /api/v1/configurator/archive/550e8400-e29b-41d4-a716-446655440000?delete_from_redis=true\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#response-model_4","title":"Response Model","text":"<pre><code>{\n  \"message\": \"Session archived successfully\",\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"archived_at\": \"2025-01-17T10:45:00Z\",\n  \"deleted_from_redis\": true\n}\n</code></pre>"},{"location":"API_DOCUMENTATION/#http-status-codes_4","title":"HTTP Status Codes","text":"<ul> <li>200 OK: Session archived successfully</li> <li>400 Bad Request: Session not finalized (cannot archive incomplete sessions)</li> <li>404 Not Found: Session not found</li> <li>500 Internal Server Error: Server error (PostgreSQL failure)</li> </ul>"},{"location":"API_DOCUMENTATION/#6-get-health","title":"6. GET /health","text":"<p>Purpose: System health check (all services)</p> <p>Flow: Connection Tests \u2192 Service Status \u2192 Response</p> <p>Example Request: <pre><code>GET /health\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#response-model_5","title":"Response Model","text":"<pre><code>{\n  \"status\": \"healthy\",  // \"healthy\" | \"degraded\" | \"unhealthy\"\n  \"services\": {\n    \"redis\": {\n      \"status\": \"connected\",\n      \"ping\": \"PONG\",\n      \"response_time_ms\": 2.5\n    },\n    \"postgresql\": {\n      \"status\": \"connected\",\n      \"response_time_ms\": 15.3\n    },\n    \"neo4j\": {\n      \"status\": \"connected\",\n      \"response_time_ms\": 8.7\n    },\n    \"session_storage\": {\n      \"type\": \"redis\",  // \"redis\" | \"in-memory\"\n      \"status\": \"operational\"\n    }\n  },\n  \"timestamp\": \"2025-01-17T10:50:00Z\"\n}\n</code></pre> <p>Degraded Response Example (Redis unavailable): <pre><code>{\n  \"status\": \"degraded\",\n  \"services\": {\n    \"redis\": {\n      \"status\": \"disconnected\",\n      \"error\": \"Connection refused\"\n    },\n    \"postgresql\": {\n      \"status\": \"connected\",\n      \"response_time_ms\": 12.1\n    },\n    \"neo4j\": {\n      \"status\": \"connected\",\n      \"response_time_ms\": 9.3\n    },\n    \"session_storage\": {\n      \"type\": \"in-memory\",\n      \"status\": \"operational\",\n      \"warning\": \"Using in-memory fallback - sessions not persistent\"\n    }\n  },\n  \"timestamp\": \"2025-01-17T10:50:00Z\"\n}\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#http-status-codes_5","title":"HTTP Status Codes","text":"<ul> <li>200 OK: System healthy or degraded (but operational)</li> <li>503 Service Unavailable: System unhealthy (critical services down)</li> </ul>"},{"location":"API_DOCUMENTATION/#application-flow-diagrams","title":"Application Flow Diagrams","text":""},{"location":"API_DOCUMENTATION/#flow-1-new-session-creation","title":"Flow 1: New Session Creation","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 POST /api/v1/configurator/message\n                \u2502 {\"message\": \"I need a 500A MIG welder\", \"language\": \"en\"}\n                \u2502\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 process_configurator_message()                                \u2502\n\u2502 - Validate request (message not empty, language valid)        \u2502\n\u2502 - Check for session_id or reset flag                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 session_id is None \u2192 Create new session\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 get_or_create_session()                                       \u2502\n\u2502 - Generate new UUID                                           \u2502\n\u2502 - Create ConversationState with default values                \u2502\n\u2502 - current_state = ConfiguratorState.POWER_SOURCE_SELECTION    \u2502\n\u2502 - master_parameters = {} (empty)                              \u2502\n\u2502 - response_json = ResponseJSON (all null)                     \u2502\n\u2502 - conversation_history = []                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Pass to Orchestrator\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 StateByStateOrchestrator.process_message()                    \u2502\n\u2502                                                               \u2502\n\u2502 Step 1: Check for special commands (skip, done, finalize)    \u2502\n\u2502 Step 2: Extract parameters via ParameterExtractor (Agent 1)  \u2502\n\u2502         - LLM analyzes: \"I need a 500A MIG welder\"           \u2502\n\u2502         - Returns: {\"power_source\": {                         \u2502\n\u2502                      \"current_output\": \"500 A\",               \u2502\n\u2502                      \"process\": \"MIG (GMAW)\"}}                \u2502\n\u2502                                                               \u2502\n\u2502 Step 3: Check for compound request (multiple components)     \u2502\n\u2502         - Only 1 component specified \u2192 Not compound           \u2502\n\u2502                                                               \u2502\n\u2502 Step 4: Delegate to PowerSourceProcessor                     \u2502\n\u2502         - Search Neo4j for matching power sources (Agent 2)  \u2502\n\u2502         - Find 2 results: Aristo 500ix, Warrior 500i         \u2502\n\u2502                                                               \u2502\n\u2502 Step 5: Generate response via MessageGenerator (Agent 3)     \u2502\n\u2502         - Format search results with numbered list            \u2502\n\u2502         - Prompt: \"Please select a power source...\"           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Return result\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 save_conversation()                                           \u2502\n\u2502 - Add user message to conversation_history                    \u2502\n\u2502 - Add assistant response to conversation_history             \u2502\n\u2502 - Save to Redis with TTL (3600s default)                     \u2502\n\u2502 - Key: session:{session_id}                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Return MessageResponse\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                        \u2502\n\u2502 Receives:                                                     \u2502\n\u2502 {                                                             \u2502\n\u2502   \"session_id\": \"550e8400-...\",                               \u2502\n\u2502   \"message\": \"I found 2 power sources:\\n1. Aristo 500ix...\", \u2502\n\u2502   \"current_state\": \"power_source_selection\",                  \u2502\n\u2502   \"products\": [{\"gin\": \"0446200880\", ...}, ...],             \u2502\n\u2502   \"awaiting_selection\": true                                  \u2502\n\u2502 }                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"API_DOCUMENTATION/#flow-2-product-selection-natural-language","title":"Flow 2: Product Selection (Natural Language)","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 POST /api/v1/configurator/message\n                \u2502 {\n                \u2502   \"session_id\": \"550e8400-...\",\n                \u2502   \"message\": \"1\"  // Select first product\n                \u2502 }\n                \u2502\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 process_configurator_message()                                \u2502\n\u2502 - Retrieve session from Redis                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Load ConversationState\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 StateByStateOrchestrator.process_message()                    \u2502\n\u2502                                                               \u2502\n\u2502 Step 1: Check for special commands \u2192 Not a command           \u2502\n\u2502                                                               \u2502\n\u2502 Step 2: ParameterExtractor (Agent 1)                         \u2502\n\u2502         - _detect_selection_intent(\"1\")                       \u2502\n\u2502         - Regex match: ^\\s*(\\d+)\\s*$ \u2192 selection_index = 0   \u2502\n\u2502         - Return: {\"_selection_metadata\": {                   \u2502\n\u2502                     \"is_selection\": true,                     \u2502\n\u2502                     \"selection_index\": 0}}                    \u2502\n\u2502                                                               \u2502\n\u2502 Step 3: Not a compound request                               \u2502\n\u2502                                                               \u2502\n\u2502 Step 4: Handle product selection                             \u2502\n\u2502         - Check last_shown_products from previous response    \u2502\n\u2502         - product = last_shown_products[0]  // Aristo 500ix  \u2502\n\u2502         - Call select_product(                                \u2502\n\u2502             product_gin=\"0446200880\",                         \u2502\n\u2502             product_data={...}                                \u2502\n\u2502           )                                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Delegate to select_product()\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 StateByStateOrchestrator.select_product()                     \u2502\n\u2502                                                               \u2502\n\u2502 Step 1: Get processor for current state                      \u2502\n\u2502         - current_state = power_source_selection              \u2502\n\u2502         - processor = PowerSourceProcessor                    \u2502\n\u2502                                                               \u2502\n\u2502 Step 2: Create SelectedProduct                               \u2502\n\u2502         - SelectedProduct(                                    \u2502\n\u2502             gin=\"0446200880\",                                 \u2502\n\u2502             name=\"Aristo 500ix\",                              \u2502\n\u2502             category=\"PowerSource\"                            \u2502\n\u2502           )                                                   \u2502\n\u2502                                                               \u2502\n\u2502 Step 3: Add to ResponseJSON                                  \u2502\n\u2502         - response_json.PowerSource = selected_product        \u2502\n\u2502                                                               \u2502\n\u2502 Step 4: Load component applicability (MANDATORY AFTER S1)    \u2502\n\u2502         - Load from component_applicability.json              \u2502\n\u2502         - For GIN 0446200880:                                 \u2502\n\u2502           {                                                   \u2502\n\u2502             \"Feeder\": \"Y\",                                    \u2502\n\u2502             \"Cooler\": \"Y\",                                    \u2502\n\u2502             \"Interconnector\": \"Y\",                            \u2502\n\u2502             \"Torch\": \"Y\",                                     \u2502\n\u2502             \"Accessories\": \"Y\"                                \u2502\n\u2502           }                                                   \u2502\n\u2502         - response_json.applicability = ComponentApplicability\u2502\n\u2502                                                               \u2502\n\u2502 Step 5: Determine next state                                 \u2502\n\u2502         - conversation_state.get_next_state()                 \u2502\n\u2502         - Returns: feeder_selection (applicability.Feeder=\"Y\")\u2502\n\u2502                                                               \u2502\n\u2502 Step 6: Generate response (Agent 3)                          \u2502\n\u2502         - Confirmation: \"\u2705 Power source selected: ...\"       \u2502\n\u2502         - Prompt: \"Now, let's select a wire feeder...\"       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Save session and return\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                        \u2502\n\u2502 Receives:                                                     \u2502\n\u2502 {                                                             \u2502\n\u2502   \"session_id\": \"550e8400-...\",                               \u2502\n\u2502   \"message\": \"\u2705 Power source selected: Aristo 500ix...\",     \u2502\n\u2502   \"current_state\": \"feeder_selection\",                        \u2502\n\u2502   \"response_json\": {                                          \u2502\n\u2502     \"PowerSource\": {\"gin\": \"0446200880\", ...},                \u2502\n\u2502     \"applicability\": {\"Feeder\": \"Y\", ...}                     \u2502\n\u2502   },                                                          \u2502\n\u2502   \"awaiting_selection\": false                                 \u2502\n\u2502 }                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"API_DOCUMENTATION/#flow-3-product-selection-direct-gin-via-select-endpoint","title":"Flow 3: Product Selection (Direct GIN via /select endpoint)","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 POST /api/v1/configurator/select\n                \u2502 {\n                \u2502   \"session_id\": \"550e8400-...\",\n                \u2502   \"product_gin\": \"0446200880\",\n                \u2502   \"product_data\": {\n                \u2502     \"name\": \"Aristo 500ix\",\n                \u2502     \"category\": \"PowerSource\",\n                \u2502     \"description\": \"...\"\n                \u2502   }\n                \u2502 }\n                \u2502\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 select_product_endpoint()                                     \u2502\n\u2502 - Retrieve session from Redis                                \u2502\n\u2502 - Validate session exists                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Delegate to Orchestrator\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 StateByStateOrchestrator.select_product()                     \u2502\n\u2502 - Same flow as natural language selection (see Flow 2)       \u2502\n\u2502 - Bypasses ParameterExtractor (Agent 1)                      \u2502\n\u2502 - Directly adds to ResponseJSON                              \u2502\n\u2502 - Loads applicability                                        \u2502\n\u2502 - Transitions to next state                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Return result\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                        \u2502\n\u2502 Receives: Same as Flow 2 (MessageResponse)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"API_DOCUMENTATION/#flow-4-compound-request-multi-component","title":"Flow 4: Compound Request (Multi-Component)","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 POST /api/v1/configurator/message\n                \u2502 {\"message\": \"Aristo 500ix with RobustFeed U6\"}\n                \u2502\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 StateByStateOrchestrator.process_message()                    \u2502\n\u2502                                                               \u2502\n\u2502 Step 1: Check for special commands \u2192 Not a command           \u2502\n\u2502                                                               \u2502\n\u2502 Step 2: ParameterExtractor (Agent 1)                         \u2502\n\u2502         - LLM analyzes: \"Aristo 500ix with RobustFeed U6\"    \u2502\n\u2502         - Returns: {                                          \u2502\n\u2502             \"power_source\": {                                 \u2502\n\u2502               \"product_name\": \"Aristo 500ix\"                  \u2502\n\u2502             },                                                \u2502\n\u2502             \"feeder\": {                                       \u2502\n\u2502               \"product_name\": \"RobustFeed U6\"                 \u2502\n\u2502             }                                                 \u2502\n\u2502           }                                                   \u2502\n\u2502                                                               \u2502\n\u2502 Step 3: Check for compound request                           \u2502\n\u2502         - _detect_compound_request(master_parameters)         \u2502\n\u2502         - Count components with specifications: 2             \u2502\n\u2502         - Returns: true \u2192 COMPOUND REQUEST                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Delegate to compound request handler\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 _handle_compound_request()                                    \u2502\n\u2502                                                               \u2502\n\u2502 Step 1: Validate PowerSource dependency                      \u2502\n\u2502         - Check if PowerSource is in request \u2192 YES            \u2502\n\u2502         - Downstream components require PowerSource first     \u2502\n\u2502                                                               \u2502\n\u2502 Step 2: Search all specified components in parallel          \u2502\n\u2502         - Task 1: Search PowerSource \"Aristo 500ix\"           \u2502\n\u2502           \u2192 Neo4jProductSearch (Agent 2)                      \u2502\n\u2502           \u2192 Results: 1 product (GIN: 0446200880)              \u2502\n\u2502                                                               \u2502\n\u2502         - Task 2: Search Feeder \"RobustFeed U6\"               \u2502\n\u2502           \u2192 Neo4jProductSearch (Agent 2)                      \u2502\n\u2502           \u2192 Results: 1 product (GIN: 0460520880)              \u2502\n\u2502                                                               \u2502\n\u2502 Step 3: Process results for each component                   \u2502\n\u2502         Component 1: PowerSource                              \u2502\n\u2502           - Results: 1 \u2192 AUTO-SELECT                          \u2502\n\u2502           - Add to ResponseJSON.PowerSource                   \u2502\n\u2502           - Load applicability for GIN 0446200880             \u2502\n\u2502           - Mark state as handled                             \u2502\n\u2502                                                               \u2502\n\u2502         Component 2: Feeder                                   \u2502\n\u2502           - Results: 1 \u2192 AUTO-SELECT                          \u2502\n\u2502           - Validate compatibility with PowerSource           \u2502\n\u2502           - Add to ResponseJSON.Feeder                        \u2502\n\u2502           - Mark state as handled                             \u2502\n\u2502                                                               \u2502\n\u2502 Step 4: Determine next state                                 \u2502\n\u2502         - Skip handled states (power_source, feeder)          \u2502\n\u2502         - Check applicability: Cooler = \"Y\"                   \u2502\n\u2502         - Next state: cooler_selection                        \u2502\n\u2502                                                               \u2502\n\u2502 Step 5: Generate compound response (Agent 3)                 \u2502\n\u2502         - List all auto-selected components                   \u2502\n\u2502         - Show current package summary                        \u2502\n\u2502         - Prompt for next component                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Return result\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                        \u2502\n\u2502 Receives:                                                     \u2502\n\u2502 {                                                             \u2502\n\u2502   \"message\": \"\u2705 PowerSource: Aristo 500ix - Auto-selected    \u2502\n\u2502                \u2705 Feeder: RobustFeed U6 - Auto-selected       \u2502\n\u2502                Current Package: ...\",                         \u2502\n\u2502   \"current_state\": \"cooler_selection\",                        \u2502\n\u2502   \"response_json\": {                                          \u2502\n\u2502     \"PowerSource\": {\"gin\": \"0446200880\", ...},                \u2502\n\u2502     \"Feeder\": {\"gin\": \"0460520880\", ...}                      \u2502\n\u2502   },                                                          \u2502\n\u2502   \"awaiting_selection\": false                                 \u2502\n\u2502 }                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"API_DOCUMENTATION/#flow-5-state-skipping-component-not-applicable","title":"Flow 5: State Skipping (Component Not Applicable)","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 POST /api/v1/configurator/message\n                \u2502 {\"session_id\": \"...\", \"message\": \"skip\"}\n                \u2502\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 StateByStateOrchestrator.process_message()                    \u2502\n\u2502                                                               \u2502\n\u2502 Step 1: Check for special commands                           \u2502\n\u2502         - _is_special_command(\"skip\") \u2192 true                  \u2502\n\u2502         - Delegate to _handle_special_command()               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Handle \"skip\" command\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 _handle_special_command(\"skip\", ...)                          \u2502\n\u2502                                                               \u2502\n\u2502 Step 1: Check if component is skippable                      \u2502\n\u2502         - current_state = \"cooler_selection\"                  \u2502\n\u2502         - applicability.Cooler = \"Y\"                          \u2502\n\u2502         - Component is required \u2192 CANNOT SKIP                 \u2502\n\u2502         - Return error: \"Cooler is required...\"               \u2502\n\u2502                                                               \u2502\n\u2502 Alternative: If applicability = \"N\" or \"O\" (optional)         \u2502\n\u2502         - Mark component as skipped in ResponseJSON           \u2502\n\u2502         - Get next applicable state                           \u2502\n\u2502         - Generate skip confirmation message                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Return result\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                        \u2502\n\u2502 Receives:                                                     \u2502\n\u2502 {                                                             \u2502\n\u2502   \"message\": \"\u274c Cannot skip Cooler - it is required...\",     \u2502\n\u2502   \"current_state\": \"cooler_selection\",  // State unchanged   \u2502\n\u2502   \"awaiting_selection\": false                                 \u2502\n\u2502 }                                                             \u2502\n\u2502                                                               \u2502\n\u2502 OR (if skippable):                                            \u2502\n\u2502 {                                                             \u2502\n\u2502   \"message\": \"\u2705 Cooler skipped. Moving to Interconnector...\", \u2502\n\u2502   \"current_state\": \"interconnector_selection\",                \u2502\n\u2502   \"response_json\": {                                          \u2502\n\u2502     \"Cooler\": \"skipped\"  // Marked as skipped                \u2502\n\u2502   }                                                           \u2502\n\u2502 }                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"API_DOCUMENTATION/#flow-6-configuration-finalization","title":"Flow 6: Configuration Finalization","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 POST /api/v1/configurator/message\n                \u2502 {\"session_id\": \"...\", \"message\": \"done\"}\n                \u2502\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 StateByStateOrchestrator.process_message()                    \u2502\n\u2502                                                               \u2502\n\u2502 Step 1: Check for special commands                           \u2502\n\u2502         - _is_special_command(\"done\") \u2192 true                  \u2502\n\u2502         - Delegate to _handle_special_command()               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Handle \"done\" command\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 _handle_special_command(\"done\", ...)                          \u2502\n\u2502                                                               \u2502\n\u2502 Step 1: Validate minimum configuration                       \u2502\n\u2502         - Check ResponseJSON.PowerSource is not null          \u2502\n\u2502         - Minimum requirement: PowerSource selected           \u2502\n\u2502                                                               \u2502\n\u2502 Step 2: Transition to finalize state                         \u2502\n\u2502         - current_state = ConfiguratorState.FINALIZE          \u2502\n\u2502                                                               \u2502\n\u2502 Step 3: Generate finalize message (Agent 3)                  \u2502\n\u2502         - _generate_finalize_prompt()                         \u2502\n\u2502         - List all selected components                        \u2502\n\u2502         - Show component count                                \u2502\n\u2502         - Provide next actions (add accessories, export)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Return result\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                        \u2502\n\u2502 Receives:                                                     \u2502\n\u2502 {                                                             \u2502\n\u2502   \"message\": \"\u2705 Configuration Complete!\\n\\n                  \u2502\n\u2502                Your Welding Equipment Package:\\n              \u2502\n\u2502                1. PowerSource: Aristo 500ix\\n                 \u2502\n\u2502                2. Feeder: RobustFeed U6\\n                     \u2502\n\u2502                3. Cooler: Cool 50\\n...\",                      \u2502\n\u2502   \"current_state\": \"finalize\",                                \u2502\n\u2502   \"can_finalize\": true,                                       \u2502\n\u2502   \"awaiting_selection\": false                                 \u2502\n\u2502 }                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Optional: Archive session\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 POST /api/v1/configurator/archive/{session_id}                \u2502\n\u2502 - Save completed session to PostgreSQL                       \u2502\n\u2502 - Include full conversation history                          \u2502\n\u2502 - Include all agent actions                                  \u2502\n\u2502 - Mark as finalized                                          \u2502\n\u2502 - Optional: Delete from Redis to free memory                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"API_DOCUMENTATION/#flow-7-session-resumption","title":"Flow 7: Session Resumption","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                       \u2502\n\u2502 - User closes browser                                        \u2502\n\u2502 - Returns later with same session_id                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 POST /api/v1/configurator/message\n                \u2502 {\"session_id\": \"550e8400-...\", \"message\": \"resume\"}\n                \u2502\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 process_configurator_message()                                \u2502\n\u2502 - Retrieve session from Redis                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Check Redis\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 RedisSessionStorage.get_session()                             \u2502\n\u2502 - Key: session:{session_id}                                  \u2502\n\u2502 - Retrieve conversation state                                \u2502\n\u2502 - Deserialize MasterParameterJSON, ResponseJSON              \u2502\n\u2502 - Load conversation_history                                  \u2502\n\u2502 - Refresh TTL (extend by 3600s)                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Return ConversationState\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 StateByStateOrchestrator.process_message(\"resume\")            \u2502\n\u2502 - Generate resumption message                                \u2502\n\u2502 - Summary of current state                                   \u2502\n\u2502 - List selected components so far                            \u2502\n\u2502 - Prompt for next action                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u2502 Return result\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client                                                        \u2502\n\u2502 Receives:                                                     \u2502\n\u2502 {                                                             \u2502\n\u2502   \"message\": \"Welcome back! You are currently at Feeder       \u2502\n\u2502                selection. So far you have selected:\\n         \u2502\n\u2502                \u2022 PowerSource: Aristo 500ix\\n                  \u2502\n\u2502                What would you like to do next?\",              \u2502\n\u2502   \"current_state\": \"feeder_selection\",                        \u2502\n\u2502   \"response_json\": {                                          \u2502\n\u2502     \"PowerSource\": {\"gin\": \"0446200880\", ...}                 \u2502\n\u2502   }                                                           \u2502\n\u2502 }                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"API_DOCUMENTATION/#integration-with-3-agent-system","title":"Integration with 3-Agent System","text":"<p>The API serves as the orchestration layer coordinating all 3 agents:</p>"},{"location":"API_DOCUMENTATION/#agent-1-parameterextractor-llm-based-intent-understanding","title":"Agent 1: ParameterExtractor (LLM-Based Intent Understanding)","text":"<p>Integration Point: <code>process_message()</code> \u2192 <code>StateByStateOrchestrator.process_message()</code> \u2192 <code>ParameterExtractor.extract_parameters()</code></p> <p>Data Flow: <pre><code>User Message \u2192 ParameterExtractor\n              \u2193\n              Extract parameters using GPT-4\n              \u2193\n              Return updated MasterParameterJSON\n              \u2193\n              Pass to Agent 2 (ProductSearch)\n</code></pre></p> <p>Example: - Input: \"I need a 500A MIG welder for aluminum\" - Output: <code>{\"power_source\": {\"current_output\": \"500 A\", \"process\": \"MIG (GMAW)\", \"material\": \"Aluminum\"}}</code></p> <p>See Also: AGENT1_PARAMETER_EXTRACTOR.md</p>"},{"location":"API_DOCUMENTATION/#agent-2-productsearch-neo4j-graph-database","title":"Agent 2: ProductSearch (Neo4j Graph Database)","text":"<p>Integration Point: <code>StateByStateOrchestrator.process_message()</code> \u2192 <code>ComponentSearchService.search()</code></p> <p>Data Flow: <pre><code>MasterParameterJSON \u2192 ComponentSearchService\n                     \u2193\n                     Query Neo4j with Cypher\n                     \u2193\n                     Validate COMPATIBLE_WITH relationships\n                     \u2193\n                     Return SearchResults (List[ProductResult])\n                     \u2193\n                     Pass to Agent 3 (MessageGenerator)\n</code></pre></p> <p>Example: - Input: <code>{\"power_source\": {\"current_output\": \"500 A\", \"process\": \"MIG (GMAW)\"}}</code> - Output: <code>[{\"gin\": \"0446200880\", \"name\": \"Aristo 500ix\", ...}, {\"gin\": \"0445014880\", \"name\": \"Warrior 500i\", ...}]</code></p> <p>See Also: AGENT2_PRODUCT_SEARCH.md</p>"},{"location":"API_DOCUMENTATION/#agent-3-messagegenerator-template-based-llm-response-generation","title":"Agent 3: MessageGenerator (Template-Based + LLM Response Generation)","text":"<p>Integration Point: <code>StateByStateOrchestrator.process_message()</code> \u2192 <code>MessageGenerator.generate_response()</code></p> <p>Data Flow: <pre><code>SearchResults + ConversationState \u2192 MessageGenerator\n                                   \u2193\n                                   Generate state-specific prompt\n                                   \u2193\n                                   Format search results\n                                   \u2193\n                                   Translate to user's language\n                                   \u2193\n                                   Return formatted message string\n                                   \u2193\n                                   Return to client in MessageResponse\n</code></pre></p> <p>Example: - Input: <code>SearchResults</code> with 2 power sources + <code>current_state=\"power_source_selection\"</code> - Output: \"I found 2 power sources matching your requirements:\\n\\n1. Aristo 500ix (GIN: 0446200880)...\"</p> <p>See Also: AGENT3_MESSAGE_GENERATOR.md</p>"},{"location":"API_DOCUMENTATION/#session-management-architecture","title":"Session Management Architecture","text":""},{"location":"API_DOCUMENTATION/#session-storage-strategy","title":"Session Storage Strategy","text":"<p>Hot Storage (Redis): - Active sessions stored in Redis with TTL (default 3600s) - Key format: <code>session:{session_id}</code> - Automatic TTL refresh on each message - Fast retrieval for active conversations</p> <p>Cold Storage (PostgreSQL): - Completed sessions archived to PostgreSQL - Table: <code>archived_sessions</code> - Includes full conversation history + agent traces - Used for analytics and historical queries</p> <p>Fallback (In-Memory): - If Redis unavailable, use in-memory dictionary - No persistence across restarts - Background cleanup loop (every 300s) - Logged warning: \"Using in-memory fallback\"</p>"},{"location":"API_DOCUMENTATION/#session-lifecycle","title":"Session Lifecycle","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Session Creation                                            \u2502\n\u2502 - Generate UUID                                             \u2502\n\u2502 - Create ConversationState with defaults                    \u2502\n\u2502 - Save to Redis with TTL                                    \u2502\n\u2502 - Key: session:{uuid}                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n                     \u2502 User interactions\n                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Session Updates                                             \u2502\n\u2502 - Retrieve from Redis                                       \u2502\n\u2502 - Update conversation_history                               \u2502\n\u2502 - Update master_parameters                                  \u2502\n\u2502 - Update response_json                                      \u2502\n\u2502 - Update current_state                                      \u2502\n\u2502 - Save back to Redis                                        \u2502\n\u2502 - Refresh TTL (extend by 3600s)                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n                     \u2502 Configuration complete\n                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Session Finalization                                        \u2502\n\u2502 - current_state = \"finalize\"                                \u2502\n\u2502 - Validation: PowerSource selected (minimum)                \u2502\n\u2502 - Generate final package summary                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n                     \u2502 Optional: Manual archival\n                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Session Archival                                            \u2502\n\u2502 - POST /archive/{session_id}?delete_from_redis=true         \u2502\n\u2502 - Insert into PostgreSQL archived_sessions table            \u2502\n\u2502 - Include full conversation + agent logs                    \u2502\n\u2502 - Optional: Delete from Redis                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n                     \u2502 TTL expires (3600s idle)\n                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Automatic Expiration                                        \u2502\n\u2502 - Redis automatically removes key                           \u2502\n\u2502 - Session lost if not archived                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"API_DOCUMENTATION/#session-data-structure-redis","title":"Session Data Structure (Redis)","text":"<pre><code># Redis Hash Key: session:{session_id}\n{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"state\": \"feeder_selection\",  # Current configurator state\n  \"master_parameters\": \"{...}\",  # JSON-encoded MasterParameterJSON\n  \"response_json\": \"{...}\",      # JSON-encoded ResponseJSON\n  \"conversation_history\": \"[...]\",  # JSON-encoded list of messages\n  \"language\": \"en\",\n  \"created_at\": \"2025-01-17T10:30:00Z\",\n  \"last_updated\": \"2025-01-17T10:35:00Z\",\n  \"schema_version\": \"2.0\"\n}\n\n# TTL: 3600 seconds (refreshed on each message)\n</code></pre>"},{"location":"API_DOCUMENTATION/#session-data-structure-postgresql","title":"Session Data Structure (PostgreSQL)","text":"<pre><code># Table: archived_sessions\n{\n  \"session_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"created_at\": \"2025-01-17T10:30:00Z\",\n  \"completed_at\": \"2025-01-17T10:45:00Z\",\n  \"duration_seconds\": 900,\n  \"final_state\": \"finalize\",\n  \"finalized\": \"true\",\n  \"master_parameters\": {...},  # JSON\n  \"response_json\": {...},      # JSON\n  \"conversation_messages\": [...],  # JSON\n  \"agent_actions\": [...],      # JSON (optional)\n  \"total_messages\": 12,\n  \"had_errors\": \"false\"\n}\n</code></pre>"},{"location":"API_DOCUMENTATION/#error-handling-and-status-codes","title":"Error Handling and Status Codes","text":""},{"location":"API_DOCUMENTATION/#common-error-scenarios","title":"Common Error Scenarios","text":""},{"location":"API_DOCUMENTATION/#1-empty-message","title":"1. Empty Message","text":"<p>Request: <pre><code>{\n  \"message\": \"\"\n}\n</code></pre></p> <p>Response (400 Bad Request): <pre><code>{\n  \"detail\": \"Message cannot be empty\"\n}\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#2-invalid-language-code","title":"2. Invalid Language Code","text":"<p>Request: <pre><code>{\n  \"message\": \"I need a welder\",\n  \"language\": \"xx\"\n}\n</code></pre></p> <p>Response (400 Bad Request): <pre><code>{\n  \"detail\": \"Unsupported language: xx. Supported: en, es, fr, de, pt, it, sv\"\n}\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#3-session-not-found","title":"3. Session Not Found","text":"<p>Request: <pre><code>{\n  \"session_id\": \"invalid-uuid-123\",\n  \"message\": \"Continue\"\n}\n</code></pre></p> <p>Response (404 Not Found): <pre><code>{\n  \"detail\": \"Session not found: invalid-uuid-123\"\n}\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#4-agent-processing-error-llm-failure","title":"4. Agent Processing Error (LLM Failure)","text":"<p>Scenario: OpenAI API timeout or rate limit exceeded</p> <p>Response (500 Internal Server Error): <pre><code>{\n  \"detail\": \"Error processing message: LLM request failed after 3 retries\"\n}\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#5-database-connection-error","title":"5. Database Connection Error","text":"<p>Scenario: Neo4j connection lost during product search</p> <p>Response (500 Internal Server Error): <pre><code>{\n  \"detail\": \"Error processing message: Neo4j connection unavailable\"\n}\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#6-redis-unavailable-graceful-degradation","title":"6. Redis Unavailable (Graceful Degradation)","text":"<p>Scenario: Redis down, using in-memory fallback</p> <p>Response (200 OK - still operational): <pre><code>{\n  \"session_id\": \"550e8400-...\",\n  \"message\": \"I found 2 power sources...\",\n  \"current_state\": \"power_source_selection\",\n  \"products\": [...],\n  \"awaiting_selection\": true,\n  \"can_finalize\": false\n}\n</code></pre></p> <p>Note: Backend logs warning: \"\u26a0\ufe0f Redis unavailable, using in-memory storage\"</p>"},{"location":"API_DOCUMENTATION/#7-cannot-archive-non-finalized-session","title":"7. Cannot Archive Non-Finalized Session","text":"<p>Request: <pre><code>POST /api/v1/configurator/archive/550e8400-...\n</code></pre></p> <p>Scenario: Session not yet finalized (current_state != \"finalize\")</p> <p>Response (400 Bad Request): <pre><code>{\n  \"detail\": \"Cannot archive session: not finalized (current state: feeder_selection)\"\n}\n</code></pre></p>"},{"location":"API_DOCUMENTATION/#performance-metrics","title":"Performance Metrics","text":""},{"location":"API_DOCUMENTATION/#typical-response-times","title":"Typical Response Times","text":"<ul> <li>New Session Creation: 50-100ms (Redis write)</li> <li>Message Processing (LLM Extraction): 2-4s (OpenAI API latency)</li> <li>Message Processing (Selection Intent): 100-200ms (regex match, no LLM call)</li> <li>Product Search: 50-150ms (Neo4j query)</li> <li>Response Generation: 100-300ms (template-based)</li> <li>Session Retrieval: 10-20ms (Redis read)</li> <li>Session Save: 20-40ms (Redis write)</li> <li>Total End-to-End (New User Message): 2.5-5s (LLM-dependent)</li> <li>Total End-to-End (Selection): 200-400ms (no LLM)</li> </ul>"},{"location":"API_DOCUMENTATION/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Selection Intent Detection - Bypass LLM for number selections (~10ms vs ~2-4s)</li> <li>Redis Connection Pooling - Async connection pool with max 10 connections</li> <li>Neo4j Query Optimization - Indexed GIN lookups (&lt;50ms)</li> <li>Parallel Searches (Compound Requests) - Search multiple components simultaneously</li> <li>Template-Based Response Generation - Avoid LLM when possible (Agent 3)</li> <li>Lazy Database Initialization - Only initialize when first needed</li> <li>In-Memory Fallback - Continue operating if Redis down (degraded performance)</li> </ol>"},{"location":"API_DOCUMENTATION/#api-authentication-and-security","title":"API Authentication and Security","text":"<p>Current Implementation: No authentication (development mode)</p> <p>Production Recommendations: 1. JWT Authentication: Add Bearer token to all requests 2. Rate Limiting: Implement per-IP and per-session rate limits 3. CORS: Configure allowed origins in <code>main.py</code> 4. HTTPS Only: Enforce TLS in production 5. Input Validation: Sanitize all user messages 6. Session Security: Add user_id validation for session access</p> <p>See Also: DATABASE_CONNECTION_ARCHITECTURE.md for connection security</p>"},{"location":"API_DOCUMENTATION/#related-documentation","title":"Related Documentation","text":"<ul> <li>ORCHESTRATOR_ARCHITECTURE.md - StateByStateOrchestrator coordination logic</li> <li>AGENT1_PARAMETER_EXTRACTOR.md - LLM-based parameter extraction</li> <li>AGENT2_PRODUCT_SEARCH.md - Neo4j product search</li> <li>AGENT3_MESSAGE_GENERATOR.md - Response generation</li> <li>DATABASE_CONNECTION_ARCHITECTURE.md - Connection management and session storage</li> <li>CORRECTED_STATE_FLOW_ARCHITECTURE.md - S1\u2192SN state machine flow</li> <li>MASTER_PARAMETER_JSON_ARCHITECTURE.md - Data models</li> <li>MULTILINGUAL_FLOW.md - Translation architecture</li> </ul>"},{"location":"API_DOCUMENTATION/#file-location","title":"File Location","text":"<p>Source: <code>src/backend/app/api/v1/configurator.py</code></p> <p>Related Files: - <code>app/main.py</code> - FastAPI application and lifespan management - <code>app/services/orchestrator/state_orchestrator.py</code> - Orchestrator coordination - <code>app/database/redis_session_storage.py</code> - Session storage service - <code>app/database/postgres_archival.py</code> - PostgreSQL archival service - <code>app/models/conversation.py</code> - Data models (MessageRequest, MessageResponse, ConversationState)</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/","title":"Code Architecture Overview","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#executive-summary","title":"Executive Summary","text":"<p>ESAB Welding Equipment Configurator - Production-ready AI-powered configurator using configuration-driven state-machine architecture with multi-agent orchestration.</p> <p>Technology Stack: FastAPI, Neo4j, Redis, PostgreSQL, OpenAI GPT-4, Python 3.11+</p> <p>Architecture: 46 major refactored classes across 7 layers coordinating 3 AI agents through dynamic S1\u2192SN state flow.</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#end-to-end-flow-diagram","title":"End-to-End Flow Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 USER MESSAGE INPUT                                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 LAYER 1: API &amp; ROUTING                                           \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 FastAPI Application (main.py)                                \u2502 \u2502\n\u2502 \u2502 - Lifespan management, dependency injection                  \u2502 \u2502\n\u2502 \u2502 - Service initialization, middleware setup                   \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                           \u2193                                        \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 ConfiguratorAPIRouter (api/v1/configurator.py)               \u2502 \u2502\n\u2502 \u2502 - POST /message - Process user message                       \u2502 \u2502\n\u2502 \u2502 - POST /select - Explicit product selection                  \u2502 \u2502\n\u2502 \u2502 - GET /state - Session state retrieval                       \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 LAYER 2: SESSION MANAGEMENT                                       \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 RedisSessionStorage (database/redis_session_storage.py)      \u2502 \u2502\n\u2502 \u2502 - Hot session storage with TTL (default 3600s)               \u2502 \u2502\n\u2502 \u2502 - Key format: session:{session_id}                           \u2502 \u2502\n\u2502 \u2502 - Retrieval, creation, update, deletion                      \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 LAYER 3: ORCHESTRATION                                           \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 StateOrchestrator (orchestrator/state_orchestrator.py)       \u2502 \u2502\n\u2502 \u2502 - Main S1\u2192SN state machine coordination                      \u2502 \u2502\n\u2502 \u2502 - Component applicability logic                              \u2502 \u2502\n\u2502 \u2502 - Special command handling (skip, done, finalize)            \u2502 \u2502\n\u2502 \u2502 - Coordinates all 3 agents                                   \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                           \u2193                                        \u2502\n\u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u2502\n\u2502              \u2193                         \u2193                          \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2502\n\u2502   \u2502 State Processors \u2502    \u2502 Config Service   \u2502                   \u2502\n\u2502   \u2502 (13 processors)  \u2502    \u2502 (Singleton)      \u2502                   \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 LAYER 4: MULTI-AGENT PIPELINE                                    \u2502\n\u2502                                                                    \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 AGENT 1: Parameter Extractor (intent/parameter_extractor.py) \u2502 \u2502\n\u2502 \u2502 - Technology: OpenAI GPT-4                                   \u2502 \u2502\n\u2502 \u2502 - Input: User message + current state + existing parameters \u2502 \u2502\n\u2502 \u2502 - Output: Updated MasterParameterJSON                        \u2502 \u2502\n\u2502 \u2502 - Tracing: LangSmith @traceable                              \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                           \u2193                                        \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 AGENT 2: Search Orchestrator (search/orchestrator.py)        \u2502 \u2502\n\u2502 \u2502 - Context detection (proactive vs user intent)               \u2502 \u2502\n\u2502 \u2502 - Multi-strategy parallel execution                          \u2502 \u2502\n\u2502 \u2502 - Result consolidation &amp; threshold filtering                 \u2502 \u2502\n\u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502\n\u2502 \u2502 \u2502 CypherStrategy - Graph compatibility (50-100ms)          \u2502 \u2502 \u2502\n\u2502 \u2502 \u2502 LuceneStrategy - Fulltext search (100-200ms)             \u2502 \u2502 \u2502\n\u2502 \u2502 \u2502 VectorStrategy - Semantic similarity (200-400ms)         \u2502 \u2502 \u2502\n\u2502 \u2502 \u2502 LLMStrategy - AI-powered ranking (300-600ms)             \u2502 \u2502 \u2502\n\u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502\n\u2502 \u2502 - ALL strategies validate COMPATIBLE_WITH relationships      \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                           \u2193                                        \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 AGENT 3: Message Generator (response/message_generator.py)   \u2502 \u2502\n\u2502 \u2502 - Template-based response generation                         \u2502 \u2502\n\u2502 \u2502 - LLM translation for 7 languages                            \u2502 \u2502\n\u2502 \u2502 - Context-aware state prompts                                \u2502 \u2502\n\u2502 \u2502 - Result formatting                                          \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 LAYER 5: DATA MODELS                                              \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 ConversationState (models/conversation.py)                   \u2502 \u2502\n\u2502 \u2502 - Complete session state                                     \u2502 \u2502\n\u2502 \u2502 - MasterParameterJSON (user requirements)                    \u2502 \u2502\n\u2502 \u2502 - ResponseJSON (user selections/cart)                        \u2502 \u2502\n\u2502 \u2502 - Conversation history                                       \u2502 \u2502\n\u2502 \u2502 - Current state tracking                                     \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 LAYER 6: DATABASE SERVICES                                        \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u2502\n\u2502 \u2502 Neo4j          \u2502 Redis          \u2502 PostgreSQL     \u2502             \u2502\n\u2502 \u2502 Product graph  \u2502 Hot sessions   \u2502 Archival       \u2502             \u2502\n\u2502 \u2502 COMPATIBLE_WITH\u2502 TTL=3600s      \u2502 Long-term logs \u2502             \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 RESPONSE TO CLIENT                                                \u2502\n\u2502 - Updated ConversationState                                       \u2502\n\u2502 - User-facing message                                             \u2502\n\u2502 - Product search results (if applicable)                          \u2502\n\u2502 - State transition information                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#layer-by-layer-architecture","title":"Layer-by-Layer Architecture","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#layer-1-api-routing-5-classes","title":"Layer 1: API &amp; Routing (5 Classes)","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#1-fastapi-application","title":"1. FastAPI Application","text":"<p>File: <code>src/backend/app/main.py</code> Lines: ~250 lines Responsibilities: - Application initialization and lifespan management - Dependency injection setup - Service initialization (Neo4j, Redis, PostgreSQL, OpenAI) - Middleware configuration (CORS) - Static file mounting for frontend - Health check endpoint</p> <p>Key Methods: - <code>lifespan()</code> - Async context manager for startup/shutdown (lines 30-95) - <code>init_neo4j_driver()</code> - Neo4j connection (lines 100-120) - <code>init_redis_session_storage()</code> - Redis setup (lines 125-145) - <code>create_app()</code> - Application factory (lines 180-250)</p> <p>Dependencies: All services injected at startup</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#2-configuratorapirouter","title":"2. ConfiguratorAPIRouter","text":"<p>File: <code>src/backend/app/api/v1/configurator.py</code> Lines: ~920 lines Responsibilities: - REST API endpoint implementation - Request validation and error handling - Session management coordination - Response formatting</p> <p>Key Endpoints: - <code>POST /api/v1/configurator/message</code> - Process user message (lines 120-310) - <code>POST /api/v1/configurator/select</code> - Explicit product selection (lines 831-916) - <code>GET /api/v1/configurator/state/{session_id}</code> - Session retrieval (lines 450-520) - <code>DELETE /api/v1/configurator/session/{session_id}</code> - Session deletion (lines 540-590) - <code>POST /api/v1/configurator/archive/{session_id}</code> - Archive to PostgreSQL (lines 615-680)</p> <p>Dependencies: StateOrchestrator, RedisSessionStorage, PostgresArchivalService</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#3-healthcheckrouter","title":"3. HealthCheckRouter","text":"<p>File: <code>src/backend/app/api/health.py</code> Lines: ~80 lines Responsibilities: - System health monitoring - Service availability checking - Version information</p> <p>Key Endpoints: - <code>GET /health</code> - Complete system health (lines 20-75)</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#4-middleware-components","title":"4. Middleware Components","text":"<p>File: <code>src/backend/app/middleware/</code> Responsibilities: - CORS configuration - Request logging - Error handling middleware</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#5-static-file-handler","title":"5. Static File Handler","text":"<p>Configuration: <code>main.py</code> line 239 Responsibilities: - Serve frontend HTML/JS/CSS - Mount <code>src/frontend/</code> directory - Enable browser access to UI</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#layer-2-session-management-4-classes","title":"Layer 2: Session Management (4 Classes)","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#6-redissessionstorage","title":"6. RedisSessionStorage","text":"<p>File: <code>src/backend/app/database/redis_session_storage.py</code> Lines: ~280 lines Responsibilities: - Hot session storage with TTL - Session CRUD operations - Key management (format: <code>session:{session_id}</code>) - User session tracking (SET: <code>user:{user_id}:sessions</code>)</p> <p>Key Methods: - <code>get_session()</code> - Retrieve session by ID (lines 45-75) - <code>save_session()</code> - Create or update session (lines 80-125) - <code>delete_session()</code> - Remove session (lines 130-155) - <code>get_user_sessions()</code> - Get all user sessions (lines 160-195) - <code>get_latest_user_session()</code> - Resume functionality (lines 200-240)</p> <p>Configuration: TTL default 3600s (configurable)</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#7-postgresarchivalservice","title":"7. PostgresArchivalService","text":"<p>File: <code>src/backend/app/database/postgres_archival.py</code> Lines: ~220 lines Responsibilities: - Long-term session archival - Analytics data storage - Agent trace logging</p> <p>Key Methods: - <code>archive_session()</code> - Store completed session (lines 50-130) - <code>get_archived_session()</code> - Retrieve historical session (lines 135-175) - <code>get_sessions_by_user()</code> - User history (lines 180-215)</p> <p>Database: PostgreSQL table <code>archived_sessions</code></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#8-inmemorysessionstorage","title":"8. InMemorySessionStorage","text":"<p>File: <code>src/backend/app/database/in_memory_session_storage.py</code> Lines: ~150 lines Responsibilities: - Development/testing fallback - Non-persistent session storage - Used when Redis disabled</p> <p>Configuration: <code>ENABLE_REDIS_CACHING=false</code></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#9-databasemanager","title":"9. DatabaseManager","text":"<p>File: <code>src/backend/app/database/database.py</code> Lines: ~180 lines Responsibilities: - Database connection pooling - Health checking - Connection lifecycle management</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#layer-3-orchestration-8-classes","title":"Layer 3: Orchestration (8 Classes)","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#10-stateorchestrator-core-coordinator","title":"10. StateOrchestrator (\u2605 Core Coordinator)","text":"<p>File: <code>src/backend/app/services/orchestrator/state_orchestrator.py</code> Lines: ~1,450 lines Responsibilities: - Main S1\u2192SN state machine coordination - Component applicability logic (Y/N/O) - Special command handling (skip, done, finalize) - Agent pipeline coordination - Compound request processing (NEW in v2.1)</p> <p>Key Methods: - <code>process_message()</code> - Main orchestration loop (lines 85-180) - <code>select_product()</code> - Product selection handling (lines 254-320) - <code>_detect_compound_request()</code> - Multi-component detection (lines 350-380) - <code>_process_compound_request()</code> - Parallel component search (lines 400-580) - <code>_handle_skip_command()</code> - State skipping (lines 620-680) - <code>_handle_done_command()</code> - Multi-select completion (lines 690-750) - <code>_handle_finalize_command()</code> - Configuration completion (lines 760-850)</p> <p>State Transitions: Delegates to <code>ConversationState.get_next_state()</code></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#11-23-state-processors-13-classes","title":"11-23. State Processors (13 Classes)","text":"<p>File: <code>src/backend/app/services/orchestrator/processors/</code> Pattern: Registry pattern with factory</p> <p>Base Processor: - <code>StateProcessor</code> (base_processor.py) - Abstract base class</p> <p>Concrete Processors: 1. <code>PowerSourceSelectionProcessor</code> - S1: Initial power source search 2. <code>FeederSelectionProcessor</code> - S2: Wire feeder selection 3. <code>CoolerSelectionProcessor</code> - S3: Cooling system selection 4. <code>InterconnectorSelectionProcessor</code> - S4: Interconnector cable selection 5. <code>TorchSelectionProcessor</code> - S5: Welding torch selection 6. <code>AccessoriesSelectionProcessor</code> - S6: Accessory selection (multi-select) 7. <code>RemoteSelectionProcessor</code> - Remote control selection 8. <code>ConnectivitySelectionProcessor</code> - Connectivity accessories 9. <code>FeederWearSelectionProcessor</code> - Feeder wear parts 10. <code>PowerSourceAccessoriesProcessor</code> - PowerSource accessories 11. <code>FeederAccessoriesProcessor</code> - Feeder accessories 12. <code>RemoteAccessoriesProcessor</code> - Remote accessories 13. <code>FinalizeProcessor</code> - Configuration completion</p> <p>Each Processor Implements: - <code>process()</code> - Handle state-specific logic - <code>can_process()</code> - State matching - Configuration-driven behavior</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#24-stateprocessorregistry","title":"24. StateProcessorRegistry","text":"<p>File: <code>src/backend/app/services/orchestrator/processors/registry.py</code> Lines: ~120 lines Responsibilities: - Processor registration and lookup - Factory pattern implementation - Dynamic processor selection</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#layer-4-multi-agent-pipeline-13-classes","title":"Layer 4: Multi-Agent Pipeline (13 Classes)","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#agent-1-parameter-extraction","title":"AGENT 1: Parameter Extraction","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#25-parameterextractor","title":"25. ParameterExtractor","text":"<p>File: <code>src/backend/app/services/intent/parameter_extractor.py</code> Lines: ~380 lines Responsibilities: - Extract welding parameters from natural language - Update MasterParameterJSON dynamically - LLM-based intent understanding</p> <p>Key Methods: - <code>extract_parameters()</code> - Main extraction (lines 80-250, @traceable) - <code>_build_extraction_prompt()</code> - Prompt engineering (lines 255-320) - <code>_parse_llm_response()</code> - Response parsing (lines 325-375)</p> <p>LLM: OpenAI GPT-4 with structured JSON output Tracing: LangSmith integration</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#agent-2-product-search","title":"AGENT 2: Product Search","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#26-searchorchestrator","title":"26. SearchOrchestrator","text":"<p>File: <code>src/backend/app/services/search/orchestrator.py</code> Lines: ~450 lines Responsibilities: - Context detection (proactive vs user intent) - Multi-strategy parallel execution - Result consolidation coordination</p> <p>Key Methods: - <code>search()</code> - Main search coordination (lines 60-180) - <code>_detect_context()</code> - Mode detection (lines 111-146) - <code>_execute_strategies_parallel()</code> - Parallel execution (lines 185-250)</p> <p>Context Detection: <pre><code>command_keywords = [\"skip\", \"done\", \"next\", \"finalize\", \"yes\", \"no\", \"\"]\nis_proactive_display = user_message.lower().strip() in command_keywords\n</code></pre></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#27-cypherstrategy","title":"27. CypherStrategy","text":"<p>File: <code>src/backend/app/services/search/strategies/cypher_strategy.py</code> Lines: ~210 lines Responsibilities: - Graph-based compatibility search - Query-level COMPATIBLE_WITH validation - Priority-based ranking</p> <p>Key Methods: - <code>search()</code> - Execute Cypher search (lines 45-120) - <code>validate_compatibility()</code> - Compatibility check (lines 125-180)</p> <p>Performance: 50-100ms Compatibility: \u2705 Query-level via <code>Neo4jQueryBuilder</code></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#28-lucenestrategy","title":"28. LuceneStrategy","text":"<p>File: <code>src/backend/app/services/search/strategies/lucene_strategy.py</code> Lines: ~240 lines Responsibilities: - Fulltext keyword search - Query-level compatibility filtering - Relevance scoring</p> <p>Key Methods: - <code>search()</code> - Execute Lucene search (lines 50-140) - <code>validate_compatibility()</code> - Delegates to query builder (lines 145-190)</p> <p>Performance: 100-200ms Compatibility: \u2705 Query-level via <code>Neo4jQueryBuilder</code></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#29-vectorstrategy","title":"29. VectorStrategy","text":"<p>File: <code>src/backend/app/services/search/strategies/vector_strategy.py</code> Lines: ~320 lines Responsibilities: - Semantic similarity search - Embedding generation (OpenAI) - Post-query compatibility validation</p> <p>Key Methods: - <code>search()</code> - Execute vector search (lines 60-180) - <code>validate_compatibility()</code> - Post-query validation (lines 207-232)</p> <p>Performance: 200-400ms Compatibility: \u2705 Post-processing via delegation</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#30-llmstrategy","title":"30. LLMStrategy","text":"<p>File: <code>src/backend/app/services/search/strategies/llm_strategy.py</code> Lines: ~290 lines Responsibilities: - AI-powered query understanding - Intelligent result re-ranking - Inherits compatibility from retrieval</p> <p>Key Methods: - <code>search()</code> - Execute LLM search (lines 70-200) - <code>_retrieve_candidates()</code> - Get from Lucene/Vector (lines 112-182) - <code>validate_compatibility()</code> - Delegates to Lucene (lines 224-244)</p> <p>Performance: 300-600ms Compatibility: \u2705 Inherited from Lucene/Vector</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#31-resultconsolidator","title":"31. ResultConsolidator","text":"<p>File: <code>src/backend/app/services/search/consolidator.py</code> Lines: ~500 lines Responsibilities: - Weighted score consolidation from multiple strategies - Exact match boosting (100x multiplier) - Threshold filtering - Score appending to product names</p> <p>Key Methods: - <code>consolidate()</code> - Main consolidation (lines 60-200) - <code>_calculate_weighted_scores()</code> - Score merging (lines 205-280) - <code>_apply_exact_match_boost()</code> - 100x boost (lines 243-310) - <code>_apply_score_threshold()</code> - Filtering (lines 341-429) - <code>_append_scores_to_names()</code> - Display formatting (lines 312-340)</p> <p>Score Formula: <pre><code>final_score = (cypher * 0.25) + (lucene * 0.35) + (vector * 0.25) + (llm * 0.15)\n</code></pre></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#32-neo4jquerybuilder","title":"32. Neo4jQueryBuilder","text":"<p>File: <code>src/backend/app/services/search/query_builder.py</code> Lines: ~650 lines Responsibilities: - Centralized Cypher query construction - Compatibility validation logic (used by ALL query-based strategies) - Dynamic WHERE clause generation</p> <p>Key Methods: - <code>build_base_query()</code> - Base MATCH clause (lines 50-95) - <code>add_compatibility_filters()</code> - Central compatibility validation (lines 98-301) - <code>add_search_term_filters()</code> - LLM-extracted filters (lines 305-380) - <code>build_lucene_query()</code> - Fulltext queries (lines 385-480)</p> <p>Critical: This class provides THE centralized compatibility validation used by Cypher and Lucene strategies.</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#33-componentsearchservice","title":"33. ComponentSearchService","text":"<p>File: <code>src/backend/app/services/search/components/component_service.py</code> Lines: ~720 lines Responsibilities: - Neo4j product searches for all component types - Lucene native score preservation - Fuzzy product name matching</p> <p>Key Methods: - <code>search()</code> - Standard Cypher search (lines 145-285) - <code>search_with_lucene()</code> - Lucene fulltext search (lines 290-420) - <code>validate_compatibility()</code> - Compatibility validation (lines 425-550)</p> <p>Component Types: PowerSource, Feeder, Cooler, Interconnector, Torch, Accessories (6 types)</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#agent-3-response-generation","title":"AGENT 3: Response Generation","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#34-messagegenerator","title":"34. MessageGenerator","text":"<p>File: <code>src/backend/app/services/response/message_generator.py</code> Lines: ~580 lines Responsibilities: - Template-based response generation - State-specific prompts - Result formatting - Multilingual coordination</p> <p>Key Methods: - <code>generate_response()</code> - Main generation (lines 70-240) - <code>_build_state_prompt()</code> - Context-aware prompts (lines 245-380) - <code>_format_products()</code> - Product list formatting (lines 385-450)</p> <p>Message Types: selection, information, finalize, error</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#35-multilingualtranslator","title":"35. MultilingualTranslator","text":"<p>File: <code>src/backend/app/services/multilingual/translator.py</code> Lines: ~320 lines Responsibilities: - LLM-based translation to 7 languages - Language detection - Translation caching</p> <p>Key Methods: - <code>translate()</code> - Main translation (lines 60-180, @traceable) - <code>detect_language()</code> - Language detection (lines 185-230)</p> <p>Languages: en, es, fr, de, pt, it, sv</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#layer-5-data-models-12-classes","title":"Layer 5: Data Models (12 Classes)","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#36-conversationstate","title":"36. ConversationState","text":"<p>File: <code>src/backend/app/models/conversation.py</code> Lines: ~450 lines Responsibilities: - Complete session state management - State transition logic - Next state calculation</p> <p>Key Attributes: - <code>session_id: str</code> - Unique session identifier - <code>user_id: str</code> - User identifier - <code>current_state: ConfiguratorState</code> - S1-SN state - <code>master_parameters: MasterParameterJSON</code> - User requirements - <code>response_json: ResponseJSON</code> - User selections (cart) - <code>conversation_history: List[ConversationTurn]</code> - Message history - <code>created_at: datetime</code> - Session creation timestamp - <code>updated_at: datetime</code> - Last update timestamp</p> <p>Key Methods: - <code>get_next_state()</code> - Dynamic state transition (lines 180-320) - <code>can_finalize()</code> - Validation check (lines 325-360) - <code>to_dict()</code> - Serialization (lines 365-410)</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#37-masterparameterjson","title":"37. MasterParameterJSON","text":"<p>File: <code>src/backend/app/models/conversation.py</code> Lines: Part of conversation.py Responsibilities: - Track user requirements by component - Dynamically created from schema - Updated by Agent 1 (ParameterExtractor)</p> <p>Structure: <pre><code>{\n  \"power_source\": {\"product_name\": \"...\", \"current_output\": \"500A\", ...},\n  \"feeder\": {\"product_name\": \"...\", \"cooling_type\": \"water-cooled\", ...},\n  # ... other components\n}\n</code></pre></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#38-responsejson","title":"38. ResponseJSON","text":"<p>File: <code>src/backend/app/models/conversation.py</code> Lines: Part of conversation.py Responsibilities: - User's selection cart - Selected products by component - Component applicability flags</p> <p>Structure: <pre><code>{\n  \"PowerSource\": SelectedProduct(...),\n  \"Feeder\": SelectedProduct(...),\n  \"Accessories\": [SelectedProduct(...), ...],\n  \"applicability\": ComponentApplicability(Feeder=\"Y\", Cooler=\"N\", ...)\n}\n</code></pre></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#39-selectedproduct","title":"39. SelectedProduct","text":"<p>File: <code>src/backend/app/models/conversation.py</code> Responsibilities: - Individual product selection details - GIN, name, category, specifications</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#40-componentapplicability","title":"40. ComponentApplicability","text":"<p>File: <code>src/backend/app/models/conversation.py</code> Responsibilities: - Track which components are applicable (Y/N/O) - Loaded from <code>component_applicability.json</code> - Drives state skipping logic</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#41-configuratorstate-enum","title":"41. ConfiguratorState (Enum)","text":"<p>File: <code>src/backend/app/models/conversation.py</code> Responsibilities: - Define all possible states in S1\u2192SN flow - State type classification</p> <p>States: <pre><code>POWER_SOURCE_SELECTION = \"power_source_selection\"  # S1\nFEEDER_SELECTION = \"feeder_selection\"              # S2\nCOOLER_SELECTION = \"cooler_selection\"              # S3\nINTERCONNECTOR_SELECTION = \"interconnector_selection\"  # S4\nTORCH_SELECTION = \"torch_selection\"                # S5\nACCESSORIES_SELECTION = \"accessories_selection\"    # S6\nFINALIZE = \"FINALIZE\"                              # S7\n</code></pre></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#42-47-additional-models","title":"42-47. Additional Models","text":"<ul> <li><code>ConversationTurn</code> - Single message exchange</li> <li><code>ProductResult</code> - Search result item</li> <li><code>SearchResults</code> - List of products + metadata</li> <li><code>ConsolidatedResult</code> - Multi-strategy merged result</li> <li><code>MasterParameterSchema</code> - Dynamic schema definition</li> <li><code>ComponentConfig</code> - Component type configuration</li> </ul>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#layer-6-supporting-services-4-classes","title":"Layer 6: Supporting Services (4 Classes)","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#48-configurationservice-singleton","title":"48. ConfigurationService (\u2605 Singleton)","text":"<p>File: <code>src/backend/app/services/config/configuration_service.py</code> Lines: ~420 lines Responsibilities: - Centralized configuration management - LRU caching for config files - Hot reload support - Schema validation</p> <p>Key Methods: - <code>get_component_types()</code> - Component config (cached, lines 80-120) - <code>get_component_applicability()</code> - Applicability rules (cached, lines 125-165) - <code>get_search_config()</code> - Search strategy config (cached, lines 170-210) - <code>get_master_parameter_schema()</code> - Dynamic schema (cached, lines 215-255) - <code>reload_config()</code> - Hot reload (lines 260-295)</p> <p>Pattern: Singleton with function-level caching Cache: LRU with max_size=128</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#49-schemaloader","title":"49. SchemaLoader","text":"<p>File: <code>src/backend/app/config/schema_loader.py</code> Lines: ~280 lines Responsibilities: - Dynamic Pydantic model generation - JSON schema to Python class conversion - Runtime model creation</p> <p>Key Methods: - <code>load_master_parameter_schema()</code> - Create MasterParameterJSON model (lines 50-180) - <code>create_pydantic_model()</code> - Dynamic model factory (lines 185-250)</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#50-langsmithservice","title":"50. LangSmithService","text":"<p>File: <code>src/backend/app/services/observability/langsmith_service.py</code> Lines: ~150 lines Responsibilities: - LangSmith tracing integration - @traceable decorator setup - Trace logging</p> <p>Configuration: <code>LANGSMITH_API_KEY</code>, <code>LANGSMITH_PROJECT</code>, <code>LANGSMITH_TRACING</code></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#51-ginmanager","title":"51. GINManager","text":"<p>File: <code>src/backend/app/services/gin_manager.py</code> Lines: ~180 lines Responsibilities: - GIN (Global Item Number) validation - Product lookup by GIN - GIN formatting</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#architectural-patterns","title":"Architectural Patterns","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#1-dependency-injection","title":"1. Dependency Injection","text":"<p>Implementation: <code>main.py</code> lifespan() function Services Injected: - Neo4j driver - Redis client - PostgreSQL connection - OpenAI client - All service singletons</p> <p>Pattern: <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup: Initialize all services\n    app.state.neo4j_driver = init_neo4j_driver()\n    app.state.redis_client = init_redis_client()\n    # ... other services\n    yield\n    # Shutdown: Close all connections\n</code></pre></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#2-singleton-pattern","title":"2. Singleton Pattern","text":"<p>Implementation: ConfigurationService Purpose: Single instance with LRU caching Access: <code>get_config_service()</code> factory function</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#3-registry-pattern","title":"3. Registry Pattern","text":"<p>Implementation: StateProcessorRegistry Purpose: Dynamic processor lookup by state Pattern: <pre><code>@StateProcessorRegistry.register(ConfiguratorState.POWER_SOURCE_SELECTION)\nclass PowerSourceSelectionProcessor(StateProcessor):\n    ...\n</code></pre></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#4-factory-pattern","title":"4. Factory Pattern","text":"<p>Implementation: Search strategies, State processors Purpose: Dynamic object creation based on configuration</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#5-strategy-pattern","title":"5. Strategy Pattern","text":"<p>Implementation: Search strategies (Cypher, Lucene, Vector, LLM) Purpose: Interchangeable search algorithms</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#6-template-method-pattern","title":"6. Template Method Pattern","text":"<p>Implementation: StateProcessor base class Purpose: Common workflow with state-specific customization</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#quick-reference-tables","title":"Quick Reference Tables","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#by-layer","title":"By Layer","text":"Layer Classes Primary Responsibility API &amp; Routing 5 HTTP endpoints, request handling Session Management 4 Session CRUD, hot/cold storage Orchestration 8 State machine, processor coordination Multi-Agent Pipeline 13 Parameter extraction, search, response generation Data Models 12 State representation, validation Supporting Services 4 Configuration, observability, utilities"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#by-responsibility","title":"By Responsibility","text":"Responsibility Key Classes Files State Machine StateOrchestrator, ConversationState orchestrator/state_orchestrator.py, models/conversation.py Product Search SearchOrchestrator, 4 strategies, ComponentSearchService search/* Compatibility Validation Neo4jQueryBuilder, All strategies search/query_builder.py, search/strategies/* Parameter Extraction ParameterExtractor intent/parameter_extractor.py Response Generation MessageGenerator, MultilingualTranslator response/, multilingual/ Configuration ConfigurationService, SchemaLoader config/* Session Storage RedisSessionStorage, PostgresArchivalService database/* API Layer ConfiguratorAPIRouter, HealthCheckRouter api/v1/*"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#by-performance-characteristic","title":"By Performance Characteristic","text":"Operation Classes Typical Latency Fast Proactive Search CypherStrategy, ComponentSearchService 50-200ms Comprehensive Search All 4 strategies + ResultConsolidator 200-800ms Parameter Extraction ParameterExtractor (LLM) 300-800ms Session Retrieval RedisSessionStorage 5-20ms State Transition StateOrchestrator 10-50ms Response Generation MessageGenerator 50-200ms Translation MultilingualTranslator (LLM) 200-500ms"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#critical-integration-points","title":"Critical Integration Points","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#1-compatibility-validation-architecture","title":"1. Compatibility Validation Architecture","text":"<p>Centralized Implementation: <code>Neo4jQueryBuilder.add_compatibility_filters()</code> (lines 98-301)</p> <p>Used By: - CypherStrategy (query-level) - LuceneStrategy (query-level) - VectorStrategy (post-processing via delegation) - LLMStrategy (inherited from retrieval)</p> <p>Why Important: Single source of truth for compatibility logic prevents inconsistencies.</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#2-configuration-driven-behavior","title":"2. Configuration-Driven Behavior","text":"<p>Single Source: <code>ConfigurationService</code> singleton</p> <p>Configuration Files: - <code>component_types.json</code> - Component metadata, compatibility requirements - <code>component_applicability.json</code> - Y/N/O rules per power source - <code>search_config.json</code> - Strategy selection, context-based modes - <code>master_parameter_schema.json</code> - Dynamic schema definition</p> <p>Hot Reload: <code>reload_config()</code> method allows runtime updates</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#3-state-transition-logic","title":"3. State Transition Logic","text":"<p>Implementation: <code>ConversationState.get_next_state()</code></p> <p>Auto-Skip Logic: <pre><code>if applicability.get(component) == \"N\":\n    # Skip this state, move to next\n    continue\n</code></pre></p> <p>Mandatory Components: PowerSource always required</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#4-multi-strategy-search-coordination","title":"4. Multi-Strategy Search Coordination","text":"<p>Orchestrator: <code>SearchOrchestrator</code></p> <p>Context Detection \u2192 Strategy Selection \u2192 Parallel Execution \u2192 Consolidation \u2192 Threshold Filtering</p> <p>Key: ALL strategies ensure compatibility at appropriate layer.</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#development-workflow-patterns","title":"Development Workflow Patterns","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#adding-a-new-component-type","title":"Adding a New Component Type","text":"<ol> <li>Update <code>master_parameter_schema.json</code> - Define component parameters</li> <li>Update <code>component_types.json</code> - Add component metadata, dependencies</li> <li>Update <code>component_applicability.json</code> - Define Y/N/O rules</li> <li>Add state to <code>ConfiguratorState</code> enum - New state constant</li> <li>Create state processor - Implement <code>StateProcessor</code> subclass</li> <li>Register processor - Use <code>@StateProcessorRegistry.register()</code></li> <li>Update <code>ResponseJSON</code> model - Add new component field</li> <li>Test state transitions - Verify skipping and progression</li> </ol>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#modifying-search-logic","title":"Modifying Search Logic","text":"<ol> <li>For compatibility changes: Edit <code>Neo4jQueryBuilder.add_compatibility_filters()</code></li> <li>For new search strategy: Implement <code>SearchStrategy</code> interface</li> <li>For scoring changes: Edit <code>ResultConsolidator</code> weights</li> <li>For context detection: Edit <code>SearchOrchestrator._detect_context()</code></li> <li>Test: Use <code>test_chat_flow.py</code> for offline testing</li> </ol>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#adding-new-language-support","title":"Adding New Language Support","text":"<ol> <li>Frontend: Edit <code>src/frontend/translations.js</code> - Add translation dictionary</li> <li>Backend: Add to <code>LANGUAGE_NAMES</code> in <code>multilingual/translator.py</code></li> <li>Test: Send message with <code>language</code> parameter</li> </ol>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#javadoc-equivalent-documentation","title":"JavaDoc-Equivalent Documentation","text":""},{"location":"CODE_ARCHITECTURE_OVERVIEW/#recommended-tooling-mkdocs-mkdocstrings","title":"Recommended Tooling: MkDocs + mkdocstrings","text":"<p>Setup: <pre><code>pip install mkdocs mkdocs-material mkdocstrings[python]\n</code></pre></p> <p>Configuration: See <code>mkdocs.yml</code> (to be created in next step)</p> <p>Features: - Auto-generate API reference from Google-style docstrings - Beautiful Material theme - Search functionality - Versioning support - Deploy to Read the Docs or GitHub Pages</p> <p>Build Commands: <pre><code>mkdocs serve      # Local development server\nmkdocs build      # Generate static site\nmkdocs gh-deploy  # Deploy to GitHub Pages\n</code></pre></p> <p>Docstring Style: Google-style (already in use)</p> <p>Example: <pre><code>def add_compatibility_filters(\n    self,\n    query: str,\n    params: Dict[str, Any],\n    component_type: str\n) -&gt; Tuple[str, Dict[str, Any], Optional[str]]:\n    \"\"\"\n    Add COMPATIBLE_WITH relationship filters for dependent components.\n\n    Args:\n        query: Base Cypher query string\n        params: Query parameters dict\n        component_type: Component being searched (e.g., \"feeder\")\n\n    Returns:\n        Tuple of (modified_query, modified_params, parent_gins_var)\n\n    Example:\n        &gt;&gt;&gt; builder = Neo4jQueryBuilder(config)\n        &gt;&gt;&gt; query, params, _ = builder.add_compatibility_filters(\n        ...     \"MATCH (f:Feeder)\", {}, \"feeder\", {\"power_source\": {...}}\n        ... )\n        &gt;&gt;&gt; # Adds: MATCH (ps:PowerSource {gin: $ps_gin})\n        &gt;&gt;&gt; #       MATCH (f)-[:COMPATIBLE_WITH]-&gt;(ps)\n    \"\"\"\n</code></pre></p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#summary","title":"Summary","text":"<p>46 Major Classes organized across 7 architectural layers coordinate 3 AI agents through a dynamic S1\u2192SN state machine to deliver a production-ready welding equipment configurator.</p> <p>Key Architectural Strengths: - \u2705 Configuration-driven behavior (easy to modify without code changes) - \u2705 Centralized compatibility validation (single source of truth) - \u2705 Multi-strategy search with intelligent context detection - \u2705 Modular state processors via registry pattern - \u2705 Dependency injection for testability - \u2705 Singleton configuration service with LRU caching - \u2705 Async architecture for performance - \u2705 Comprehensive observability (LangSmith tracing)</p> <p>Recommended Documentation Tooling: MkDocs + mkdocstrings for JavaDoc-equivalent auto-generated API documentation.</p>"},{"location":"CODE_ARCHITECTURE_OVERVIEW/#related-documentation","title":"Related Documentation","text":"<ul> <li>Context-Based Strategies - Search strategy configuration</li> <li>Corrected State Flow Architecture - S1\u2192SN state machine</li> <li>Master Parameter JSON Architecture - Data model design</li> <li>Product Search Service - Neo4j search details</li> <li>Threshold Filtering Analysis - Score filtering</li> <li>Testing Guide - Testing best practices</li> <li>Deployment Guide - Production deployment</li> </ul> <p>Main Documentation: <code>CLAUDE.md</code> - Complete project overview</p>"},{"location":"CONFIGURATION_SYSTEM/","title":"Configuration System Architecture","text":"<p>File: <code>src/backend/app/services/config/configuration_service.py</code></p> <p>The Configuration System is a centralized, cached service for loading and managing all application configurations in the ESAB Configurator.</p>"},{"location":"CONFIGURATION_SYSTEM/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Architecture Pattern</li> <li>Core Features</li> <li>Configuration Files</li> <li>API Reference</li> <li>Usage Examples</li> <li>Performance Optimization</li> <li>Hot Reload</li> <li>Related Documentation</li> </ul>"},{"location":"CONFIGURATION_SYSTEM/#overview","title":"Overview","text":"<p>The ConfigurationService provides a single source of truth for all application configuration with:</p> <ul> <li>Centralized Loading: All configs loaded from <code>app/config/</code> directory</li> <li>LRU Caching: Fast repeated access with <code>@lru_cache(maxsize=32)</code></li> <li>Hot Reload: Runtime config updates via <code>reload_config()</code></li> <li>Type Safety: Validation and schema checking</li> <li>Global Access: Singleton pattern with <code>get_config_service()</code></li> </ul> <p>Architecture: Singleton Pattern + LRU Caching</p> <pre><code>Application Code\n    \u2193\nget_config_service() [Global Singleton]\n    \u2193\nConfigurationService\n    \u251c\u2500\u2192 @lru_cache(maxsize=32)\n    \u251c\u2500\u2192 load_config(\"config_name\")\n    \u251c\u2500\u2192 30+ specialized methods\n    \u2514\u2500\u2192 /app/config/*.json files\n</code></pre>"},{"location":"CONFIGURATION_SYSTEM/#architecture-pattern","title":"Architecture Pattern","text":""},{"location":"CONFIGURATION_SYSTEM/#singleton-pattern","title":"Singleton Pattern","text":"<p>Implementation (<code>configuration_service.py:477-483</code>):</p> <pre><code># Global singleton instance\n_config_service: Optional[ConfigurationService] = None\n\ndef get_config_service() -&gt; ConfigurationService:\n    \"\"\"Get global ConfigurationService singleton instance\"\"\"\n    global _config_service\n    if _config_service is None:\n        _config_service = ConfigurationService()\n    return _config_service\n</code></pre> <p>Benefits: - Single instance across entire application - Shared cache across all modules - Consistent configuration state - Memory efficient (one copy of each config)</p> <p>Usage: <pre><code>from app.services.config.configuration_service import get_config_service\n\nconfig_service = get_config_service()\ncomponent_types = config_service.get_component_types()\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#lru-caching-pattern","title":"LRU Caching Pattern","text":"<p>Implementation (<code>configuration_service.py:39-48</code>):</p> <pre><code>from functools import lru_cache\n\n@lru_cache(maxsize=32)\ndef load_config(self, config_name: str) -&gt; Dict[str, Any]:\n    \"\"\"Load configuration from JSON file with caching\"\"\"\n    config_path = self.config_dir / f\"{config_name}.json\"\n    with open(config_path, \"r\", encoding=\"utf-8\") as f:\n        config = json.load(f)\n    return config\n</code></pre> <p>Cache Characteristics: - Size: 32 entries (sufficient for all config files) - Eviction Policy: Least Recently Used (LRU) - Key: Config name string (e.g., \"component_types\", \"state_config\") - Value: Parsed JSON dict - Performance: O(1) for cache hits, file I/O for cache misses</p>"},{"location":"CONFIGURATION_SYSTEM/#core-features","title":"Core Features","text":""},{"location":"CONFIGURATION_SYSTEM/#1-centralized-configuration-directory","title":"1. Centralized Configuration Directory","text":"<p>Location: <code>src/backend/app/config/</code></p> <p>All configuration files are JSON-based and stored in a single directory:</p> <pre><code>app/config/\n\u251c\u2500\u2500 component_applicability.json     # Y/N component rules per power source\n\u251c\u2500\u2500 component_types.json             # Component metadata and state sequence\n\u251c\u2500\u2500 master_parameter_schema.json     # Dynamic MasterParameterJSON schema\n\u251c\u2500\u2500 product_names.json               # Product lookup cache\n\u251c\u2500\u2500 prompts.json                     # LLM prompt templates\n\u251c\u2500\u2500 state_config.json                # State processor configuration\n\u251c\u2500\u2500 search_config.json               # Search strategy configuration\n\u251c\u2500\u2500 llm_config.json                  # LLM model configuration\n\u2514\u2500\u2500 languages.json                   # Supported languages\n</code></pre>"},{"location":"CONFIGURATION_SYSTEM/#2-lazy-loading-with-caching","title":"2. Lazy Loading with Caching","text":"<p>First Call (cache miss): 1. Reads JSON file from disk 2. Parses JSON 3. Stores in LRU cache 4. Returns dict</p> <p>Subsequent Calls (cache hit): 1. Returns dict directly from cache 2. No disk I/O 3. Sub-millisecond response time</p>"},{"location":"CONFIGURATION_SYSTEM/#3-type-safety-and-validation","title":"3. Type Safety and Validation","text":"<p>All configuration loading methods include: - Schema validation (JSON structure checking) - Key existence validation (required fields) - Type coercion (int, float, bool conversion) - Default values (fallback for missing fields)</p> <p>Example (<code>get_session_ttl</code> method): <pre><code>def get_session_ttl(self) -&gt; int:\n    \"\"\"Get Redis session TTL in seconds (default: 3600)\"\"\"\n    config = self.load_config(\"session_config\")\n    return config.get(\"ttl\", 3600)  # Default to 1 hour\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#4-global-singleton-access","title":"4. Global Singleton Access","text":"<p>Pattern: Global instance created on first access</p> <p>Thread Safety: Python GIL ensures thread-safe singleton initialization</p> <p>Benefits: - No dependency injection needed - Import anywhere in codebase - Consistent state across modules - Shared cache across all services</p>"},{"location":"CONFIGURATION_SYSTEM/#configuration-files","title":"Configuration Files","text":""},{"location":"CONFIGURATION_SYSTEM/#component_typesjson","title":"component_types.json","text":"<p>Purpose: Defines all component types, their metadata, and state sequence</p> <p>Structure: <pre><code>{\n  \"component_types\": {\n    \"PowerSource\": {\n      \"state_name\": \"power_source_selection\",\n      \"neo4j_label\": \"Product\",\n      \"category_field\": \"category\",\n      \"category_value\": \"PowerSource\",\n      \"field_name_in_response_json\": \"PowerSource\",\n      \"field_name_in_master_parameters\": \"power_source\"\n    },\n    \"Feeder\": { /* ... */ },\n    \"Cooler\": { /* ... */ }\n  },\n  \"state_sequence\": [\n    \"power_source_selection\",\n    \"feeder_selection\",\n    \"cooler_selection\",\n    \"interconnector_selection\",\n    \"torch_selection\",\n    \"powersource_accessories_selection\",\n    \"feeder_accessories_selection\",\n    \"feeder_conditional_accessories\",\n    \"interconnector_accessories_selection\",\n    \"remote_selection\",\n    \"remote_accessories_selection\",\n    \"remote_conditional_accessories\",\n    \"connectivity_selection\",\n    \"finalize\"\n  ]\n}\n</code></pre></p> <p>Used By: - StateProcessorRegistry (processor initialization) - ConversationState (state transitions) - SearchOrchestrator (component type mapping) - AccessoryStateProcessor (state sequencing)</p> <p>Accessor: <code>get_component_types() -&gt; Dict[str, Any]</code></p>"},{"location":"CONFIGURATION_SYSTEM/#state_configjson","title":"state_config.json","text":"<p>Purpose: Configuration for all 14 state processors</p> <p>Structure: <pre><code>{\n  \"states\": {\n    \"power_source_selection\": {\n      \"state_name\": \"Power Source Selection\",\n      \"mandatory\": true,\n      \"proactive_display\": true,\n      \"search_limit\": 10,\n      \"preview_limit\": 5,\n      \"multi_select\": false,\n      \"allow_skip\": false\n    },\n    \"feeder_selection\": {\n      \"state_name\": \"Feeder Selection\",\n      \"mandatory\": false,\n      \"proactive_display\": true,\n      \"search_limit\": 10,\n      \"preview_limit\": 5,\n      \"multi_select\": false,\n      \"allow_skip\": true\n    }\n    /* ... 12 more states */\n  }\n}\n</code></pre></p> <p>Used By: - StateProcessorRegistry (processor configuration) - StateProcessor base class (configuration extraction)</p> <p>Accessor: <code>get_state_config() -&gt; Dict[str, Any]</code></p>"},{"location":"CONFIGURATION_SYSTEM/#component_applicabilityjson","title":"component_applicability.json","text":"<p>Purpose: Defines which components are applicable (Y/N) for each power source</p> <p>Structure: <pre><code>{\n  \"power_sources\": {\n    \"0446200880\": {\n      \"name\": \"Aristo 500ix\",\n      \"applicability\": {\n        \"Feeder\": \"Y\",\n        \"Cooler\": \"Y\",\n        \"Interconnector\": \"Y\",\n        \"Torch\": \"Y\",\n        \"Accessories\": \"Y\",\n        \"PowerSourceAccessories\": \"Y\",\n        \"FeederAccessories\": \"Y\",\n        \"FeederConditionalAccessories\": \"Y\",\n        \"InterconnectorAccessories\": \"Y\",\n        \"Remotes\": \"Y\",\n        \"RemoteAccessories\": \"Y\",\n        \"RemoteConditionalAccessories\": \"Y\",\n        \"Connectivity\": \"Y\"\n      }\n    }\n  },\n  \"default_policy\": {\n    \"name\": \"Default Policy\",\n    \"applicability\": {\n      \"Feeder\": \"Y\",\n      \"Cooler\": \"Y\",\n      /* ... all components default to Y */\n    }\n  }\n}\n</code></pre></p> <p>Used By: - StateByStateOrchestrator (applicability loading after S1) - ConversationState (state transition logic with auto-skip)</p> <p>Accessor: <code>get_component_applicability() -&gt; Dict[str, Any]</code></p>"},{"location":"CONFIGURATION_SYSTEM/#master_parameter_schemajson","title":"master_parameter_schema.json","text":"<p>Purpose: Defines schema for dynamically creating MasterParameterJSON model</p> <p>Structure: <pre><code>{\n  \"power_source\": {\n    \"product_name\": \"string\",\n    \"process\": \"string\",\n    \"current_output\": \"string\",\n    \"material\": \"string\",\n    \"voltage\": \"string\"\n  },\n  \"feeder\": {\n    \"product_name\": \"string\",\n    \"cooling_type\": \"string\",\n    \"wire_size\": \"string\"\n  },\n  \"cooler\": {\n    \"product_name\": \"string\",\n    \"cooling_capacity\": \"string\"\n  }\n  /* ... other components */\n}\n</code></pre></p> <p>Used By: - Schema loader (dynamic Pydantic model creation) - ParameterExtractor (LLM extraction schema)</p> <p>Accessor: <code>get_master_parameter_schema() -&gt; Dict[str, Any]</code></p>"},{"location":"CONFIGURATION_SYSTEM/#search_configjson","title":"search_config.json","text":"<p>Purpose: Configuration for search strategies and orchestrator</p> <p>Structure: <pre><code>{\n  \"strategies\": {\n    \"cypher\": {\n      \"enabled\": true,\n      \"priority\": 1,\n      \"weight\": 0.4\n    },\n    \"lucene\": {\n      \"enabled\": true,\n      \"priority\": 2,\n      \"weight\": 0.3,\n      \"min_score\": 0.1\n    },\n    \"vector\": {\n      \"enabled\": true,\n      \"priority\": 3,\n      \"weight\": 0.2,\n      \"min_score\": 0.6,\n      \"embedding_model\": \"text-embedding-3-large\",\n      \"embedding_dims\": 3072\n    },\n    \"llm\": {\n      \"enabled\": true,\n      \"priority\": 4,\n      \"weight\": 0.1,\n      \"retrieval_method\": \"combined\",\n      \"retrieval_limit\": 20,\n      \"top_k\": 10\n    }\n  },\n  \"consolidation\": {\n    \"max_results\": 10,\n    \"deduplication\": true,\n    \"normalization\": \"min-max\"\n  }\n}\n</code></pre></p> <p>Used By: - SearchOrchestrator (strategy configuration) - VectorSearchStrategy (embedding config) - LLMSearchStrategy (retrieval config)</p> <p>Accessor: <code>get_search_config() -&gt; Dict[str, Any]</code></p>"},{"location":"CONFIGURATION_SYSTEM/#llm_configjson","title":"llm_config.json","text":"<p>Purpose: Configuration for LLM models used across the application</p> <p>Structure: <pre><code>{\n  \"parameter_extraction\": {\n    \"model\": \"gpt-4\",\n    \"temperature\": 0.1,\n    \"max_tokens\": 2000\n  },\n  \"llm_search_reranking\": {\n    \"model\": \"gpt-4o-mini\",\n    \"temperature\": 0.1,\n    \"response_format\": {\"type\": \"json_object\"}\n  },\n  \"message_generation\": {\n    \"model\": \"gpt-4o-mini\",\n    \"temperature\": 0.7,\n    \"max_tokens\": 500\n  },\n  \"translation\": {\n    \"model\": \"gpt-4o-mini\",\n    \"temperature\": 0.3,\n    \"max_tokens\": 1000\n  }\n}\n</code></pre></p> <p>Used By: - ParameterExtractor (parameter extraction config) - LLMSearchStrategy (reranking config) - MessageGenerator (response generation config) - MultilingualTranslator (translation config)</p> <p>Accessor: <code>get_llm_config(purpose: str) -&gt; Dict[str, Any]</code></p>"},{"location":"CONFIGURATION_SYSTEM/#promptsjson","title":"prompts.json","text":"<p>Purpose: LLM prompt templates for parameter extraction, reranking, and translation</p> <p>Structure: <pre><code>{\n  \"parameter_extraction\": {\n    \"system\": \"You are an expert welding equipment specialist...\",\n    \"user\": \"Extract parameters from: {user_message}\\n\\nCurrent state: {current_state}...\"\n  },\n  \"llm_reranking\": {\n    \"system\": \"You are an expert welding equipment specialist. Rank products...\",\n    \"user\": \"Query: {user_message}\\n\\nProducts:\\n{products}\"\n  },\n  \"translation\": {\n    \"system\": \"You are a professional translator...\",\n    \"user\": \"Translate to {target_language}: {text}\"\n  }\n}\n</code></pre></p> <p>Used By: - ParameterExtractor (LLM prompt construction) - LLMSearchStrategy (reranking prompt) - MultilingualTranslator (translation prompt)</p> <p>Accessor: <code>get_prompt(prompt_key: str) -&gt; str</code></p>"},{"location":"CONFIGURATION_SYSTEM/#languagesjson","title":"languages.json","text":"<p>Purpose: Supported languages configuration</p> <p>Structure: <pre><code>{\n  \"supported_languages\": {\n    \"en\": \"English\",\n    \"es\": \"Espa\u00f1ol\",\n    \"fr\": \"Fran\u00e7ais\",\n    \"de\": \"Deutsch\",\n    \"pt\": \"Portugu\u00eas\",\n    \"it\": \"Italiano\",\n    \"sv\": \"Svenska\"\n  },\n  \"default_language\": \"en\"\n}\n</code></pre></p> <p>Used By: - MultilingualTranslator (language validation) - MessageGenerator (multilingual responses) - FastAPI endpoints (language parameter validation)</p> <p>Accessor: <code>get_supported_languages() -&gt; Dict[str, str]</code></p>"},{"location":"CONFIGURATION_SYSTEM/#api-reference","title":"API Reference","text":""},{"location":"CONFIGURATION_SYSTEM/#core-methods","title":"Core Methods","text":""},{"location":"CONFIGURATION_SYSTEM/#__init__config_dir-optionalstr-none","title":"<code>__init__(config_dir: Optional[str] = None)</code>","text":"<p>Initialize ConfigurationService with config directory.</p> <p>Parameters: - <code>config_dir</code> (Optional[str]): Path to config directory (defaults to <code>app/config/</code>)</p> <p>Example: <pre><code># Use default config directory\nconfig_service = ConfigurationService()\n\n# Use custom config directory\nconfig_service = ConfigurationService(config_dir=\"/path/to/configs\")\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#load_configconfig_name-str-dictstr-any","title":"<code>load_config(config_name: str) -&gt; Dict[str, Any]</code>","text":"<p>Load configuration from JSON file with LRU caching.</p> <p>Parameters: - <code>config_name</code> (str): Config file name without .json extension</p> <p>Returns: Parsed JSON dict</p> <p>Caching: Result cached with <code>@lru_cache(maxsize=32)</code></p> <p>Example: <pre><code>component_types = config_service.load_config(\"component_types\")\nstate_config = config_service.load_config(\"state_config\")\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#reload_configconfig_name-str-dictstr-any","title":"<code>reload_config(config_name: str) -&gt; Dict[str, Any]</code>","text":"<p>Force reload of configuration (clears cache and reloads from disk).</p> <p>Parameters: - <code>config_name</code> (str): Config file name without .json extension</p> <p>Returns: Freshly loaded JSON dict</p> <p>Use Cases: - Hot reload after config file changes - Development/testing with dynamic configs - Runtime configuration updates</p> <p>Example: <pre><code># Modify config file on disk\nwith open(\"app/config/search_config.json\", \"w\") as f:\n    json.dump(new_config, f)\n\n# Reload configuration\nconfig_service.reload_config(\"search_config\")\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#specialized-accessors-30-methods","title":"Specialized Accessors (30+ Methods)","text":""},{"location":"CONFIGURATION_SYSTEM/#component-configuration","title":"Component Configuration","text":""},{"location":"CONFIGURATION_SYSTEM/#get_component_types-dictstr-any","title":"<code>get_component_types() -&gt; Dict[str, Any]</code>","text":"<p>Get component types configuration including state sequence.</p> <p>Returns: Component types dict with metadata and state sequence</p> <p>Example: <pre><code>component_types = config_service.get_component_types()\nstate_sequence = component_types[\"state_sequence\"]  # List of all states\npower_source_config = component_types[\"component_types\"][\"PowerSource\"]\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#get_component_applicability-dictstr-any","title":"<code>get_component_applicability() -&gt; Dict[str, Any]</code>","text":"<p>Get component applicability configuration (Y/N rules per power source).</p> <p>Returns: Applicability dict with power source rules</p> <p>Example: <pre><code>applicability = config_service.get_component_applicability()\naristo_500ix_rules = applicability[\"power_sources\"][\"0446200880\"][\"applicability\"]\ndefault_rules = applicability[\"default_policy\"][\"applicability\"]\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#get_master_parameter_schema-dictstr-any","title":"<code>get_master_parameter_schema() -&gt; Dict[str, Any]</code>","text":"<p>Get master parameter schema for dynamic model creation.</p> <p>Returns: Schema dict defining all component parameters</p> <p>Example: <pre><code>schema = config_service.get_master_parameter_schema()\npower_source_fields = schema[\"power_source\"]  # Dict of field names and types\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#get_response_json_field_namecomponent_key-str-str","title":"<code>get_response_json_field_name(component_key: str) -&gt; str</code>","text":"<p>Get ResponseJSON field name for a component type.</p> <p>Parameters: - <code>component_key</code> (str): Component type key (e.g., \"PowerSource\", \"Feeder\")</p> <p>Returns: Field name in ResponseJSON (e.g., \"PowerSource\", \"FeederAccessories\")</p> <p>Example: <pre><code>field_name = config_service.get_response_json_field_name(\"PowerSource\")\n# Returns: \"PowerSource\"\n\nfield_name = config_service.get_response_json_field_name(\"FeederAccessories\")\n# Returns: \"FeederAccessories\"\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#get_master_parameters_field_namecomponent_key-str-str","title":"<code>get_master_parameters_field_name(component_key: str) -&gt; str</code>","text":"<p>Get MasterParameterJSON field name for a component type.</p> <p>Parameters: - <code>component_key</code> (str): Component type key</p> <p>Returns: Field name in MasterParameterJSON (snake_case)</p> <p>Example: <pre><code>field_name = config_service.get_master_parameters_field_name(\"PowerSource\")\n# Returns: \"power_source\"\n\nfield_name = config_service.get_master_parameters_field_name(\"FeederAccessories\")\n# Returns: \"feeder_accessories\"\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#get_neo4j_labelcomponent_key-str-str","title":"<code>get_neo4j_label(component_key: str) -&gt; str</code>","text":"<p>Get Neo4j node label for a component type.</p> <p>Parameters: - <code>component_key</code> (str): Component type key</p> <p>Returns: Neo4j node label (e.g., \"Product\", \"Accessory\")</p> <p>Example: <pre><code>label = config_service.get_neo4j_label(\"PowerSource\")\n# Returns: \"Product\"\n\nlabel = config_service.get_neo4j_label(\"FeederAccessories\")\n# Returns: \"Product\" (all components use Product label with category field)\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#check_dependencies_satisfiedcomponent_key-str-selected_components-any-tuplebool-liststr-dictstr-str","title":"<code>check_dependencies_satisfied(component_key: str, selected_components: Any) -&gt; Tuple[bool, List[str], Dict[str, str]]</code>","text":"<p>Check if dependencies for a component are satisfied.</p> <p>Parameters: - <code>component_key</code> (str): Component type key - <code>selected_components</code> (ResponseJSON): Selected components</p> <p>Returns: Tuple of (satisfied: bool, missing_deps: List[str], parent_info: Dict[str, str])</p> <p>Example: <pre><code>satisfied, missing, parents = config_service.check_dependencies_satisfied(\n    \"FeederConditionalAccessories\",\n    response_json\n)\n\nif not satisfied:\n    print(f\"Missing dependencies: {missing}\")\nelif len(parents) &gt; 0:\n    print(f\"Ready to show conditional accessories for {len(parents)} parents\")\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#state-configuration","title":"State Configuration","text":""},{"location":"CONFIGURATION_SYSTEM/#get_state_config-dictstr-any","title":"<code>get_state_config() -&gt; Dict[str, Any]</code>","text":"<p>Get state processor configuration for all 14 states.</p> <p>Returns: State config dict with processor settings</p> <p>Example: <pre><code>state_config = config_service.get_state_config()\npower_source_config = state_config[\"states\"][\"power_source_selection\"]\nmandatory = power_source_config[\"mandatory\"]  # True\nmulti_select = power_source_config[\"multi_select\"]  # False\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#search-configuration","title":"Search Configuration","text":""},{"location":"CONFIGURATION_SYSTEM/#get_search_config-dictstr-any","title":"<code>get_search_config() -&gt; Dict[str, Any]</code>","text":"<p>Get search configuration (strategies, weights, limits).</p> <p>Returns: Search config dict</p> <p>Example: <pre><code>search_config = config_service.get_search_config()\nstrategies = search_config[\"strategies\"]\ncypher_config = strategies[\"cypher\"]\nvector_config = strategies[\"vector\"]\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#llm-configuration","title":"LLM Configuration","text":""},{"location":"CONFIGURATION_SYSTEM/#get_llm_configpurpose-str-dictstr-any","title":"<code>get_llm_config(purpose: str) -&gt; Dict[str, Any]</code>","text":"<p>Get LLM configuration for specific purpose.</p> <p>Parameters: - <code>purpose</code> (str): Purpose key (e.g., \"parameter_extraction\", \"llm_search_reranking\")</p> <p>Returns: LLM config dict with model, temperature, max_tokens</p> <p>Example: <pre><code>extraction_config = config_service.get_llm_config(\"parameter_extraction\")\nmodel = extraction_config[\"model\"]  # \"gpt-4\"\ntemperature = extraction_config[\"temperature\"]  # 0.1\n\nreranking_config = config_service.get_llm_config(\"llm_search_reranking\")\nmodel = reranking_config[\"model\"]  # \"gpt-4o-mini\"\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#get_promptprompt_key-str-str","title":"<code>get_prompt(prompt_key: str) -&gt; str</code>","text":"<p>Get LLM prompt template by key.</p> <p>Parameters: - <code>prompt_key</code> (str): Prompt key (e.g., \"parameter_extraction\", \"llm_reranking\")</p> <p>Returns: Prompt template string</p> <p>Example: <pre><code>extraction_prompt = config_service.get_prompt(\"parameter_extraction\")\n# Returns: {\"system\": \"...\", \"user\": \"...\"}\n\nreranking_prompt = config_service.get_prompt(\"llm_reranking\")\n# Returns: {\"system\": \"...\", \"user\": \"...\"}\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#language-configuration","title":"Language Configuration","text":""},{"location":"CONFIGURATION_SYSTEM/#get_supported_languages-dictstr-str","title":"<code>get_supported_languages() -&gt; Dict[str, str]</code>","text":"<p>Get supported languages configuration.</p> <p>Returns: Dict of {language_code: language_name}</p> <p>Example: <pre><code>languages = config_service.get_supported_languages()\n# Returns: {\"en\": \"English\", \"es\": \"Espa\u00f1ol\", ...}\n\nif \"fr\" in languages:\n    print(f\"French supported: {languages['fr']}\")\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#get_default_language-str","title":"<code>get_default_language() -&gt; str</code>","text":"<p>Get default language code.</p> <p>Returns: ISO 639-1 language code (default: \"en\")</p> <p>Example: <pre><code>default_lang = config_service.get_default_language()\n# Returns: \"en\"\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#session-configuration","title":"Session Configuration","text":""},{"location":"CONFIGURATION_SYSTEM/#get_session_ttl-int","title":"<code>get_session_ttl() -&gt; int</code>","text":"<p>Get Redis session TTL in seconds.</p> <p>Returns: TTL in seconds (default: 3600)</p> <p>Example: <pre><code>ttl = config_service.get_session_ttl()\n# Returns: 3600 (1 hour)\n</code></pre></p>"},{"location":"CONFIGURATION_SYSTEM/#usage-examples","title":"Usage Examples","text":""},{"location":"CONFIGURATION_SYSTEM/#example-1-component-type-lookup","title":"Example 1: Component Type Lookup","text":"<pre><code>from app.services.config.configuration_service import get_config_service\n\n# Get singleton instance\nconfig_service = get_config_service()\n\n# Get component types configuration\ncomponent_types = config_service.get_component_types()\n\n# Extract state sequence\nstate_sequence = component_types[\"state_sequence\"]\nprint(f\"Total states: {len(state_sequence)}\")\n# Output: Total states: 14\n\n# Get PowerSource configuration\npower_source_config = component_types[\"component_types\"][\"PowerSource\"]\nprint(f\"State name: {power_source_config['state_name']}\")\nprint(f\"Neo4j label: {power_source_config['neo4j_label']}\")\n# Output:\n# State name: power_source_selection\n# Neo4j label: Product\n</code></pre>"},{"location":"CONFIGURATION_SYSTEM/#example-2-loading-component-applicability","title":"Example 2: Loading Component Applicability","text":"<pre><code># After S1 (PowerSource selection)\nselected_ps_gin = \"0446200880\"  # Aristo 500ix\n\n# Load applicability\napplicability_config = config_service.get_component_applicability()\npower_sources = applicability_config.get(\"power_sources\", {})\n\nps_config = power_sources.get(selected_ps_gin)\nif ps_config:\n    applicability = ps_config.get(\"applicability\", {})\n    print(f\"Feeder applicable: {applicability.get('Feeder')}\")\n    print(f\"Cooler applicable: {applicability.get('Cooler')}\")\nelse:\n    # Use default policy\n    default_policy = applicability_config.get(\"default_policy\", {})\n    applicability = default_policy.get(\"applicability\", {})\n    print(\"Using default applicability policy\")\n</code></pre>"},{"location":"CONFIGURATION_SYSTEM/#example-3-state-processor-configuration","title":"Example 3: State Processor Configuration","text":"<pre><code># Get state configuration for processor initialization\nstate_config_dict = config_service.get_state_config()\n\n# Extract configuration for specific state\npower_source_config = state_config_dict[\"states\"][\"power_source_selection\"]\n\n# Use configuration\nmandatory = power_source_config.get(\"mandatory\", False)\nproactive = power_source_config.get(\"proactive_display\", False)\nsearch_limit = power_source_config.get(\"search_limit\", 10)\nmulti_select = power_source_config.get(\"multi_select\", False)\n\nprint(f\"Mandatory: {mandatory}\")\nprint(f\"Proactive display: {proactive}\")\nprint(f\"Search limit: {search_limit}\")\nprint(f\"Multi-select: {multi_select}\")\n# Output:\n# Mandatory: True\n# Proactive display: True\n# Search limit: 10\n# Multi-select: False\n</code></pre>"},{"location":"CONFIGURATION_SYSTEM/#example-4-search-strategy-configuration","title":"Example 4: Search Strategy Configuration","text":"<pre><code># Get search configuration for SearchOrchestrator\nsearch_config = config_service.get_search_config()\n\n# Check which strategies are enabled\nstrategies = search_config[\"strategies\"]\n\nfor strategy_name, strategy_config in strategies.items():\n    enabled = strategy_config.get(\"enabled\", False)\n    if enabled:\n        weight = strategy_config.get(\"weight\", 0.0)\n        print(f\"{strategy_name}: enabled (weight={weight})\")\n\n# Output:\n# cypher: enabled (weight=0.4)\n# lucene: enabled (weight=0.3)\n# vector: enabled (weight=0.2)\n# llm: enabled (weight=0.1)\n</code></pre>"},{"location":"CONFIGURATION_SYSTEM/#example-5-llm-configuration-for-parameter-extraction","title":"Example 5: LLM Configuration for Parameter Extraction","text":"<pre><code># Get LLM configuration for parameter extraction\nextraction_config = config_service.get_llm_config(\"parameter_extraction\")\n\n# Extract settings\nmodel = extraction_config.get(\"model\", \"gpt-4\")\ntemperature = extraction_config.get(\"temperature\", 0.1)\nmax_tokens = extraction_config.get(\"max_tokens\", 2000)\n\nprint(f\"Model: {model}\")\nprint(f\"Temperature: {temperature}\")\nprint(f\"Max tokens: {max_tokens}\")\n# Output:\n# Model: gpt-4\n# Temperature: 0.1\n# Max tokens: 2000\n\n# Get prompt template\nprompt = config_service.get_prompt(\"parameter_extraction\")\nsystem_prompt = prompt[\"system\"]\nuser_prompt_template = prompt[\"user\"]\n\n# Use in OpenAI API call\nfrom openai import AsyncOpenAI\nclient = AsyncOpenAI()\n\nresponse = await client.chat.completions.create(\n    model=model,\n    temperature=temperature,\n    max_tokens=max_tokens,\n    messages=[\n        {\"role\": \"system\", \"content\": system_prompt},\n        {\"role\": \"user\", \"content\": user_prompt_template.format(\n            user_message=\"I need a 500A MIG welder\",\n            current_state=\"power_source_selection\"\n        )}\n    ]\n)\n</code></pre>"},{"location":"CONFIGURATION_SYSTEM/#example-6-field-name-mapping","title":"Example 6: Field Name Mapping","text":"<pre><code># Map component type to ResponseJSON field name\ncomponent_key = \"FeederAccessories\"\nfield_name = config_service.get_response_json_field_name(component_key)\nprint(f\"ResponseJSON field: {field_name}\")\n# Output: ResponseJSON field: FeederAccessories\n\n# Map component type to MasterParameterJSON field name\nmaster_field_name = config_service.get_master_parameters_field_name(component_key)\nprint(f\"MasterParameterJSON field: {master_field_name}\")\n# Output: MasterParameterJSON field: feeder_accessories\n\n# Map component type to Neo4j label\nneo4j_label = config_service.get_neo4j_label(component_key)\nprint(f\"Neo4j label: {neo4j_label}\")\n# Output: Neo4j label: Product\n</code></pre>"},{"location":"CONFIGURATION_SYSTEM/#performance-optimization","title":"Performance Optimization","text":""},{"location":"CONFIGURATION_SYSTEM/#lru-cache-performance","title":"LRU Cache Performance","text":"<p>Cache Hit Scenario (most common): - Lookup Time: O(1) - dict lookup in memory - Response Time: &lt; 1ms - Disk I/O: None - CPU Usage: Minimal</p> <p>Cache Miss Scenario (first access): - File I/O: Read JSON file from disk (~5-10ms) - Parsing: JSON deserialization (~1-5ms) - Total Time: ~10-15ms - Cache Storage: O(1) dict insertion</p> <p>Cache Size: - Max Entries: 32 - Actual Usage: ~10-15 config files - Memory Per Entry: ~1-10 KB (varies by config size) - Total Memory: ~50-150 KB (negligible)</p>"},{"location":"CONFIGURATION_SYSTEM/#cache-efficiency-metrics","title":"Cache Efficiency Metrics","text":"<p>Hit Rate: 99%+ after initial warmup</p> <p>Warmup Time: First request to each config (~10-15ms)</p> <p>Steady State: All requests &lt; 1ms</p> <p>Memory Overhead: &lt; 200 KB total</p>"},{"location":"CONFIGURATION_SYSTEM/#performance-comparison","title":"Performance Comparison","text":"Operation Without Cache With Cache Improvement First load ~10-15ms ~10-15ms - Second load ~10-15ms &lt; 1ms 10-15x faster 100 loads ~1000-1500ms &lt; 100ms 10-15x faster Memory 0 KB ~150 KB Minimal overhead"},{"location":"CONFIGURATION_SYSTEM/#hot-reload","title":"Hot Reload","text":""},{"location":"CONFIGURATION_SYSTEM/#use-cases","title":"Use Cases","text":"<ol> <li>Development: Rapid iteration on config files without server restart</li> <li>Testing: Dynamic config changes in test scenarios</li> <li>Production: Runtime config updates for emergency fixes</li> </ol>"},{"location":"CONFIGURATION_SYSTEM/#hot-reload-process","title":"Hot Reload Process","text":"<pre><code># Step 1: Modify config file\nimport json\nfrom pathlib import Path\n\nconfig_path = Path(\"app/config/search_config.json\")\nconfig = json.loads(config_path.read_text())\nconfig[\"strategies\"][\"vector\"][\"enabled\"] = False  # Disable vector search\nconfig_path.write_text(json.dumps(config, indent=2))\n\n# Step 2: Reload configuration\nfrom app.services.config.configuration_service import get_config_service\n\nconfig_service = get_config_service()\nconfig_service.reload_config(\"search_config\")\n\n# Step 3: Verify changes\nsearch_config = config_service.get_search_config()\nprint(f\"Vector enabled: {search_config['strategies']['vector']['enabled']}\")\n# Output: Vector enabled: False\n</code></pre>"},{"location":"CONFIGURATION_SYSTEM/#cache-clearing","title":"Cache Clearing","text":"<p>The <code>reload_config()</code> method clears the LRU cache before reloading:</p> <pre><code>def reload_config(self, config_name: str) -&gt; Dict[str, Any]:\n    \"\"\"Force reload of configuration (clears cache)\"\"\"\n    self.load_config.cache_clear()  # Clear entire LRU cache\n    return self.load_config(config_name)\n</code></pre> <p>Note: <code>cache_clear()</code> clears all cached configs, not just the one being reloaded. This ensures consistency if configs reference each other.</p>"},{"location":"CONFIGURATION_SYSTEM/#production-considerations","title":"Production Considerations","text":"<p>Caution: Hot reload in production can cause temporary inconsistencies if: - Multiple workers are running (each has separate cache) - Configs are reloaded during active requests - Related configs are not reloaded together</p> <p>Best Practice: Use hot reload for emergency fixes only. Prefer full deployment for config changes.</p>"},{"location":"CONFIGURATION_SYSTEM/#related-documentation","title":"Related Documentation","text":"<ul> <li>State Processor Architecture - How processors use configuration</li> <li>Search Strategies - Search configuration usage</li> <li>Master Parameter JSON Architecture - Schema loading</li> <li>State Flow Architecture - State sequence configuration</li> </ul>"},{"location":"CONFIGURATION_SYSTEM/#file-location","title":"File Location","text":"<p>Source: <code>src/backend/app/services/config/configuration_service.py</code></p> <p>Related Files: - <code>app/config/*.json</code> - All configuration files - <code>app/services/processors/registry.py</code> - Uses state_config.json - <code>app/services/search/orchestrator.py</code> - Uses search_config.json - <code>app/models/conversation.py</code> - Uses master_parameter_schema.json</p>"},{"location":"CONFIG_CONSOLIDATION/","title":"Configuration Consolidation - November 2024","text":""},{"location":"CONFIG_CONSOLIDATION/#summary","title":"Summary","text":"<p>Consolidated <code>component_config.json</code> from its unusual location (<code>app/services/search/components/</code>) to the main configuration directory (<code>app/config/</code>) for better organization and consistency.</p>"},{"location":"CONFIG_CONSOLIDATION/#problem","title":"Problem","text":"<p>The configuration file structure was confusing with multiple config directories: - <code>/app/config/</code> - Main configuration directory (13 JSON files) - <code>/app/services/config/</code> - Service utilities (config_validator.py, prompt_service.py, etc.) - <code>/app/services/search/components/</code> - Contained component_config.json (unusual location)</p>"},{"location":"CONFIG_CONSOLIDATION/#solution","title":"Solution","text":"<p>Step 1: Created centralized loader function - Added <code>load_component_config()</code> to <code>app/config/schema_loader.py</code> - Follows same pattern as <code>load_master_parameter_schema()</code> - Provides caching via <code>@lru_cache</code> - Centralized error handling and logging</p> <p>Step 2: Updated component_service.py - Replaced direct file loading with <code>load_component_config()</code> import - Changed from: <code>Path(__file__).parent / \"component_config.json\"</code> - Changed to: <code>from app.config.schema_loader import load_component_config</code> - Updated documentation to reflect centralized config loading</p> <p>Step 3: Moved configuration file - Copied <code>component_config.json</code> to <code>/app/config/</code> - Removed old file from <code>/app/services/search/components/</code> - Updated documentation in <code>archived/README.md</code></p>"},{"location":"CONFIG_CONSOLIDATION/#configuration-directory-structure-after-consolidation","title":"Configuration Directory Structure (After Consolidation)","text":"<pre><code>app/config/                                    # Main configuration directory\n\u251c\u2500\u2500 component_config.json                     # \u2705 NOW HERE (moved from services/search/components/)\n\u251c\u2500\u2500 master_parameter_schema.json\n\u251c\u2500\u2500 component_types.json\n\u251c\u2500\u2500 component_applicability.json\n\u251c\u2500\u2500 parameter_normalizations.json\n\u251c\u2500\u2500 category_features_llm.json\n\u251c\u2500\u2500 product_names.json\n\u251c\u2500\u2500 search_config.json\n\u251c\u2500\u2500 state_config.json\n\u251c\u2500\u2500 state_prompts.json\n\u251c\u2500\u2500 llm_config.json\n\u251c\u2500\u2500 llm_prompts.json\n\u251c\u2500\u2500 languages.json\n\u251c\u2500\u2500 schema_loader.py                          # \u2705 NOW LOADS component_config.json\n\u2514\u2500\u2500 archived/                                 # Unused files\n\napp/services/config/                          # Service utilities (appropriate location)\n\u251c\u2500\u2500 config_monitor.py\n\u251c\u2500\u2500 config_validator.py\n\u251c\u2500\u2500 configuration_service.py\n\u2514\u2500\u2500 prompt_service.py\n\napp/services/search/components/               # Search service components only\n\u251c\u2500\u2500 component_service.py                      # \u2705 NOW USES load_component_config()\n\u251c\u2500\u2500 query_builder.py\n\u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"CONFIG_CONSOLIDATION/#files-modified","title":"Files Modified","text":""},{"location":"CONFIG_CONSOLIDATION/#1-appconfigschema_loaderpy","title":"1. <code>/app/config/schema_loader.py</code>","text":"<p>Change: Added <code>load_component_config()</code> function - Loads and caches component_config.json from main config directory - Returns dict with all 13 component type configurations - Provides error handling for missing/invalid files - Uses same pattern as existing <code>load_master_parameter_schema()</code></p> <p>Code Added (lines 15-51): <pre><code>@lru_cache(maxsize=1)\ndef load_component_config() -&gt; Dict[str, Any]:\n    \"\"\"\n    Load and cache component search configuration from config\n\n    Returns:\n        Dict containing component search configuration with all 13 component types\n        Each component has: category, neo4j_label, requires_compatibility,\n        dependencies, master_param_key, lucene_enabled, fuzzy_matching_enabled\n    \"\"\"\n    try:\n        config_path = os.path.join(\n            os.path.dirname(__file__),\n            \"component_config.json\"\n        )\n\n        with open(config_path, \"r\") as f:\n            config = json.load(f)\n\n        logger.info(f\"Loaded component config with {len(config)} component types\")\n        logger.info(f\"Component types: {list(config.keys())}\")\n\n        return config\n\n    except FileNotFoundError:\n        logger.error(f\"Component config file not found at {config_path}\")\n        raise\n    except json.JSONDecodeError as e:\n        logger.error(f\"Invalid JSON in component config file: {e}\")\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to load component config: {e}\")\n        raise\n</code></pre></p>"},{"location":"CONFIG_CONSOLIDATION/#2-appservicessearchcomponentscomponent_servicepy","title":"2. <code>/app/services/search/components/component_service.py</code>","text":"<p>Change: Updated to use centralized config loader instead of direct file loading</p> <p>Before: <pre><code>import json\nfrom pathlib import Path\n\n# Load component configuration\nconfig_path = Path(__file__).parent / \"component_config.json\"\nwith open(config_path, \"r\") as f:\n    self.component_config = json.load(f)\n</code></pre></p> <p>After: <pre><code>from app.config.schema_loader import load_component_config\n\n# Load component configuration from centralized config directory\nself.component_config = load_component_config()\n</code></pre></p>"},{"location":"CONFIG_CONSOLIDATION/#3-appconfigarchivedreadmemd","title":"3. <code>/app/config/archived/README.md</code>","text":"<p>Change: Updated documentation to reflect new location and usage</p> <p>Before: <pre><code>- `component_config.json` - Component search configuration for Phase 1 refactoring (query_builder.py, component_service.py, lucene_strategy.py)\n</code></pre></p> <p>After: <pre><code>- `component_config.json` - Component search configuration for all 13 component types (schema_loader.py, component_service.py, query_builder.py, strategies)\n</code></pre></p>"},{"location":"CONFIG_CONSOLIDATION/#benefits","title":"Benefits","text":"<ol> <li>Consistency: All configuration JSON files now in one place (<code>app/config/</code>)</li> <li>Discoverability: Easier to find and understand configuration structure</li> <li>Maintainability: Centralized loading logic in <code>schema_loader.py</code></li> <li>Caching: Config file loaded once and cached via <code>@lru_cache</code></li> <li>Error Handling: Standardized error handling for all config files</li> <li>Documentation: Clear separation between config files and service utilities</li> </ol>"},{"location":"CONFIG_CONSOLIDATION/#testing","title":"Testing","text":"<p>To verify the consolidation works correctly:</p> <pre><code># 1. Check the file exists in new location\nls -lh /app/config/component_config.json\n\n# 2. Check old location is removed\nls /app/services/search/components/component_config.json\n# Should return: No such file or directory\n\n# 3. Start the server and verify no errors\ncd src/backend\nuvicorn app.main:app --reload\n\n# 4. Check logs for successful loading\n# Should see: \"Loaded component config with 13 component types\"\n</code></pre>"},{"location":"CONFIG_CONSOLIDATION/#related-files","title":"Related Files","text":"<ul> <li><code>component_config.json</code> - Configuration for 13 component types (power_source, feeder, cooler, etc.)</li> <li><code>query_builder.py</code> - Uses component config via ComponentSearchService</li> <li><code>component_service.py</code> - Generic search service using component config</li> <li><code>lucene_strategy.py</code> - Lucene search strategy using ComponentSearchService</li> <li><code>cypher_strategy.py</code> - Cypher search strategy using ComponentSearchService</li> </ul>"},{"location":"CONFIG_CONSOLIDATION/#users-updates","title":"User's Updates","text":"<p>Note: User has already updated <code>component_config.json</code> to add cooler dependency for torches:</p> <pre><code>\"torch\": {\n  \"category\": \"Torches\",\n  \"neo4j_label\": \"Torch\",\n  \"requires_compatibility\": true,\n  \"dependencies\": [\"feeder\", \"cooler\"],  // \u2190 User added \"cooler\"\n  \"master_param_key\": \"torch\",\n  \"lucene_enabled\": true,\n  \"fuzzy_matching_enabled\": false,\n  \"description\": \"Welding torch selection (requires compatible feeder) and cooler\"\n}\n</code></pre> <p>This update is now preserved in the consolidated location.</p>"},{"location":"CONFIG_CONSOLIDATION_STATUS/","title":"Configuration Consolidation Status","text":"<p>Date: November 15, 2024 Status: In Progress - Phase 1 Complete</p>"},{"location":"CONFIG_CONSOLIDATION_STATUS/#whats-been-done","title":"What's Been Done","text":""},{"location":"CONFIG_CONSOLIDATION_STATUS/#phase-1-file-merge-complete","title":"\u2705 Phase 1: File Merge Complete","text":"<ol> <li>Merged component_config.json INTO component_types.json</li> <li> <p>Added 5 new fields to each component:</p> <ul> <li><code>category</code> (Powersource, Feeder, etc.)</li> <li><code>dependencies</code> (array of component keys)</li> <li><code>master_param_key</code> (MasterParameterJSON key)</li> <li><code>lucene_enabled</code> (boolean)</li> <li><code>fuzzy_matching_enabled</code> (boolean)</li> </ul> </li> <li> <p>Fixed <code>neo4j_label</code> to use correct values from component_config</p> <ul> <li>PowersourceAccessory (not \"Accessory\")</li> <li>FeederAccessory (not \"Accessory\")</li> <li>etc.</li> </ul> </li> <li> <p>Created 4 New Schema Files (for validation expansion)</p> </li> <li>component_config.schema.json</li> <li>state_config.schema.json</li> <li>search_config.schema.json</li> <li> <p>master_parameter_schema.schema.json</p> </li> <li> <p>Updated ConfigValidator to validate 7 configs instead of 3</p> </li> <li>Original: component_types, state_prompts, component_applicability</li> <li>Added: component_config, state_config, search_config, master_parameter_schema</li> </ol>"},{"location":"CONFIG_CONSOLIDATION_STATUS/#what-remains-todo","title":"What Remains (TODO)","text":""},{"location":"CONFIG_CONSOLIDATION_STATUS/#phase-2-code-migration","title":"Phase 2: Code Migration","text":"<p>6 Files to Update:</p> <ol> <li> <p>app/config/schema_loader.py <pre><code># Change load_component_config() to:\ndef load_component_config() -&gt; Dict[str, Any]:\n    \"\"\"Load component configuration (now from component_types)\"\"\"\n    return load_config(\"component_types\")[\"component_types\"]\n</code></pre></p> </li> <li> <p>app/services/search/components/component_service.py <pre><code># Line ~50: Change config loading\n# FROM: config = load_component_config()\n# TO:   config = schema_loader.load_config(\"component_types\")[\"component_types\"]\n</code></pre></p> </li> <li> <p>app/services/search/strategies/cypher_strategy.py <pre><code># Update component config loading to use component_types\n</code></pre></p> </li> <li> <p>app/services/search/strategies/lucene_strategy.py <pre><code># Update component config loading to use component_types\n</code></pre></p> </li> <li> <p>app/services/search/components/query_builder.py <pre><code># Update component config loading to use component_types\n</code></pre></p> </li> <li> <p>app/services/config/config_validator.py <pre><code># Line 367: REMOVE this line:\nresults.append(self.validate_config_schema(\"component_config\"))\n</code></pre></p> </li> </ol>"},{"location":"CONFIG_CONSOLIDATION_STATUS/#phase-3-cleanup","title":"Phase 3: Cleanup","text":"<ol> <li> <p>Archive Old Files <pre><code>mkdir -p /archived/config_refactoring/\nmv app/config/component_config.json /archived/config_refactoring/\n</code></pre></p> </li> <li> <p>Delete Obsolete Files <pre><code>rm app/config/component_config.schema.json\nrm app/config/component_types_merged.json  # temp file\n</code></pre></p> </li> <li> <p>Update component_types Schema</p> </li> <li>Add new required fields to component_types.schema.json:<ul> <li>category, dependencies, master_param_key, lucene_enabled, fuzzy_matching_enabled</li> </ul> </li> </ol>"},{"location":"CONFIG_CONSOLIDATION_STATUS/#phase-4-testing","title":"Phase 4: Testing","text":"<pre><code># 1. Validate configs\ncd src/backend\npython -c \"from app.services.config.config_validator import validate_configs_on_startup; print(validate_configs_on_startup())\"\n\n# 2. Test server startup\nuvicorn app.main:app --reload\n\n# 3. Test component search\ncurl -X POST http://localhost:8000/api/v1/configurator/message \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"message\": \"I need a 500A MIG welder\", \"language\": \"en\"}'\n</code></pre>"},{"location":"CONFIG_CONSOLIDATION_STATUS/#duplication-analysis-results","title":"Duplication Analysis Results","text":""},{"location":"CONFIG_CONSOLIDATION_STATUS/#critical-findings","title":"Critical Findings","text":"<p>3X Duplication - neo4j_label: - component_config.json \u2713 (correct values) - component_types.json \u2713 (was wrong for accessories, now fixed) - search_config.json (in lucene.components)</p> <p>2X Duplication - lucene_enabled: - component_config.json - search_config.json (as lucene.components.{comp}.enabled)</p> <p>2X Duplication - category: - component_config.json (as \"category\": \"Powersource\") - search_config.json (as \"neo4j_category\": \"Powersource\")</p> <p>2X Duplication - requires_compatibility: - component_config.json (as requires_compatibility) - component_types.json (as requires_compatibility_check)</p>"},{"location":"CONFIG_CONSOLIDATION_STATUS/#resolution-strategy","title":"Resolution Strategy","text":"<p>Single Source of Truth: component_types.json</p> <p>All component metadata now lives in one place. Other files reference it.</p>"},{"location":"CONFIG_CONSOLIDATION_STATUS/#optional-phase-5-search_configjson-rationalization","title":"Optional: Phase 5 - search_config.json Rationalization","text":"<p>Problem: search_config.json still duplicates 3 fields per component</p> <p>Current: <pre><code>\"lucene_search\": {\n  \"components\": {\n    \"power_source\": {\n      \"enabled\": true,                    // \u2190 Get from component_types.lucene_enabled\n      \"neo4j_label\": \"Powersource\",       // \u2190 Get from component_types.neo4j_label\n      \"neo4j_category\": \"Powersource\",    // \u2190 Get from component_types.category\n      \"min_score\": 0.5,                   // \u2190 KEEP (Lucene-specific)\n      \"score_threshold_percent\": 20       // \u2190 KEEP (Lucene-specific)\n    }\n  }\n}\n</code></pre></p> <p>Proposed: <pre><code>\"lucene_search\": {\n  \"components\": {\n    \"power_source\": {\n      \"min_score\": 0.5,\n      \"score_threshold_percent\": 20\n    }\n  }\n}\n</code></pre></p> <p>Requires: - Update LuceneStrategy to load component_types and merge settings - 10-15 minutes additional work</p>"},{"location":"CONFIG_CONSOLIDATION_STATUS/#benefits-achieved","title":"Benefits Achieved","text":"<ol> <li>Single Source of Truth - component_types.json is master</li> <li>No Duplication - neo4j_label, category, dependencies in one place</li> <li>Easier Maintenance - Change component settings in ONE file</li> <li>Consistent Data - No risk of configs drifting out of sync</li> <li>Validated - 7 config files now have schema validation (was 3)</li> </ol>"},{"location":"CONFIG_CONSOLIDATION_STATUS/#files-modified","title":"Files Modified","text":"<p>Config Files: - \u2705 app/config/component_types.json (merged and ready)</p> <p>Schema Files Created: - \u2705 app/config/schemas/component_config.schema.json - \u2705 app/config/schemas/state_config.schema.json - \u2705 app/config/schemas/search_config.schema.json - \u2705 app/config/schemas/master_parameter_schema.schema.json</p> <p>Code Files Updated: - \u2705 app/services/config/config_validator.py (added 4 new validations)</p> <p>Code Files Remaining (6): - \u274c app/config/schema_loader.py - \u274c app/services/search/components/component_service.py - \u274c app/services/search/strategies/cypher_strategy.py - \u274c app/services/search/strategies/lucene_strategy.py - \u274c app/services/search/components/query_builder.py - \u274c app/services/config/config_validator.py (remove component_config validation)</p>"},{"location":"CONFIG_CONSOLIDATION_STATUS/#next-steps","title":"Next Steps","text":"<ol> <li>Complete Phase 2: Update 6 code files</li> <li>Complete Phase 3: Archive and cleanup</li> <li>Complete Phase 4: Test thoroughly</li> <li>(Optional) Phase 5: Rationalize search_config.json</li> </ol> <p>Estimated Time Remaining: 20-30 minutes</p>"},{"location":"CONFIG_CONSOLIDATION_STATUS/#contact","title":"Contact","text":"<p>For questions about this consolidation: - See: docs/CORRECTED_STATE_FLOW_ARCHITECTURE.md - See: docs/PRODUCT_SEARCH_SERVICE.md</p>"},{"location":"CONTEXT_BASED_STRATEGIES/","title":"Context-Based Search Strategies","text":""},{"location":"CONTEXT_BASED_STRATEGIES/#executive-summary","title":"Executive Summary","text":"<p>Purpose: Dynamic search strategy selection based on user interaction context to optimize performance and relevance.</p> <p>Two Operating Modes: 1. Proactive Display (50-200ms) - Fast compatibility checking when entering new states 2. User Intent (200-800ms) - Comprehensive semantic matching for explicit search requirements</p> <p>Key Benefit: 60-75% faster response time for navigation commands while maintaining high relevance for actual searches.</p> <p>Critical Clarification: ALL strategies validate COMPATIBLE_WITH relationships - the difference is HOW they validate (query-level vs post-processing).</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#configuration-overview","title":"Configuration Overview","text":""},{"location":"CONTEXT_BASED_STRATEGIES/#configuration-location","title":"Configuration Location","text":"<p>File: <code>src/backend/app/config/search_config.json</code> Lines: 137-146</p> <pre><code>{\n  \"context_based_strategies\": {\n    \"description\": \"Strategy selection based on search context (proactive vs user intent)\",\n    \"proactive_display\": {\n      \"enabled_strategies\": [\"cypher\"],\n      \"description\": \"Proactive display uses only Cypher for fast compatibility checking when entering a new state\"\n    },\n    \"user_intent\": {\n      \"enabled_strategies\": [\"cypher\", \"lucene\", \"vector\", \"llm\"],\n      \"description\": \"User intent uses all strategies for comprehensive semantic matching when user provides search requirements.\"\n    }\n  }\n}\n</code></pre>"},{"location":"CONTEXT_BASED_STRATEGIES/#what-gets-configured","title":"What Gets Configured","text":"Setting Values Purpose <code>proactive_display.enabled_strategies</code> <code>[\"cypher\"]</code> Fast compatibility-only search <code>user_intent.enabled_strategies</code> <code>[\"cypher\", \"lucene\", \"vector\", \"llm\"]</code> Full semantic search pipeline"},{"location":"CONTEXT_BASED_STRATEGIES/#compatibility-validation-architecture","title":"Compatibility Validation Architecture","text":""},{"location":"CONTEXT_BASED_STRATEGIES/#critical-understanding-all-strategies-validate-compatibility","title":"\u2b50 Critical Understanding: All Strategies Validate Compatibility","text":"<p>Common Misconception: \"Only Cypher strategy validates COMPATIBLE_WITH relationships\"</p> <p>Actual Implementation: ALL search strategies validate compatibility, but at different architectural layers.</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#compatibility-validation-comparison-table","title":"Compatibility Validation Comparison Table","text":"Strategy Validates Compatibility? Validation Layer Implementation File Location Cypher \u2705 YES Query construction <code>Neo4jQueryBuilder.add_compatibility_filters()</code> adds MATCH clauses for COMPATIBLE_WITH relationships <code>query_builder.py:98-301</code> Lucene \u2705 YES Query construction Same <code>Neo4jQueryBuilder.add_compatibility_filters()</code> method (shared centralized logic) <code>component_service.py:270-276</code> Vector \u2705 YES Post-processing Returns semantic matches, then validates via <code>validate_compatibility()</code> delegation <code>vector_strategy.py:207-232</code> LLM \u2705 YES Inherited from retrieval Retrieves from Lucene/Vector (already validated), then re-ranks <code>llm_strategy.py:224-244</code>"},{"location":"CONTEXT_BASED_STRATEGIES/#validation-implementation-details","title":"Validation Implementation Details","text":""},{"location":"CONTEXT_BASED_STRATEGIES/#1-cypher-strategy-query-level-validation","title":"1. Cypher Strategy - Query-Level Validation","text":"<p>Compatibility Check: <pre><code># File: query_builder.py, Lines 98-301\ndef add_compatibility_filters(\n    self,\n    query: str,\n    params: Dict[str, Any],\n    component_type: str,\n    selected_components: Dict[str, Any],\n    node_alias: str = \"target\"\n) -&gt; Tuple[str, Dict[str, Any], Optional[str]]:\n    \"\"\"\n    Add COMPATIBLE_WITH relationship filters for dependent components.\n\n    Example: For feeder search with selected power_source:\n    Adds: MATCH (ps:PowerSource {gin: $ps_gin})\n          MATCH (target)-[:COMPATIBLE_WITH]-&gt;(ps)\n    \"\"\"\n</code></pre></p> <p>Resulting Cypher Query: <pre><code>MATCH (target:Feeder)\nMATCH (ps_dep:PowerSource {gin: $power_source_gin})\nMATCH (target)-[r1:COMPATIBLE_WITH]-&gt;(ps_dep)\nWHERE target.category = $category\nRETURN target\nORDER BY target.priority\n</code></pre></p> <p>How It Works: - Neo4j graph database enforces compatibility at query execution time - Only products with COMPATIBLE_WITH edges to selected components are returned - Fastest method because filtering happens in database</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#2-lucene-strategy-query-level-validation-same-as-cypher","title":"2. Lucene Strategy - Query-Level Validation (Same as Cypher)","text":"<p>Compatibility Check: <pre><code># File: component_service.py, Lines 270-276\nif config.get(\"requires_compatibility\"):\n    query, params, _ = self.query_builder.add_compatibility_filters(\n        query, params, component_type, selected_components, \"p\"\n    )\n</code></pre></p> <p>Resulting Cypher Query with Lucene: <pre><code>CALL db.index.fulltext.queryNodes('productIndex', $search_text)\nYIELD node AS p, score\nWITH *\nWHERE p:Feeder AND p.category = $category\nMATCH (ps_dep:PowerSource {gin: $power_source_gin})\nMATCH (p)-[r1:COMPATIBLE_WITH]-&gt;(ps_dep)\nORDER BY score DESC\n</code></pre></p> <p>How It Works: - Lucene fulltext search finds textually relevant products - Same <code>add_compatibility_filters()</code> method adds COMPATIBLE_WITH relationships - Neo4j filters Lucene results to only compatible products - Returns products ranked by Lucene relevance + compatibility</p> <p>Key Difference from Cypher: Lucene starts with text relevance, then filters by compatibility. Cypher starts with compatibility graph traversal.</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#3-vector-strategy-post-processing-validation","title":"3. Vector Strategy - Post-Processing Validation","text":"<p>Why Different: Vector index queries can't include relationship traversal in the same Cypher structure.</p> <p>Search Query (No compatibility in query): <pre><code># File: vector_strategy.py, Lines 116-129\nCALL db.index.vector.queryNodes('embeddingIndex', $limit, $vector)\nYIELD node, score\nMATCH (p:Product)-[:HAS_EMBEDDING]-&gt;(node)\nWHERE p.category = $category AND score &gt;= $min_score\nRETURN p, score\nORDER BY score DESC\n</code></pre></p> <p>Compatibility Validation (Post-query): <pre><code># File: vector_strategy.py, Lines 207-232\nasync def validate_compatibility(\n    self,\n    product_gin: str,\n    selected_components: Dict[str, Any],\n    component_type: str\n) -&gt; bool:\n    \"\"\"\n    Validate product compatibility using Neo4j graph relationships.\n\n    Delegates to the Neo4j product search service for compatibility validation.\n    \"\"\"\n    return await self.neo4j_search.validate_compatibility(\n        product_gin=product_gin,\n        selected_components=selected_components,\n        component_type=component_type\n    )\n</code></pre></p> <p>How It Works: 1. Vector search finds semantically similar products (all matches above similarity threshold) 2. Compatibility validation happens externally via <code>validate_compatibility()</code> method 3. Consolidation layer can filter results by compatibility before returning to user</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#4-llm-strategy-inherited-validation-from-retrieval-strategies","title":"4. LLM Strategy - Inherited Validation from Retrieval Strategies","text":"<p>Retrieval from Validated Sources: <pre><code># File: llm_strategy.py, Lines 112-159\nif self.retrieval_method == \"lucene\":\n    # Lucene results are ALREADY compatibility-filtered\n    lucene_result = await self.lucene_strategy.search(\n        component_type=component_type,\n        selected_components=selected_components,  # \u2190 Compatibility enforced here\n        ...\n    )\n    all_candidates = lucene_result.products\n\nelif self.retrieval_method == \"vector\":\n    # Vector results include all semantic matches (unfiltered)\n    vector_result = await self.vector_strategy.search(\n        component_type=component_type,\n        selected_components=selected_components,  # \u2190 Passed through\n        ...\n    )\n    all_candidates = vector_result.products\n</code></pre></p> <p>Validation Delegation: <pre><code># File: llm_strategy.py, Lines 224-244\nasync def validate_compatibility(\n    self,\n    product_gin: str,\n    selected_components: Dict[str, Any],\n    component_type: str\n) -&gt; bool:\n    \"\"\"Delegates to Lucene strategy for compatibility validation.\"\"\"\n    return await self.lucene_strategy.validate_compatibility(\n        product_gin, selected_components, component_type\n    )\n</code></pre></p> <p>How It Works: 1. LLM retrieves candidates from Lucene (pre-filtered) and/or Vector (unfiltered) 2. LLM re-ranks combined set by semantic relevance 3. Compatibility validation available via delegation for any additional filtering</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#configuration-driven-compatibility","title":"Configuration-Driven Compatibility","text":"<p>File: <code>component_types.json</code></p> <p>All strategies check <code>requires_compatibility</code> flag:</p> <pre><code>{\n  \"power_source\": {\n    \"requires_compatibility\": false,  // First component, no dependencies\n    \"dependencies\": []\n  },\n  \"feeder\": {\n    \"requires_compatibility\": true,   // Depends on PowerSource\n    \"dependencies\": [\"power_source\"]\n  },\n  \"cooler\": {\n    \"requires_compatibility\": true,   // Depends on PowerSource\n    \"dependencies\": [\"power_source\"]\n  },\n  \"interconnector\": {\n    \"requires_compatibility\": true,   // Depends on PowerSource, Feeder, Cooler\n    \"dependencies\": [\"power_source\", \"feeder\", \"cooler\"]\n  }\n}\n</code></pre> <p>Implementation: <pre><code># query_builder.py, Lines 148-156\nconfig = self.component_config.get(component_type)\nif not config or not config.get(\"requires_compatibility\"):\n    logger.info(f\"\u23ed\ufe0f  SKIPPING compatibility filters (requires_compatibility=False)\")\n    return query, params, None\n\ndependencies = config.get(\"dependencies\", [])\n</code></pre></p>"},{"location":"CONTEXT_BASED_STRATEGIES/#technical-deep-dive","title":"Technical Deep-Dive","text":""},{"location":"CONTEXT_BASED_STRATEGIES/#mode-detection-algorithm","title":"Mode Detection Algorithm","text":"<p>File: <code>src/backend/app/services/search/orchestrator.py</code> Lines: 111-146</p> <pre><code># Line 112: Detect mode based on user message\ncommand_keywords = [\"skip\", \"done\", \"next\", \"finalize\", \"yes\", \"no\", \"\"]\nis_proactive_display = user_message.lower().strip() in command_keywords\n\nif is_proactive_display:\n    # Proactive display: Use only fast compatibility strategies\n    context_strategies = context_config.get(\"proactive_display\", {}).get(\n        \"enabled_strategies\", [\"cypher\"]\n    )\n    logger.info(f\"\ud83d\udd0d Proactive display mode - using strategies: {context_strategies}\")\nelse:\n    # User intent: Use all semantic matching strategies\n    context_strategies = context_config.get(\"user_intent\", {}).get(\n        \"enabled_strategies\", [\"cypher\", \"lucene\"]\n    )\n    logger.info(f\"\ud83c\udfaf User intent mode - using strategies: {context_strategies}\")\n</code></pre> <p>Detection Logic: - Proactive Mode Triggers: Empty message, \"skip\", \"done\", \"next\", \"finalize\", \"yes\", \"no\" - User Intent Mode Triggers: Any other message (search queries, product names, specifications)</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#strategy-selection-flow","title":"Strategy Selection Flow","text":"<pre><code>User Message Input\n    \u2193\nContext Detection (orchestrator.py:112)\n    \u2193\n    \u251c\u2500\u2192 Command Keyword? \u2192 PROACTIVE MODE\n    \u2502        \u2193\n    \u2502   Load proactive_display config\n    \u2502        \u2193\n    \u2502   Use [\"cypher\"] only\n    \u2502        \u2193\n    \u2502   Fast compatibility search (50-200ms)\n    \u2502        \u2193\n    \u2502   \u2705 Compatibility validated in query\n    \u2502\n    \u2514\u2500\u2192 Search Query? \u2192 USER INTENT MODE\n             \u2193\n        Load user_intent config\n             \u2193\n        Use [\"cypher\", \"lucene\", \"vector\", \"llm\"]\n             \u2193\n        Comprehensive semantic search (200-800ms)\n             \u2193\n        \u2705 All strategies validate compatibility\n</code></pre>"},{"location":"CONTEXT_BASED_STRATEGIES/#strategy-filtering-implementation","title":"Strategy Filtering Implementation","text":"<p>File: <code>src/backend/app/services/search/orchestrator.py</code> Lines: 135-138</p> <pre><code># Filter strategies by:\n# 1. Strategy is enabled (strategy.is_enabled() = True)\n# 2. Strategy name is in context-based enabled list\nenabled_strategies = [\n    s for s in self.strategies\n    if s.is_enabled() and s.get_name() in context_strategies\n]\n</code></pre> <p>Double-Gating Mechanism: - Gate 1: Strategy-level <code>is_enabled()</code> flag (individual strategy config) - Gate 2: Context-based <code>enabled_strategies</code> list (context config) - Both must be true for strategy to execute</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#performance-impact-analysis","title":"Performance Impact Analysis","text":""},{"location":"CONTEXT_BASED_STRATEGIES/#proactive-display-mode","title":"Proactive Display Mode","text":"<p>Enabled Strategies: Cypher only Typical Response Time: 50-200ms Use Cases: State transitions, navigation commands, skip/done actions</p> <p>Performance Breakdown: <pre><code>Context Detection:      5ms\nConfig Loading:        10ms\nCypher Query:         50-150ms  \u2190 Includes compatibility validation\nResult Formatting:     10-30ms\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTotal:                75-195ms\n</code></pre></p> <p>Strengths: - \u2705 Fast enough for real-time UI updates - \u2705 Minimal server load - \u2705 Predictable latency - \u2705 Suitable for mobile networks - \u2705 Still validates compatibility (via graph traversal)</p> <p>Limitations: - \u274c No relevance ranking (priority-based only) - \u274c No semantic understanding - \u274c Misses products with alternative terminology</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#user-intent-mode","title":"User Intent Mode","text":"<p>Enabled Strategies: Cypher + Lucene + Vector + LLM Typical Response Time: 200-800ms Use Cases: Search queries, product requests, specification-based searches</p> <p>Performance Breakdown: <pre><code>Context Detection:       5ms\nConfig Loading:         10ms\nParallel Strategy Execution:\n  \u251c\u2500 Cypher:           50-100ms  \u2190 Validates compatibility in query\n  \u251c\u2500 Lucene:          100-200ms  \u2190 Validates compatibility in query\n  \u251c\u2500 Vector:          200-400ms  \u2190 Post-validation available\n  \u2514\u2500 LLM:             300-600ms  \u2190 Inherits from Lucene/Vector\nResult Consolidation:   50-100ms\nScore Normalization:    10-20ms\nThreshold Filtering:    10-20ms\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTotal:                 200-800ms\n</code></pre></p> <p>Strengths: - \u2705 High relevance matching - \u2705 Semantic understanding - \u2705 Handles synonyms and concepts - \u2705 Intelligent re-ranking - \u2705 All strategies ensure compatibility</p> <p>Limitations: - \u26a0\ufe0f Higher latency (2-4x slower) - \u26a0\ufe0f More resource-intensive - \u26a0\ufe0f LLM costs per query - \u26a0\ufe0f Potential timeout on slow networks</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#scoring-and-quality-impact","title":"Scoring and Quality Impact","text":""},{"location":"CONTEXT_BASED_STRATEGIES/#proactive-display-scoring","title":"Proactive Display Scoring","text":"<p>Source: Cypher relationship priorities only (still includes compatibility)</p> <p>Score Calculation: <pre><code># Priority comes from Neo4j COMPATIBLE_WITH relationship weight\n# Lower priority number = higher rank\nproducts.sort(key=lambda p: p.priority)\n</code></pre></p> <p>Score Range: 1-100 (priority values) Score Meaning: Lower = better match</p> <p>Example: <pre><code>Product A: Priority 1 \u2192 Top recommendation (compatible)\nProduct B: Priority 5 \u2192 Secondary option (compatible)\nProduct C: Priority 10 \u2192 Tertiary option (compatible)\n</code></pre></p> <p>Quality Characteristics: - \u2705 Consistent ordering across sessions - \u2705 Deterministic results - \u2705 Guarantees compatibility - \u274c No relevance to user query specifics - \u274c Ignores product name/description matching</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#user-intent-scoring","title":"User Intent Scoring","text":"<p>Source: Weighted consolidation of 4 strategies (all validate compatibility)</p> <p>Score Calculation: <pre><code># Each strategy contributes weighted score\ncypher_score = cypher_result.priority_score * 0.25\nlucene_score = lucene_result.relevance_score * 0.35\nvector_score = vector_result.similarity_score * 0.25\nllm_score = llm_result.ranking_score * 0.15\n\n# Consolidated score\nfinal_score = cypher_score + lucene_score + vector_score + llm_score\n</code></pre></p> <p>Score Range: 0.0-20.0 (normalized consolidated scores) Score Meaning: Higher = better match</p> <p>Example: <pre><code>Product A: Score 15.3 \u2192 Excellent match (keyword + semantic + LLM + compatible)\nProduct B: Score 8.7 \u2192 Good match (keyword match, weaker semantic, compatible)\nProduct C: Score 3.2 \u2192 Weak match (compatibility only, low relevance)\n</code></pre></p> <p>Quality Characteristics: - \u2705 Query-specific relevance - \u2705 Balances multiple ranking signals - \u2705 Handles complex requirements - \u2705 Ensures compatibility across all strategies - \u26a0\ufe0f Non-deterministic (LLM scores may vary) - \u26a0\ufe0f Requires calibration of weights</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#configuration-trade-offs","title":"Configuration Trade-offs","text":""},{"location":"CONTEXT_BASED_STRATEGIES/#option-1-current-configuration-recommended","title":"Option 1: Current Configuration (Recommended)","text":"<pre><code>{\n  \"proactive_display\": {\"enabled_strategies\": [\"cypher\"]},\n  \"user_intent\": {\"enabled_strategies\": [\"cypher\", \"lucene\", \"vector\", \"llm\"]}\n}\n</code></pre> <p>Pros: - \u2705 Best balance of speed and quality - \u2705 Fast navigation (50-200ms) - \u2705 High-quality search results (200-800ms) - \u2705 Good user experience - \u2705 All results guaranteed compatible</p> <p>Cons: - \u26a0\ufe0f LLM costs for every search query - \u26a0\ufe0f 800ms max latency may feel slow on mobile</p> <p>Best For: Production deployments with budget for LLM calls</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#option-2-performance-optimized","title":"Option 2: Performance-Optimized","text":"<pre><code>{\n  \"proactive_display\": {\"enabled_strategies\": [\"cypher\"]},\n  \"user_intent\": {\"enabled_strategies\": [\"cypher\", \"lucene\"]}\n}\n</code></pre> <p>Pros: - \u2705 Faster search responses (100-300ms) - \u2705 No LLM costs - \u2705 Still good keyword matching - \u2705 Suitable for mobile networks - \u2705 Compatibility validation in all queries</p> <p>Cons: - \u274c No semantic understanding - \u274c Weaker handling of complex queries - \u274c Misses synonym matching</p> <p>Best For: Cost-sensitive deployments, mobile-first apps</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#option-3-quality-optimized","title":"Option 3: Quality-Optimized","text":"<pre><code>{\n  \"proactive_display\": {\"enabled_strategies\": [\"cypher\", \"lucene\"]},\n  \"user_intent\": {\"enabled_strategies\": [\"cypher\", \"lucene\", \"vector\", \"llm\"]}\n}\n</code></pre> <p>Pros: - \u2705 Better proactive display relevance - \u2705 Best possible search quality - \u2705 Consistent multi-strategy approach - \u2705 Maximum compatibility assurance</p> <p>Cons: - \u274c Slower navigation (150-400ms) - \u274c Higher server load - \u274c May feel laggy during state transitions</p> <p>Best For: Desktop applications, research/analysis tools</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#practical-examples","title":"Practical Examples","text":""},{"location":"CONTEXT_BASED_STRATEGIES/#example-1-state-transition-proactive-display","title":"Example 1: State Transition (Proactive Display)","text":"<p>User Action: User selects PowerSource \"Aristo 500ix\", system advances to Feeder state</p> <p>Message: <code>\"\"</code> (empty string when entering new state)</p> <p>Detection: <code>is_proactive_display = True</code> (empty string in command_keywords)</p> <p>Strategies Used: Cypher only</p> <p>Query with Compatibility Validation: <pre><code>MATCH (ps:PowerSource {gin: '0446200880'})\nMATCH (feeder:Feeder)-[:COMPATIBLE_WITH]-&gt;(ps)\nRETURN feeder\nORDER BY feeder.priority\n</code></pre></p> <p>Response Time: ~80ms</p> <p>Results (all compatible): <pre><code>1. RobustFeed U6 (Priority: 1)\n2. RobustFeed U74M (Priority: 5)\n3. RobustFeed U8 (Priority: 8)\n</code></pre></p> <p>User Experience: Instant display of compatible feeders, no perceived delay</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#example-2-product-search-user-intent","title":"Example 2: Product Search (User Intent)","text":"<p>User Message: <code>\"water-cooled feeder for 500A aluminum welding\"</code></p> <p>Detection: <code>is_proactive_display = False</code> (not a command keyword)</p> <p>Strategies Used: Cypher + Lucene + Vector + LLM (all validate compatibility)</p> <p>Parallel Execution:</p> <p>Cypher Query (50ms): <pre><code>MATCH (ps:PowerSource {gin: '0446200880'})\nMATCH (feeder:Feeder)-[:COMPATIBLE_WITH]-&gt;(ps)  \u2190 Compatibility\nWHERE feeder.current &gt;= 500\nRETURN feeder\n</code></pre></p> <p>Lucene Query (120ms): <pre><code>CALL db.index.fulltext.queryNodes('feederFulltextIndex', 'water-cooled 500A aluminum')\nYIELD node, score\nWHERE (node)-[:COMPATIBLE_WITH]-&gt;(:PowerSource {gin: '0446200880'})  \u2190 Compatibility\nRETURN node, score\n</code></pre></p> <p>Vector Query (250ms): <pre><code># Returns semantic matches (compatibility validated post-query)\nquery_embedding = openai.embeddings.create(\n    model=\"text-embedding-3-small\",\n    input=\"water-cooled feeder for 500A aluminum welding\"\n)\n# Neo4j vector search + external compatibility validation\n</code></pre></p> <p>LLM Query (450ms): <pre><code># Retrieves from Lucene (already compatible) and Vector\n# Re-ranks by suitability\n</code></pre></p> <p>Response Time: ~530ms total</p> <p>Results (all compatible): <pre><code>1. RobustFeed U74M WC (Score: 16.8) - Excellent match, compatible\n2. RobustFeed U8 WC (Score: 14.7) - Good match, compatible\n3. RobustFeed U6 (Score: 8.2) - Compatible but air-cooled\n</code></pre></p> <p>User Experience: Highly relevant AND compatible results ranked by suitability</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"CONTEXT_BASED_STRATEGIES/#log-markers","title":"Log Markers","text":"<p>Context Detection Logs (<code>orchestrator.py:116-132</code>): <pre><code>\ud83d\udd0d Proactive display mode - using strategies: ['cypher']\n\ud83c\udfaf User intent mode - using strategies: ['cypher', 'lucene', 'vector', 'llm']\n</code></pre></p> <p>Compatibility Validation Logs: <pre><code>\u2705 Compatibility filters added: PowerSource \u2192 Feeder\n\u2705 Compatibility filters added: PowerSource, Feeder \u2192 Interconnector\n\u23ed\ufe0f  SKIPPING compatibility filters (requires_compatibility=False)\n</code></pre></p> <p>Strategy Execution Logs: <pre><code>\u26a1 Cypher strategy executing... (50ms) [compatibility in query]\n\ud83d\udcda Lucene strategy executing... (120ms) [compatibility in query]\n\ud83d\udd2e Vector strategy executing... (250ms) [post-validation available]\n\ud83e\udd16 LLM strategy executing... (450ms) [inherits from retrieval]\n</code></pre></p>"},{"location":"CONTEXT_BASED_STRATEGIES/#performance-monitoring","title":"Performance Monitoring","text":"<p>Key Metrics to Track: - <code>search.context_detection.duration_ms</code> - Context detection time - <code>search.strategy.{name}.duration_ms</code> - Individual strategy execution time - <code>search.compatibility_validation.duration_ms</code> - Compatibility check time - <code>search.consolidation.duration_ms</code> - Score consolidation time - <code>search.total.duration_ms</code> - End-to-end search time - <code>search.mode.proactive.count</code> - Number of proactive searches - <code>search.mode.user_intent.count</code> - Number of user intent searches</p> <p>Alert Thresholds: - Proactive display &gt; 300ms \u2192 Investigate database performance - User intent &gt; 1000ms \u2192 Check LLM API latency or network issues - Compatibility validation &gt; 100ms \u2192 Review graph query optimization - Consolidation &gt; 200ms \u2192 Review threshold filtering complexity</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#summary","title":"Summary","text":"<p>Context-Based Strategies provide intelligent search optimization by:</p> <ol> <li>Detecting Context: Command keywords vs search queries</li> <li>Selecting Strategies: Fast compatibility (Cypher) vs comprehensive semantic search (all strategies)</li> <li>Ensuring Compatibility: ALL strategies validate COMPATIBLE_WITH relationships at appropriate layers</li> <li>Balancing Trade-offs: 60-75% faster navigation without sacrificing search quality or compatibility</li> <li>Maintaining Flexibility: Easy configuration changes via JSON</li> </ol> <p>Key Takeaways: - \u2705 Proactive mode (50-200ms) for state transitions - validates compatibility in query - \u2705 User intent mode (200-800ms) for searches - all strategies validate compatibility - \u2705 Configurable strategy combinations for different deployment needs - \u2705 Weighted score consolidation for high-quality ranking - \u2705 Centralized compatibility logic via <code>Neo4jQueryBuilder.add_compatibility_filters()</code></p> <p>Recommended Configuration: Keep default (cypher-only proactive, all-strategies user intent) for best balance of speed, quality, and guaranteed compatibility.</p>"},{"location":"CONTEXT_BASED_STRATEGIES/#related-documentation","title":"Related Documentation","text":"<ul> <li>Corrected State Flow Architecture - S1\u2192SN state machine</li> <li>Threshold Filtering Analysis - Score filtering and boosting</li> <li>Code Architecture Overview - Complete system architecture</li> <li>Product Search Service - Neo4j search implementation</li> </ul> <p>Configuration Files: - <code>src/backend/app/config/search_config.json</code> - Context-based strategy configuration - <code>src/backend/app/config/component_types.json</code> - Compatibility requirements per component</p> <p>Implementation Files: - <code>src/backend/app/services/search/orchestrator.py</code> - Context detection and strategy selection - <code>src/backend/app/services/search/query_builder.py</code> - Centralized compatibility validation logic - <code>src/backend/app/services/search/consolidator.py</code> - Score consolidation and threshold filtering - <code>src/backend/app/services/search/strategies/</code> - Individual strategy implementations</p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/","title":"Corrected State Flow Architecture - S1\u2192SN Dynamic Progression","text":"<p>Version: 2.0 Date: 2025-10-24 Status: Architecture Design - Spec-Compliant Flow with Compatibility Validation</p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#executive-summary","title":"Executive Summary","text":"<p>This document corrects the implementation flow to match the v5.4 specification exactly: - Sequential state progression S1\u2192SN (configuration-driven, not all at once) - PowerSource (S1) is MANDATORY - cannot be skipped - Collect parameters per state before searching Neo4j - Search Neo4j only when \u22651 parameter for that component - Compatibility validation using COMPATIBLE_WITH relationships - User-driven progression (user must confirm/skip to advance) - Component applicability determines which states are active</p> <p>Spec Reference: Section 2 - State Machine (S1\u2192SN), Lines 217-286</p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#critical-rules","title":"Critical Rules","text":""},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#rule-1-powersource-is-mandatory","title":"Rule 1: PowerSource is Mandatory","text":"<ul> <li>S1 (PowerSource) CANNOT be skipped</li> <li>User must provide \u22651 parameter OR direct product mention</li> <li>System will keep prompting until PowerSource is selected</li> <li>All other states (S2-S6) can be skipped</li> </ul>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#rule-2-compatibility-validation","title":"Rule 2: Compatibility Validation","text":"<ul> <li>Every component search must validate compatibility with previously selected components</li> <li>Uses Neo4j <code>COMPATIBLE_WITH</code> relationships (bidirectional)</li> <li>Compatibility rules are component-specific (see Section 9)</li> </ul>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#rule-3-compound-request-handling-new-in-v21","title":"Rule 3: Compound Request Handling (New in v2.1)","text":"<ul> <li>Proactive Search: Users can specify multiple components in one message</li> <li>Auto-Selection: Exact matches (1 result) are auto-selected</li> <li>Disambiguation: Multiple matches (2+ results) queue for user choice</li> <li>Validation: PowerSource required before downstream components</li> <li>State Skipping: Auto-selected components skip their corresponding states</li> </ul>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#compound-request-flow-proactive-search","title":"Compound Request Flow (Proactive Search)","text":"<p>New in v2.1: The system now supports compound requests where users specify multiple components simultaneously instead of going through sequential states.</p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#detection-validation","title":"Detection &amp; Validation","text":"<pre><code>User Message \u2192 ParameterExtractor (LLM)\n    \u2193\nMasterParameterJSON populated with 1+ components\n    \u2193\nOrchestrator._detect_compound_request()\n    \u2193\nCompound Request? (1+ components with parameters)\n    \u251c\u2500 YES \u2192 Proceed to Validation\n    \u2514\u2500 NO  \u2192 Use Sequential Flow (Section 1 below)\n\nOrchestrator._validate_compound_request()\n    \u2193\nPowerSource Present?\n    \u251c\u2500 YES \u2192 Proceed to Parallel Search\n    \u2514\u2500 NO (downstream only) \u2192 ERROR: \"Please specify PowerSource first\"\n</code></pre>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#parallel-component-search","title":"Parallel Component Search","text":"<pre><code>For each specified component:\n    \u2193\nOrchestrator._search_component(component_type)\n    \u2193\nNeo4j Product Search\n    \u2193\nResults?\n    \u251c\u2500 1 Exact Match  \u2192 AUTO-SELECT \u2192 Add to ResponseJSON\n    \u251c\u2500 2+ Matches     \u2192 QUEUE for disambiguation\n    \u2514\u2500 0 Matches      \u2192 FALLBACK to all compatible products\n</code></pre>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#auto-selection-state-progression","title":"Auto-Selection &amp; State Progression","text":"<pre><code>All Components Processed\n    \u2193\nAuto-Selected Components \u2192 Skip their states\n    \u2193\nQueued Components \u2192 Stop at first disambiguation state\n    \u2193\nDetermine Next State:\n    \u251c\u2500 Has queued components? \u2192 Go to first queued component state\n    \u251c\u2500 Has unselected applicable components? \u2192 Go to next applicable state\n    \u2514\u2500 All handled? \u2192 Go to FINALIZE\n</code></pre>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#example-flow-aristo-500ix-with-robustfeed-u6","title":"Example Flow: \"Aristo 500ix with RobustFeed U6\"","text":"<pre><code>Step 1: DETECTION\n- ParameterExtractor fills: power_source{product_name: \"Aristo 500ix\"}, feeder{product_name: \"RobustFeed U6\"}\n- _detect_compound_request() \u2192 TRUE (2 components specified)\n\nStep 2: VALIDATION\n- _validate_compound_request() \u2192 PASS (PowerSource present)\n\nStep 3: PARALLEL SEARCH\n- Search PowerSource \"Aristo 500ix\" \u2192 1 result (GIN: 0446200880) \u2192 AUTO-SELECT\n- Search Feeder \"RobustFeed U6\" \u2192 1 result (GIN: 0460520880) \u2192 AUTO-SELECT\n\nStep 4: STATE PROGRESSION\n- Skip power_source_selection (auto-selected)\n- Skip feeder_selection (auto-selected)\n- Move to cooler_selection (next applicable component)\n\nStep 5: RESPONSE\n\"\u2705 PowerSource: Aristo 500ix (GIN: 0446200880) - Auto-selected\n \u2705 Feeder: RobustFeed U6 (GIN: 0460520880) - Auto-selected\n\n Current Package:\n \u2022 PowerSource: Aristo 500ix\n \u2022 Feeder: RobustFeed U6\n\n Next: Would you like to add a Cooler? [Y/N/skip]\"\n</code></pre>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#example-flow-aristo-500ix-with-robustfeed-disambiguation","title":"Example Flow: \"Aristo 500ix with RobustFeed\" (Disambiguation)","text":"<pre><code>Step 1-2: Same as above\n\nStep 3: PARALLEL SEARCH\n- Search PowerSource \"Aristo 500ix\" \u2192 1 result \u2192 AUTO-SELECT\n- Search Feeder \"RobustFeed\" \u2192 3 results (U4, U6, PRO) \u2192 QUEUE for disambiguation\n\nStep 4: STATE PROGRESSION\n- Skip power_source_selection (auto-selected)\n- Stop at feeder_selection (disambiguation needed)\n\nStep 5: RESPONSE\n\"\u2705 PowerSource: Aristo 500ix - Auto-selected\n\n For Feeder, I found multiple RobustFeed models:\n 1. RobustFeed U4 (GIN: 0460510880)\n 2. RobustFeed U6 (GIN: 0460520880)\n 3. RobustFeed PRO (GIN: 0460530880)\n\n Which feeder would you like?\"\n</code></pre>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#validation-error-i-need-robustfeed-u6-no-powersource","title":"Validation Error: \"I need RobustFeed U6\" (No PowerSource)","text":"<pre><code>Step 1: DETECTION\n- ParameterExtractor fills: feeder{product_name: \"RobustFeed U6\"}\n- _detect_compound_request() \u2192 TRUE (1 component specified)\n\nStep 2: VALIDATION\n- _validate_compound_request() \u2192 FAIL (No PowerSource, downstream component)\n\nStep 3: ERROR RESPONSE\n\"To configure a Feeder, I first need to know which Power Source you want.\n Please specify a power source (e.g., 'Aristo 500ix', '500A MIG welder').\"\n\n State remains: power_source_selection\n</code></pre>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#1-correct-state-flow-sequential","title":"1. Correct State Flow (Sequential)","text":""},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#11-state-by-state-progression","title":"1.1 State-by-State Progression","text":"<pre><code>S1: PowerSource\n    \u2193 (user provides details OR says \"skip\")\n    \u2193\n[Check Component Applicability JSON]\n    \u2193\nS2: Feeder (if Y) OR skip to S3/S4/S5\n    \u2193 (user provides details OR says \"skip\")\n    \u2193\nS3: Cooler (if Y) OR skip to S4/S5\n    \u2193 (user provides details OR says \"skip\")\n    \u2193\nS4: Interconnect (if Y) OR skip to S5\n    \u2193 (user provides details OR says \"skip\")\n    \u2193\nS5: Torch (if Y)\n    \u2193 (user provides details OR says \"skip\")\n    \u2193\nS6: Accessories (optional)\n    \u2193 (user says \"go ahead\", \"generate packages\", or \"skip all\")\n    \u2193\nS7: Finalize (check \u22653 components, get confirmation, call backend)\n</code></pre>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#2-state-processing-logic","title":"2. State Processing Logic","text":""},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#21-per-state-processing-flow","title":"2.1 Per-State Processing Flow","text":"<p>For Each State Sn (n = 1 to 6):</p> <pre><code>1. CHECK STATE APPLICABILITY\n   - If current state marked \"N\" in Component Applicability JSON\n   \u2192 Auto-fill as NA\n   \u2192 Skip to next \"Y\" state\n\n2. PROMPT USER FOR COMPONENT DETAILS\n   - Generate user-friendly prompt based on component type\n   - Example: \"Tell me what you need in a Feeder:\n     \u2022 Portability (portable or stationary)\n     \u2022 Wire size (e.g., 0.035 inch, 0.045 inch)\n     \u2022 Wire material (aluminum, steel, stainless)\n     Or say 'skip' to continue without a feeder.\"\n\n3. EXTRACT PARAMETERS USING LLM\n   - User responds with details OR \"skip\"\n   - LLM extracts parameters into Master JSON for THAT component only\n   - Example: \"I need a portable feeder with 0.035 wire\"\n   \u2192 Master JSON Feeder: {portability: \"portable\", wire_size: \"0.035 inch\"}\n\n4. CHECK ELIGIBILITY FOR NEO4J SEARCH\n   - If Master JSON has \u22651 parameter for this component (OR direct product mention)\n   \u2192 Search Neo4j for matching products\n\n   - If 0 parameters\n   \u2192 Ask user for more details OR allow skip\n\n5. NEO4J PRODUCT SEARCH\n   - Use Master JSON parameters to search Neo4j\n   - Return 1-5 matching products\n\n6. PRESENT OPTIONS TO USER\n   - If 1 product found: \"I found the [Product Name]. Does this work for you?\"\n\n   - If &gt;1 products found: \"I found several options:\n     1. [Product 1] - [Key Features]\n     2. [Product 2] - [Key Features]\n     3. [Product 3] - [Key Features]\n     Which would you prefer, or would you like more details?\"\n\n7. USER SELECTION OR SKIP\n   - User selects a product \u2192 Add to Response JSON (cart)\n   - User says \"skip\" \u2192 Mark component as skipped (empty in Response JSON)\n   - User asks for details \u2192 Show detailed product info\n\n8. ADVANCE TO NEXT STATE\n   - Move to next state in sequence\n   - Check Component Applicability to determine next active state\n   - Repeat steps 1-8 for next component\n</code></pre>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#3-detailed-state-implementations","title":"3. Detailed State Implementations","text":""},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#31-s1-powersource-mandatory-cannot-skip","title":"3.1 S1: PowerSource (MANDATORY - Cannot Skip)","text":"<p>Mandatory Validation: - PowerSource is the ONLY mandatory component - User CANNOT say \"skip\" for this state - System must keep prompting until \u22651 parameter OR direct product mention - Once selected, triggers Component Applicability configuration</p> <p>Prompt Template: <pre><code>\"Welcome! Let's configure your welding package.\n\nWhat power source do you need? (This is required to continue)\n\nYou can tell me:\n\u2022 Amperage (e.g., 300A, 500A)\n\u2022 Welding process (MIG, TIG, Stick)\n\u2022 Material you'll be welding (aluminum, steel, stainless)\n\u2022 Input voltage/phase (230V, 460V, 3-phase)\n\nOr mention a specific model (e.g., 'Aristo 500ix', 'Renegade ES300').\"\n</code></pre></p> <p>User Response Examples: - \"I need 500 amps for MIG welding\" \u2192 Extract parameters - \"Aristo 500ix\" \u2192 Direct product lookup - \"500A aluminum welding\" \u2192 Extract parameters - \"skip\" \u2192 REJECTED: \"PowerSource is required. Please tell me what you need.\"</p> <p>LLM Extraction: <pre><code>{\n  \"master_json_updates\": {\n    \"PowerSource\": {\n      \"current_output\": \"500 A\",\n      \"process\": \"MIG (GMAW)\",\n      \"material\": \"aluminum\"\n    }\n  }\n}\n</code></pre></p> <p>Neo4j Search (if \u22651 parameter): <pre><code>CALL db.index.vector.queryNodes('product_embeddings', 5, embedding_vector)\nYIELD node, score\nWHERE node.category = 'PowerSource'\n  AND node.current_output CONTAINS '500'\n  AND 'MIG (GMAW)' IN node.process\n  AND node.material CONTAINS 'aluminum'\nRETURN node\nORDER BY score DESC\nLIMIT 5\n</code></pre></p> <p>Present Options: <pre><code>\"I found these power sources:\n\n1. Aristo 500ix - 500A MIG/TIG, 3-phase, aluminum-ready\n2. Warrior 500i - 500A MIG, 3-phase, multi-material\n\nWhich would you prefer?\"\n</code></pre></p> <p>After Selection: - Add to Response JSON: <code>{\"PowerSource\": {\"gin\": \"0446200880\", \"description\": \"Aristo 500ix\"}}</code> - Check Component Applicability JSON for Aristo 500ix - Auto-fill NA components if any marked \"N\" - Advance to next \"Y\" state (e.g., Feeder if Y, or Torch if Feeder is N)</p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#32-s2-feeder","title":"3.2 S2: Feeder","text":"<p>Check Applicability First: <pre><code>applicability = component_config.get_applicability(\"0446200880\")  # Aristo 500ix\n\nif applicability.Feeder == \"N\":\n    # Auto-fill NA\n    response_json[\"Feeder\"] = {\"gin\": \"NA\", \"description\": \"Not Applicable\"}\n    # Skip to S3\nelse:\n    # Proceed with feeder selection\n</code></pre></p> <p>Prompt Template (if Y): <pre><code>\"Great choice! Now let's select a feeder.\n\nFor the Aristo 500ix, you'll need a feeder. Tell me your preferences:\n\u2022 Portability (portable or stationary)\n\u2022 Wire size (common: 0.030, 0.035, 0.045 inch)\n\u2022 Wire material (aluminum, steel, stainless)\n\nOr say 'skip' if you don't need a feeder right now.\"\n</code></pre></p> <p>User Response Examples: - \"I need a portable feeder with 0.035 wire\" \u2192 Extract parameters - \"Python 450\" \u2192 Direct product lookup - \"Skip\" \u2192 Skip feeder (Response JSON Feeder remains empty)</p> <p>LLM Extraction: <pre><code>{\n  \"master_json_updates\": {\n    \"Feeder\": {\n      \"portability\": \"portable\",\n      \"wire_size\": \"0.035 inch\",\n      \"process\": \"MIG (GMAW)\"  // Inherited from PowerSource\n    }\n  }\n}\n</code></pre></p> <p>Compatibility Validation: - Feeder must be compatible with PowerSource - Uses COMPATIBLE_WITH relationship in Neo4j</p> <p>Neo4j Search (if \u22651 parameter): <pre><code>// Find feeders compatible with selected PowerSource\nMATCH (ps:Product {gin: $power_source_gin})-[:COMPATIBLE_WITH]-(f:Product)\nWHERE f.category = 'Feeder'\n  AND ($portability IS NULL OR f.portability CONTAINS $portability)\n  AND ($wire_size IS NULL OR f.wire_size CONTAINS $wire_size)\nRETURN f\nLIMIT 5\n\n// Parameters from Master JSON:\n// $power_source_gin = \"0446200880\" (from Response JSON)\n// $portability = \"portable\" (from Master JSON Feeder)\n// $wire_size = \"0.035\" (from Master JSON Feeder)\n</code></pre></p> <p>Present Options: <pre><code>\"I found these compatible feeders:\n\n1. Python 450 - Portable, 0.030-0.045 inch wire, aluminum-ready\n2. Wire Feeder 15A - Portable, 0.035 inch, steel/stainless\n\nWhich feeder works for you?\"\n</code></pre></p> <p>After Selection: - Add to Response JSON: <code>{\"Feeder\": {\"gin\": \"K4331-1\", \"description\": \"Python 450\"}}</code> - Advance to S3 (Cooler)</p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#33-s3-cooler","title":"3.3 S3: Cooler","text":"<p>Prompt Template (if Y): <pre><code>\"Excellent! Now for the cooling system.\n\nFor your Aristo 500ix and Python 450, you'll need a cooler.\n\nWhat cooling do you prefer?\n\u2022 Cooling type (water or air)\n\u2022 Flow rate (e.g., 2 GPM, 4 GPM for water cooling)\n\u2022 Tank capacity (e.g., 3 gallon, 5 gallon)\n\nOr say 'skip' if you don't need a cooler.\"\n</code></pre></p> <p>User Response Examples: - \"Water cooling\" \u2192 Extract cooling_type - \"I need 4 GPM water cooling\" \u2192 Extract cooling_type + flow_rate - \"Cool Mate 3\" \u2192 Direct product lookup - \"Skip\" \u2192 Skip cooler</p> <p>LLM Extraction: <pre><code>{\n  \"master_json_updates\": {\n    \"Cooler\": {\n      \"cooling_type\": \"water\",\n      \"flow_rate\": \"4 GPM\"\n    }\n  }\n}\n</code></pre></p> <p>Compatibility Validation: - Cooler must be compatible with PowerSource AND Feeder (if selected)</p> <p>Neo4j Search: <pre><code>// Find coolers compatible with PowerSource AND Feeder\nMATCH (ps:Product {gin: $power_source_gin})-[:COMPATIBLE_WITH]-(c:Product)\nWHERE c.category = 'Cooler'\n  AND ($cooling_type IS NULL OR c.cooling_type = $cooling_type)\n  AND ($flow_rate IS NULL OR c.flow_rate CONTAINS $flow_rate)\n  // If feeder was selected, validate compatibility\n  AND (\n    $feeder_gin IS NULL\n    OR $feeder_gin = ''\n    OR EXISTS((c)-[:COMPATIBLE_WITH]-(:Product {gin: $feeder_gin}))\n  )\nRETURN c\nLIMIT 5\n\n// Parameters:\n// $power_source_gin = \"0446200880\" (from Response JSON)\n// $feeder_gin = \"K4331-1\" (from Response JSON, if selected)\n// $cooling_type = \"water\" (from Master JSON)\n// $flow_rate = \"4 GPM\" (from Master JSON)\n</code></pre></p> <p>After Selection: - Add to Response JSON: <code>{\"Cooler\": {\"gin\": \"K2584-1\", \"description\": \"Cool Mate 3\"}}</code> - Advance to S4 (Interconnect)</p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#34-s4-interconnect","title":"3.4 S4: Interconnect","text":"<p>Prompt Template (if Y): <pre><code>\"Perfect! Now let's select the interconnector cable.\n\nWhat cable length do you need?\n\u2022 3 meters (10 ft) - compact setup\n\u2022 5 meters (16 ft) - standard\n\u2022 10 meters (33 ft) - extended reach\n\u2022 15 meters (50 ft) - maximum reach\n\nOr say 'skip'.\"\n</code></pre></p> <p>User Response Examples: - \"5 meters\" \u2192 Extract length - \"I need 10m cable\" \u2192 Extract length - \"Skip\" \u2192 Skip interconnect</p> <p>LLM Extraction: <pre><code>{\n  \"master_json_updates\": {\n    \"Interconnect\": {\n      \"length\": \"16 ft\"\n    }\n  }\n}\n</code></pre></p> <p>Compatibility Validation: - Interconnector must be compatible with PowerSource, Feeder, and Cooler (if selected)</p> <p>Neo4j Search: <pre><code>// Find interconnectors compatible with all selected components\nMATCH (ps:Product {gin: $power_source_gin})-[:COMPATIBLE_WITH]-(ic:Product)\nWHERE ic.category = 'Interconnector'\n  AND ($length IS NULL OR ic.length CONTAINS $length)\n  // Validate compatibility with Feeder (if selected)\n  AND (\n    $feeder_gin IS NULL OR $feeder_gin = ''\n    OR EXISTS((ic)-[:COMPATIBLE_WITH]-(:Product {gin: $feeder_gin}))\n  )\n  // Validate compatibility with Cooler (if selected)\n  AND (\n    $cooler_gin IS NULL OR $cooler_gin = ''\n    OR EXISTS((ic)-[:COMPATIBLE_WITH]-(:Product {gin: $cooler_gin}))\n  )\nRETURN ic\nLIMIT 5\n\n// Parameters:\n// $power_source_gin, $feeder_gin, $cooler_gin from Response JSON\n// $length from Master JSON\n</code></pre></p> <p>After Selection: - Add to Response JSON: <code>{\"Interconnect\": {\"gin\": \"...\", \"description\": \"Interconnector Cable 5m\"}}</code> - Advance to S5 (Torch)</p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#35-s5-torch","title":"3.5 S5: Torch","text":"<p>Prompt Template (if Y): <pre><code>\"Almost done! Now let's select your torch.\n\nFor your setup, what torch characteristics do you need?\n\u2022 Amperage rating (should match your power source: 400A, 500A, 600A)\n\u2022 Cooling type (water-cooled or air-cooled)\n\u2022 Cable length (if different from interconnector)\n\nOr mention a specific torch model, or say 'skip'.\"\n</code></pre></p> <p>User Response Examples: - \"500A water-cooled torch\" \u2192 Extract parameters - \"Bernard Q400\" \u2192 Direct product lookup - \"Skip\" \u2192 Skip torch</p> <p>LLM Extraction: <pre><code>{\n  \"master_json_updates\": {\n    \"Torch\": {\n      \"amperage_rating\": \"500 A\",\n      \"cooling_type\": \"water\",\n      \"process\": \"MIG (GMAW)\"\n    }\n  }\n}\n</code></pre></p> <p>Compatibility Validation: - Torch must be compatible with Feeder AND Cooler (if selected) - Note: Torch compatibility is with Feeder/Cooler, NOT PowerSource directly</p> <p>Neo4j Search: <pre><code>// Find torches compatible with Feeder AND Cooler\n// Start with Feeder if selected, otherwise PowerSource\nMATCH (base:Product)\nWHERE (\n  ($feeder_gin IS NOT NULL AND $feeder_gin != '' AND base.gin = $feeder_gin)\n  OR ($feeder_gin IS NULL OR $feeder_gin = '') AND base.gin = $power_source_gin\n)\nMATCH (base)-[:COMPATIBLE_WITH]-(t:Product)\nWHERE t.category = 'Torch'\n  AND ($amperage_rating IS NULL OR t.amperage_rating CONTAINS $amperage_rating)\n  AND ($cooling_type IS NULL OR t.cooling_type = $cooling_type)\n  // Validate compatibility with Cooler (if selected)\n  AND (\n    $cooler_gin IS NULL OR $cooler_gin = ''\n    OR EXISTS((t)-[:COMPATIBLE_WITH]-(:Product {gin: $cooler_gin}))\n  )\nRETURN t\nLIMIT 5\n\n// Parameters:\n// $feeder_gin, $cooler_gin, $power_source_gin from Response JSON\n// $amperage_rating, $cooling_type from Master JSON\n</code></pre></p> <p>After Selection: - Add to Response JSON: <code>{\"Torch\": {\"gin\": \"...\", \"description\": \"Bernard Q400\"}}</code> - Advance to S6 (Accessories)</p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#36-s6-accessories-optional","title":"3.6 S6: Accessories (Optional)","text":"<p>Prompt Template: <pre><code>\"Great! Your core package is complete:\n\u2022 PowerSource: Aristo 500ix\n\u2022 Feeder: Python 450\n\u2022 Cooler: Cool Mate 3\n\u2022 Interconnect: 5m Cable\n\u2022 Torch: Bernard Q400\n\nWould you like to add any accessories, or shall we proceed to generate your complete package?\n\nSay 'add accessories' to browse, or 'go ahead' / 'generate packages' to finalize.\"\n</code></pre></p> <p>User Response: - \"Go ahead\" / \"Generate packages\" / \"Finalize\" \u2192 Advance to S7 - \"Add accessories\" \u2192 Show accessory options - \"Skip all\" \u2192 Advance to S7</p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#37-s7-finalize","title":"3.7 S7: Finalize","text":"<p>Step 1: Validate Threshold <pre><code># Count real components in Response JSON\nreal_count = count_real_components(response_json)\n\nif real_count &lt; 3:\n    return \"\"\"\n    You need at least 3 components to generate packages.\n    Currently you have {real_count}:\n    \u2022 PowerSource: Aristo 500ix\n    \u2022 Feeder: Python 450\n\n    Would you like to add more components?\n    \"\"\"\n</code></pre></p> <p>Step 2: Get User Confirmation <pre><code>\"Your configuration is ready with {component_count} components.\n\nReady to generate your complete packages?\n\nSay 'confirm' or 'yes' to proceed.\"\n</code></pre></p> <p>Step 3: Call Backend <pre><code>if user_confirms:\n    # Call Sparky + Standard package generation\n    packages = await orchestrator.generate_packages(\n        response_json=response_json,\n        master_json=master_json\n    )\n\n    # Present both packages to user\n    return format_package_presentation(packages)\n</code></pre></p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#4-component-applicability-integration","title":"4. Component Applicability Integration","text":""},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#41-dynamic-state-skipping","title":"4.1 Dynamic State Skipping","text":"<p>After S1 (PowerSource Selection):</p> <pre><code>async def _handle_power_source_selection(session, user_message):\n    # ... user selects Aristo 500ix ...\n\n    power_source_gin = \"0446200880\"  # Aristo 500ix\n\n    # Get component applicability\n    config_manager = get_component_config_manager()\n    applicability = config_manager.get_applicability(power_source_gin)\n\n    # AUTO-FILL NA COMPONENTS IMMEDIATELY\n    na_service = get_na_autofill_service()\n    filled_na = na_service.auto_fill_na_components(\n        session.partial_package,\n        applicability\n    )\n\n    # Example: Renegade ES300 has Feeder=N, Cooler=N, Interconnect=N\n    if applicability.Feeder == \"N\":\n        response_json[\"Feeder\"] = {\"gin\": \"NA\", \"description\": \"Not Applicable\"}\n    if applicability.Cooler == \"N\":\n        response_json[\"Cooler\"] = {\"gin\": \"NA\", \"description\": \"Not Applicable\"}\n    if applicability.Interconnect == \"N\":\n        response_json[\"Interconnect\"] = {\"gin\": \"NA\", \"description\": \"Not Applicable\"}\n\n    # Build confirmation message\n    message = f\"Great! Selected {power_source.name}.\\n\\n\"\n\n    if filled_na:\n        message += \"The following components are not needed for this power source:\\n\"\n        for component in filled_na:\n            message += f\"\u2022 {component}: Not Applicable\\n\"\n        message += \"\\n\"\n\n    # Determine next state\n    next_state = state_machine.get_next_active_state(\n        current_state=ConversationState.POWER_SOURCE,\n        applicability=applicability\n    )\n\n    # Example: Renegade ES300 \u2192 skip to Torch (S5)\n    # Example: Aristo 500ix \u2192 proceed to Feeder (S2)\n\n    return message, [], next_state\n</code></pre>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#5-master-json-vs-response-json","title":"5. Master JSON vs Response JSON","text":""},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#51-clear-separation","title":"5.1 Clear Separation","text":"<p>Master Parameter JSON (User Requirements): <pre><code>{\n  \"PowerSource\": {\n    \"process\": \"MIG (GMAW)\",\n    \"current_output\": \"500 A\",\n    \"material\": \"aluminum\",\n    \"voltage\": \"230V\",\n    \"phase\": \"3-phase\"\n  },\n  \"Feeder\": {\n    \"portability\": \"portable\",\n    \"wire_size\": \"0.035 inch\",\n    \"process\": \"MIG (GMAW)\"\n  },\n  \"Cooler\": {\n    \"cooling_type\": \"water\",\n    \"flow_rate\": \"4 GPM\"\n  }\n}\n</code></pre></p> <p>Response JSON (Selected Products - \"Cart\"): <pre><code>{\n  \"PowerSource\": {\n    \"gin\": \"0446200880\",\n    \"description\": \"Aristo 500ix\"\n  },\n  \"Feeder\": {\n    \"gin\": \"K4331-1\",\n    \"description\": \"Python 450\"\n  },\n  \"Cooler\": {\n    \"gin\": \"K2584-1\",\n    \"description\": \"Cool Mate 3\"\n  },\n  \"Interconnect\": {\n    \"gin\": \"NA\",\n    \"description\": \"Not Applicable\"\n  },\n  \"Torch\": {\n    \"gin\": \"\",\n    \"description\": \"\"\n  }\n}\n</code></pre></p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#52-usage","title":"5.2 Usage","text":"<ul> <li>Master JSON: Used for Neo4j search, parameter tracking, requirement validation</li> <li>Response JSON: Used for cart, package generation, backend API calls</li> </ul>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#6-conversation-flow-example","title":"6. Conversation Flow Example","text":""},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#61-example-aristo-500ix-configuration-all-y","title":"6.1 Example: Aristo 500ix Configuration (All Y)","text":"<p>Turn 1: S1 PowerSource <pre><code>System: \"What power source do you need?\"\nUser: \"I need Aristo 500ix\"\n\n[LLM Extraction]\nMaster JSON PowerSource: {direct_product_mention: \"Aristo 500ix\"}\n\n[Neo4j Direct Lookup]\nFound: Aristo 500ix (0446200880)\n\n[Check Applicability]\nFeeder=Y, Cooler=Y, Interconnect=Y, Torch=Y\n\nSystem: \"Great! Selected Aristo 500ix (500A MIG/TIG).\nNow let's select a feeder...\"\n</code></pre></p> <p>Turn 2: S2 Feeder <pre><code>System: \"What feeder do you need? (portability, wire size, material)\"\nUser: \"Portable feeder with 0.035 wire\"\n\n[LLM Extraction]\nMaster JSON Feeder: {portability: \"portable\", wire_size: \"0.035 inch\"}\n\n[Neo4j Search - COMPATIBLE_WITH Aristo]\nFound:\n1. Python 450 - Portable, 0.030-0.045 inch\n2. Wire Feeder 15A - Portable, 0.035 inch\n\nSystem: \"I found these feeders:\n1. Python 450 - Portable, 0.030-0.045 inch wire\n2. Wire Feeder 15A - Portable, 0.035 inch\n\nWhich one?\"\n\nUser: \"Python 450\"\n\n[Add to Response JSON]\nResponse JSON Feeder: {gin: \"K4331-1\", description: \"Python 450\"}\n\nSystem: \"Excellent! Python 450 selected.\nNow for the cooling system...\"\n</code></pre></p> <p>Turn 3: S3 Cooler <pre><code>System: \"What cooling do you need?\"\nUser: \"Water cooling\"\n\n[LLM Extraction]\nMaster JSON Cooler: {cooling_type: \"water\"}\n\n[Neo4j Search]\nFound: Cool Mate 3 - 4 GPM water cooling\n\nSystem: \"I found Cool Mate 3 (4 GPM water cooling). Good for you?\"\nUser: \"Yes\"\n\n[Add to Response JSON]\nSystem: \"Great! Cool Mate 3 added. Now for interconnector cable...\"\n</code></pre></p> <p>Turn 4: S4 Interconnect <pre><code>System: \"What cable length? (3m, 5m, 10m, 15m)\"\nUser: \"5 meters\"\n\n[Search &amp; Add]\nResponse JSON Interconnect: {gin: \"...\", description: \"5m Cable\"}\n\nSystem: \"5m cable added. Now let's select your torch...\"\n</code></pre></p> <p>Turn 5: S5 Torch <pre><code>System: \"What torch? (amperage, cooling)\"\nUser: \"500A water-cooled\"\n\n[Search &amp; Add]\nResponse JSON Torch: {gin: \"...\", description: \"Bernard Q400\"}\n\nSystem: \"Bernard Q400 added!\n\nYour package:\n\u2022 PowerSource: Aristo 500ix\n\u2022 Feeder: Python 450\n\u2022 Cooler: Cool Mate 3\n\u2022 Interconnect: 5m Cable\n\u2022 Torch: Bernard Q400\n\nAdd accessories or generate packages?\"\n</code></pre></p> <p>Turn 6: S6 Accessories <pre><code>User: \"Generate packages\"\n\n[Advance to S7]\n</code></pre></p> <p>Turn 7: S7 Finalize <pre><code>[Validate Threshold]\nReal components: 5 (\u22653 \u2713)\n\nSystem: \"Ready to generate packages with 5 components. Confirm?\"\nUser: \"Yes\"\n\n[Call Backend - Sparky + Standard]\n[Present Packages]\n</code></pre></p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#62-example-renegade-es300-minimal-y","title":"6.2 Example: Renegade ES300 (Minimal Y)","text":"<p>Turn 1: S1 PowerSource <pre><code>User: \"Renegade ES300\"\n\n[Direct Lookup]\nFound: Renegade ES300 (0445250880)\n\n[Check Applicability]\nFeeder=N, Cooler=N, Interconnect=N, Torch=Y\n\n[Auto-Fill NA]\nResponse JSON:\n- Feeder: {gin: \"NA\", description: \"Not Applicable\"}\n- Cooler: {gin: \"NA\", description: \"Not Applicable\"}\n- Interconnect: {gin: \"NA\", description: \"Not Applicable\"}\n\nSystem: \"Selected Renegade ES300!\n\nThis power source doesn't require:\n\u2022 Feeder: Not Applicable\n\u2022 Cooler: Not Applicable\n\u2022 Interconnect: Not Applicable\n\nLet's select your torch...\"\n\n[Skip directly to S5]\n</code></pre></p> <p>Turn 2: S5 Torch <pre><code>User: \"300A air-cooled\"\n\n[Search &amp; Add]\nResponse JSON Torch: {gin: \"...\", description: \"TIG Torch 300A\"}\n\nSystem: \"Your package:\n\u2022 PowerSource: Renegade ES300\n\u2022 Torch: TIG Torch 300A\n\nThis has only 2 real components. You need at least 3 to generate packages.\nWould you like to add accessories?\"\n</code></pre></p> <p>Turn 3: S6 Accessories <pre><code>User: \"Yes, add accessories\"\n\n[Show accessory options]\nUser selects 2 accessories\n\nResponse JSON:\n- Accessory1: {gin: \"...\", description: \"Welding Helmet\"}\n- Accessory2: {gin: \"...\", description: \"Gloves\"}\n\nReal components now: 4 (\u22653 \u2713)\n\nSystem: \"Ready to generate packages?\"\n</code></pre></p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#7-implementation-checklist","title":"7. Implementation Checklist","text":"<ul> <li> Update ConversationalManager with state-by-state logic</li> <li> Implement per-state prompt templates</li> <li> Integrate Master JSON extraction per state</li> <li> Add Neo4j search after parameter collection</li> <li> Implement product list presentation (1 vs multiple)</li> <li> Add user selection handling</li> <li> Integrate Component Applicability checking</li> <li> Implement NA auto-fill after S1</li> <li> Add dynamic state skipping</li> <li> Implement threshold validation at S7</li> <li> Add user confirmation handling at S7</li> <li> Test Aristo 500ix flow (all Y)</li> <li> Test Renegade ES300 flow (minimal Y)</li> <li> Test skip functionality</li> </ul>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#8-success-criteria","title":"8. Success Criteria","text":"<p>\u2705 Sequential Progression: States processed in order S1\u2192SN (configuration-driven) \u2705 Parameter Collection: Each state collects parameters before searching \u2705 Neo4j Search: Only when \u22651 parameter for component \u2705 Product Selection: User selects from list or direct match \u2705 Component Applicability: N components auto-filled as NA \u2705 Dynamic Skipping: System skips N states automatically \u2705 Threshold Validation: Blocks generation if &lt; 3 components \u2705 User Confirmation: Requires explicit confirmation at S7</p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#9-compatibility-validation-matrix","title":"9. Compatibility Validation Matrix","text":""},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#91-neo4j-category-reference","title":"9.1 Neo4j Category Reference","text":"<pre><code>Categories:\n  - PowerSource\n  - Feeder\n  - FeederAccessory\n  - Cooler\n  - Interconnector\n  - Torch\n  - PowerSourceAccessory\n  - ConnectivityAccessory\n  - Remote\n  - Accessory\n</code></pre>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#92-component-compatibility-rules","title":"9.2 Component Compatibility Rules","text":"<p>S1: PowerSource - No compatibility validation (first component) - Cannot be skipped</p> <p>S2: Feeder - Compatible with: PowerSource <pre><code>MATCH (ps:Product {gin: $power_source_gin})-[:COMPATIBLE_WITH]-(f:Product)\nWHERE f.category = 'Feeder'\n</code></pre></p> <p>S3: Cooler - Compatible with: PowerSource AND Feeder (if selected) <pre><code>MATCH (ps:Product {gin: $power_source_gin})-[:COMPATIBLE_WITH]-(c:Product)\nWHERE c.category = 'Cooler'\n  AND ($feeder_gin IS NULL OR EXISTS((c)-[:COMPATIBLE_WITH]-(:Product {gin: $feeder_gin})))\n</code></pre></p> <p>S4: Interconnector - Compatible with: PowerSource, Feeder, Cooler (all selected components) <pre><code>MATCH (ps:Product {gin: $power_source_gin})-[:COMPATIBLE_WITH]-(ic:Product)\nWHERE ic.category = 'Interconnector'\n  AND ($feeder_gin IS NULL OR EXISTS((ic)-[:COMPATIBLE_WITH]-(:Product {gin: $feeder_gin})))\n  AND ($cooler_gin IS NULL OR EXISTS((ic)-[:COMPATIBLE_WITH]-(:Product {gin: $cooler_gin})))\n</code></pre></p> <p>S5: Torch - Compatible with: Feeder AND Cooler (if selected) - Note: NOT directly with PowerSource <pre><code>MATCH (base:Product {gin: $feeder_gin})-[:COMPATIBLE_WITH]-(t:Product)\nWHERE t.category = 'Torch'\n  AND ($cooler_gin IS NULL OR EXISTS((t)-[:COMPATIBLE_WITH]-(:Product {gin: $cooler_gin})))\n</code></pre></p> <p>S6: Accessories (Category-Specific)</p> <pre><code>PowerSourceAccessory:\n  compatible_with: [PowerSource]\n  query: |\n    MATCH (ps:Product {gin: $power_source_gin})-[:COMPATIBLE_WITH]-(a:Product)\n    WHERE a.category = 'PowerSourceAccessory'\n\nFeederAccessory:\n  compatible_with: [Feeder]\n  query: |\n    MATCH (f:Product {gin: $feeder_gin})-[:COMPATIBLE_WITH]-(a:Product)\n    WHERE a.category = 'FeederAccessory'\n\nConnectivityAccessory:\n  compatible_with: [PowerSource, Feeder]\n  query: |\n    MATCH (ps:Product {gin: $power_source_gin})-[:COMPATIBLE_WITH]-(a:Product)\n    WHERE a.category = 'ConnectivityAccessory'\n      AND ($feeder_gin IS NULL OR EXISTS((a)-[:COMPATIBLE_WITH]-(:Product {gin: $feeder_gin})))\n\nRemote:\n  compatible_with: [PowerSource, Feeder]\n  query: |\n    MATCH (ps:Product {gin: $power_source_gin})-[:COMPATIBLE_WITH]-(r:Product)\n    WHERE r.category = 'Remote'\n      AND ($feeder_gin IS NULL OR EXISTS((r)-[:COMPATIBLE_WITH]-(:Product {gin: $feeder_gin})))\n</code></pre>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#93-skip-behavior-compatibility","title":"9.3 Skip Behavior &amp; Compatibility","text":"<p>When Component is Skipped: - Skipped components are NOT included in compatibility validation - Example: If Feeder is skipped at S2   - S3 (Cooler): Only validate compatibility with PowerSource   - S4 (Interconnector): Only validate compatibility with PowerSource + Cooler   - S5 (Torch): Only validate compatibility with Cooler (if selected)</p> <p>Example Flow with Skips: <pre><code>S1: PowerSource = Aristo 500ix (0446200880)\nS2: Feeder = SKIPPED\nS3: Cooler = Cool Mate 3 (K2584-1)\n  \u2713 Validate: Compatible with PowerSource only\nS4: Interconnector = SKIPPED\nS5: Torch = Bernard Q400\n  \u2713 Validate: Compatible with Cooler only (Feeder was skipped)\n</code></pre></p>"},{"location":"CORRECTED_STATE_FLOW_ARCHITECTURE/#94-compatibility-query-pattern-template","title":"9.4 Compatibility Query Pattern Template","text":"<pre><code>def build_compatibility_query(\n    component_category: str,\n    master_json: dict,\n    response_json: dict\n) -&gt; tuple[str, dict]:\n    \"\"\"\n    Build Neo4j query with compatibility validation\n\n    Returns: (query_string, parameters_dict)\n    \"\"\"\n\n    # Get previously selected components\n    power_source_gin = response_json.get(\"PowerSource\", {}).get(\"gin\")\n    feeder_gin = response_json.get(\"Feeder\", {}).get(\"gin\")\n    cooler_gin = response_json.get(\"Cooler\", {}).get(\"gin\")\n    interconnect_gin = response_json.get(\"Interconnect\", {}).get(\"gin\")\n\n    # Build base query\n    query = f\"\"\"\n    MATCH (ps:Product {{gin: $power_source_gin}})-[:COMPATIBLE_WITH]-(target:Product)\n    WHERE target.category = $category\n    \"\"\"\n\n    # Add component-specific compatibility checks\n    if component_category == \"Feeder\":\n        # Only PowerSource compatibility (already in base query)\n        pass\n\n    elif component_category == \"Cooler\":\n        query += \"\"\"\n        AND ($feeder_gin IS NULL OR $feeder_gin = ''\n             OR EXISTS((target)-[:COMPATIBLE_WITH]-(:Product {gin: $feeder_gin})))\n        \"\"\"\n\n    elif component_category == \"Interconnector\":\n        query += \"\"\"\n        AND ($feeder_gin IS NULL OR $feeder_gin = ''\n             OR EXISTS((target)-[:COMPATIBLE_WITH]-(:Product {gin: $feeder_gin})))\n        AND ($cooler_gin IS NULL OR $cooler_gin = ''\n             OR EXISTS((target)-[:COMPATIBLE_WITH]-(:Product {gin: $cooler_gin})))\n        \"\"\"\n\n    elif component_category == \"Torch\":\n        # Torch is special - compatible with Feeder/Cooler, not PowerSource\n        query = \"\"\"\n        MATCH (base:Product)\n        WHERE (\n          ($feeder_gin IS NOT NULL AND $feeder_gin != '' AND base.gin = $feeder_gin)\n          OR ($feeder_gin IS NULL OR $feeder_gin = '') AND base.gin = $power_source_gin\n        )\n        MATCH (base)-[:COMPATIBLE_WITH]-(target:Product)\n        WHERE target.category = $category\n          AND ($cooler_gin IS NULL OR $cooler_gin = ''\n               OR EXISTS((target)-[:COMPATIBLE_WITH]-(:Product {gin: $cooler_gin})))\n        \"\"\"\n\n    # Add Master JSON parameter filters\n    query += build_parameter_filters(component_category, master_json)\n\n    query += \"\"\"\n    RETURN target\n    LIMIT 5\n    \"\"\"\n\n    # Build parameters\n    params = {\n        \"category\": component_category,\n        \"power_source_gin\": power_source_gin,\n        \"feeder_gin\": feeder_gin or \"\",\n        \"cooler_gin\": cooler_gin or \"\",\n        **extract_component_parameters(component_category, master_json)\n    }\n\n    return query, params\n</code></pre> <p>Status: Architecture Updated - Compatibility Validation Added Version: 2.0 Next: Get approval on updated architecture, then implement state-by-state handlers</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/","title":"Database Connection Architecture","text":"<p>Files: - <code>src/backend/app/database/database.py</code> - <code>src/backend/app/database/redis_session_storage.py</code> - <code>src/backend/app/database/postgres_archival.py</code> - <code>src/backend/app/main.py</code> (lifespan management)</p> <p>Comprehensive guide to database connection management, leak prevention, session storage, and connection lifecycle in the ESAB Welding Equipment Configurator.</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#overview","title":"Overview","text":"<p>The configurator uses three databases with different purposes and connection management strategies:</p> <ol> <li>Redis - Hot session data with TTL (3600s default)</li> <li>PostgreSQL - Archival storage for completed sessions</li> <li>Neo4j - Read-only product catalog with graph relationships</li> </ol> <p>Architecture Pattern: Singleton managers + Async connection pooling + Graceful degradation</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#connection-managers","title":"Connection Managers","text":""},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#1-redismanager-hot-session-data","title":"1. RedisManager - Hot Session Data","text":"<pre><code>class RedisManager:\n    \"\"\"\n    Redis manager for hot session data and LangGraph checkpoints.\n\n    Features:\n    - Session state caching (24hr TTL)\n    - LangGraph checkpoint storage\n    - Async connection pooling\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize Redis manager with .env configuration.\"\"\"\n        self.redis_url = os.getenv(\"REDIS_URL\")\n        self.redis_host = os.getenv(\"REDIS_HOST\", \"localhost\")\n        self.redis_port = int(os.getenv(\"REDIS_PORT\", \"6379\"))\n        self.redis_password = os.getenv(\"REDIS_PASSWORD\")\n        self.redis_db = int(os.getenv(\"REDIS_DB\", \"0\"))\n        self.enable_caching = os.getenv(\"ENABLE_REDIS_CACHING\", \"true\").lower() == \"true\"\n        self.cache_ttl = int(os.getenv(\"CACHE_TTL\", \"3600\"))\n\n        self.client: Optional[Redis] = None\n        self._initialized = False\n\n    async def init_redis(self):\n        \"\"\"Initialize Redis connection.\"\"\"\n        if self._initialized:\n            return\n\n        try:\n            # Use REDIS_URL if available, otherwise construct from components\n            if self.redis_url:\n                self.client = Redis.from_url(\n                    self.redis_url,\n                    decode_responses=True,\n                    encoding=\"utf-8\"\n                )\n            else:\n                self.client = Redis(\n                    host=self.redis_host,\n                    port=self.redis_port,\n                    password=self.redis_password,\n                    db=self.redis_db,\n                    decode_responses=True,\n                    encoding=\"utf-8\"\n                )\n\n            # Test connection\n            await self.client.ping()\n            self._initialized = True\n            logger.info(f\"Redis connected: {self.redis_host}:{self.redis_port}\")\n\n        except Exception as e:\n            logger.error(f\"Redis connection failed: {e}\")\n            self.client = None\n            raise\n\n    async def close(self):\n        \"\"\"Close Redis connection.\"\"\"\n        if self.client:\n            await self.client.close()\n            logger.info(\"Redis connection closed\")\n</code></pre> <p>Key Features: - Lazy Initialization: Only connects when first needed - Connection Testing: <code>PING</code> command verifies connectivity - Flexible Configuration: Supports <code>REDIS_URL</code> or individual components - Graceful Failure: Logs error and raises exception for upstream handling - Decode Responses: Automatically decodes bytes to UTF-8 strings - Singleton Pattern: Single client instance per application</p> <p>Environment Variables: <pre><code>REDIS_URL=redis://localhost:6379/0          # OR individual components:\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_PASSWORD=your-password\nREDIS_DB=0\nENABLE_REDIS_CACHING=true\nCACHE_TTL=3600\n</code></pre></p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#2-postgresqlmanager-archival-storage","title":"2. PostgreSQLManager - Archival Storage","text":"<pre><code>class PostgreSQLManager:\n    \"\"\"\n    PostgreSQL manager for archival storage and analytics.\n\n    Features:\n    - Session archival (permanent storage)\n    - Analytics queries\n    - Async SQLAlchemy session management\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize PostgreSQL manager with .env configuration.\"\"\"\n        self.postgres_host = os.getenv(\"POSTGRES_HOST\", \"localhost\")\n        self.postgres_port = int(os.getenv(\"POSTGRES_PORT\", \"5432\"))\n        self.postgres_db = os.getenv(\"POSTGRES_DB\", \"pconfig\")\n        self.postgres_user = os.getenv(\"POSTGRES_USER\", \"postgres\")\n        self.postgres_password = os.getenv(\"POSTGRES_PASSWORD\", \"root\")\n\n        self.engine = None\n        self.session_factory = None\n        self._initialized = False\n\n    def init_db(self):\n        \"\"\"Initialize PostgreSQL engine and session factory.\"\"\"\n        if self._initialized:\n            return\n\n        # Create async database URL\n        database_url = (\n            f\"postgresql+asyncpg://{self.postgres_user}:\"\n            f\"{self.postgres_password}@{self.postgres_host}:\"\n            f\"{self.postgres_port}/{self.postgres_db}\"\n        )\n\n        # Create async engine\n        self.engine = create_async_engine(\n            database_url,\n            echo=False,  # Set to True for SQL debugging\n            poolclass=NullPool,  # Use NullPool to avoid connection pool conflicts\n            future=True\n        )\n\n        # Create session factory\n        self.session_factory = async_sessionmaker(\n            bind=self.engine,\n            class_=AsyncSession,\n            expire_on_commit=False,\n            autoflush=True,\n            autocommit=False\n        )\n\n        self._initialized = True\n        logger.info(f\"PostgreSQL connected: {self.postgres_host}:{self.postgres_port}/{self.postgres_db}\")\n\n    async def close(self):\n        \"\"\"Close PostgreSQL engine.\"\"\"\n        if self.engine:\n            await self.engine.dispose()\n            logger.info(\"PostgreSQL engine disposed\")\n</code></pre> <p>Key Features: - NullPool Strategy: Prevents connection pool conflicts in async context - Session Factory: Creates new sessions on-demand with proper async configuration - expire_on_commit=False: Prevents ORM from expiring objects after commit - autoflush=True: Automatically flushes changes before queries - AsyncPG Driver: Fast async PostgreSQL driver for Python</p> <p>Connection Leak Prevention: <pre><code>async def get_postgres_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    \"\"\"\n    Dependency for getting PostgreSQL session.\n\n    Yields:\n        SQLAlchemy async session\n    \"\"\"\n    if not postgresql_manager._initialized:\n        postgresql_manager.init_db()\n\n    async with postgresql_manager.session_factory() as session:\n        try:\n            yield session\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()  # \u2705 ALWAYS closes session (leak prevention)\n</code></pre></p> <p>Why NullPool? - Problem: Default connection pool can cause issues with async SQLAlchemy - Solution: NullPool creates fresh connection for each request and closes immediately - Trade-off: Slightly higher latency vs guaranteed leak prevention</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#3-neo4jmanager-product-catalog-singleton-pattern","title":"3. Neo4jManager - Product Catalog (Singleton Pattern)","text":"<pre><code>class Neo4jManager:\n    \"\"\"\n    Neo4j driver manager with centralized connection pooling.\n\n    Features:\n    - Single driver instance (singleton pattern)\n    - Connection pooling coordination\n    - Health checks and monitoring\n    - Automatic reconnection on failures\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize Neo4j manager with configuration.\"\"\"\n        self.uri: Optional[str] = None\n        self.username: Optional[str] = None\n        self.password: Optional[str] = None\n        self.driver: Optional[object] = None  # AsyncDriver type\n        self._initialized = False\n        self._reconnect_attempts = 0\n        self._max_reconnect_attempts = 3\n\n        # Connection pool configuration\n        self._max_connection_lifetime = 3600  # 1 hour\n        self._max_connection_pool_size = 50\n        self._connection_acquisition_timeout = 60  # seconds\n\n    async def init_neo4j(\n        self,\n        uri: str,\n        username: str,\n        password: str\n    ):\n        \"\"\"\n        Initialize Neo4j driver with connection pooling.\n\n        Args:\n            uri: Neo4j connection URI (bolt:// or neo4j://)\n            username: Neo4j username\n            password: Neo4j password\n        \"\"\"\n        if self._initialized:\n            logger.info(\"Neo4j already initialized\")\n            return\n\n        self.uri = uri\n        self.username = username\n        self.password = password\n\n        try:\n            # Import here to avoid circular dependency\n            from neo4j import AsyncGraphDatabase\n\n            # Create driver with connection pool configuration\n            # Note: encrypted parameter can only be used with bolt:// and neo4j:// schemes\n            # For bolt+s:// and neo4j+s:// schemes, encryption is implicit and should not be specified\n            driver_config = {\n                \"auth\": (username, password),\n                \"max_connection_lifetime\": self._max_connection_lifetime,\n                \"max_connection_pool_size\": self._max_connection_pool_size,\n                \"connection_acquisition_timeout\": self._connection_acquisition_timeout,\n            }\n\n            # Only add encrypted parameter for non-encrypted schemes\n            if uri.startswith(\"bolt://\") or uri.startswith(\"neo4j://\"):\n                driver_config[\"encrypted\"] = False  # Explicitly no encryption for development\n\n            self.driver = AsyncGraphDatabase.driver(uri, **driver_config)\n\n            # Health check - verify connection\n            await self._verify_connectivity()\n\n            self._initialized = True\n            self._reconnect_attempts = 0\n\n            logger.info(f\"\u2705 Neo4j driver initialized - URI: {uri}\")\n            logger.info(f\"   Connection pool: max_size={self._max_connection_pool_size}, \"\n                       f\"max_lifetime={self._max_connection_lifetime}s\")\n\n        except Exception as e:\n            logger.error(f\"\u274c Failed to initialize Neo4j driver: {e}\")\n            raise\n</code></pre> <p>Connection Pool Configuration: - max_connection_pool_size: 50 concurrent connections (prevents resource exhaustion) - max_connection_lifetime: 3600s (1 hour) - prevents stale connections - connection_acquisition_timeout: 60s - timeout waiting for available connection</p> <p>Health Check System: <pre><code>async def _verify_connectivity(self):\n    \"\"\"\n    Verify Neo4j connection with simple query.\n\n    Raises:\n        Exception if connection fails\n    \"\"\"\n    if not self.driver:\n        raise ValueError(\"Driver not initialized\")\n\n    try:\n        async with self.driver.session() as session:\n            result = await session.run(\"RETURN 1 as test\")\n            record = await result.single()\n            assert record[\"test\"] == 1\n\n        logger.info(\"\u2705 Neo4j connectivity verified\")\n\n    except Exception as e:\n        logger.error(f\"\u274c Neo4j connectivity check failed: {e}\")\n        raise\n</code></pre></p> <p>Automatic Reconnection Strategy: <pre><code>async def get_driver(self):\n    \"\"\"\n    Get Neo4j driver instance with automatic reconnection.\n\n    Returns:\n        AsyncDriver instance\n\n    Raises:\n        RuntimeError if driver not initialized or reconnection fails\n    \"\"\"\n    if not self._initialized or not self.driver:\n        raise RuntimeError(\"Neo4j driver not initialized. Call init_neo4j() first.\")\n\n    # Import here to avoid circular dependency\n    from neo4j.exceptions import ServiceUnavailable, SessionExpired\n\n    # Check if driver is still connected\n    try:\n        await self._verify_connectivity()\n        self._reconnect_attempts = 0  # Reset on success\n        return self.driver\n\n    except (ServiceUnavailable, SessionExpired) as e:\n        logger.warning(f\"\u26a0\ufe0f Neo4j connection lost: {e}\")\n\n        # Attempt reconnection\n        if self._reconnect_attempts &lt; self._max_reconnect_attempts:\n            logger.info(f\"\ud83d\udd04 Attempting reconnection ({self._reconnect_attempts + 1}/{self._max_reconnect_attempts})\")\n            await self._reconnect()\n            return self.driver\n        else:\n            logger.error(f\"\u274c Max reconnection attempts ({self._max_reconnect_attempts}) exceeded\")\n            raise RuntimeError(\"Neo4j connection lost and reconnection failed\")\n\nasync def _reconnect(self):\n    \"\"\"\n    Attempt to reconnect to Neo4j with exponential backoff.\n    \"\"\"\n    import asyncio\n\n    self._reconnect_attempts += 1\n\n    # Exponential backoff\n    delay = min(2 ** self._reconnect_attempts, 30)  # Max 30 seconds\n    logger.info(f\"Waiting {delay}s before reconnection attempt...\")\n    await asyncio.sleep(delay)\n\n    try:\n        # Close existing driver\n        if self.driver:\n            await self.driver.close()\n\n        # Reinitialize\n        self._initialized = False\n        await self.init_neo4j(self.uri, self.username, self.password)\n\n        logger.info(\"\u2705 Neo4j reconnection successful\")\n\n    except Exception as e:\n        logger.error(f\"\u274c Reconnection attempt failed: {e}\")\n        raise\n</code></pre></p> <p>Reconnection Algorithm: 1. Detection: ServiceUnavailable or SessionExpired exceptions 2. Exponential Backoff: 2^n delay (max 30 seconds) 3. Driver Cleanup: Close stale driver before reconnecting 4. Reinitialization: Full driver reinit with health check 5. Retry Limit: Maximum 3 attempts before failure</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#redis-session-storage","title":"Redis Session Storage","text":""},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#session-storage-architecture","title":"Session Storage Architecture","text":"<p>RedisSessionStorage provides Redis-backed session persistence with automatic fallback to in-memory storage.</p> <pre><code>class RedisSessionStorage:\n    \"\"\"\n    Redis-backed session storage service.\n\n    Features:\n    - Session caching with configurable TTL\n    - Hash-based payload storage for structured metadata\n    - Session lifecycle management and user mapping\n    \"\"\"\n\n    def __init__(\n        self,\n        redis_client: Redis,\n        ttl: int = 3600,\n        *,\n        namespace: str = \"configurator:sessions\",\n        enable_sessions: bool = True,\n    ):\n        \"\"\"\n        Initialize Redis session storage.\n\n        Args:\n            redis_client: Redis async client\n            ttl: Time-to-live for sessions in seconds (default: 3600 = 1 hour)\n            namespace: Base key namespace\n            enable_sessions: Feature flag for full session caching behaviour\n        \"\"\"\n        self.redis = redis_client\n        self.ttl = ttl\n        self.namespace = namespace.rstrip(\":\")\n        self.user_namespace = f\"{self.namespace}:user\"\n        self.active_sessions_key = f\"{self.namespace}:active\"\n        self.enable_sessions = enable_sessions\n        self.schema_version = SESSION_SCHEMA_VERSION\n\n    def _session_key(self, session_id: str) -&gt; str:\n        \"\"\"Generate Redis key for session ID.\"\"\"\n        validated_id = _validate_session_id(session_id)\n        return f\"{self.namespace}:{validated_id}\"\n\n    def _user_sessions_key(self, user_id: str) -&gt; str:\n        \"\"\"Generate Redis key for user-session mapping set.\"\"\"\n        validated_id = _validate_identifier(user_id, \"user_id\")\n        return f\"{self.user_namespace}:{validated_id}\"\n</code></pre> <p>Redis Key Structure: <pre><code>configurator:sessions:{session_id}           # Hash - Session payload\nconfigurator:sessions:user:{user_id}         # Set - User's session IDs\nconfigurator:sessions:active                 # Sorted Set - Active sessions by timestamp\n</code></pre></p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#session-save-with-concurrency-safeguards","title":"Session Save with Concurrency Safeguards","text":"<pre><code>async def save_session(\n    self,\n    conversation_state: ConversationState,\n    *,\n    participants: Optional[Iterable[str]] = None,\n    metadata: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"\n    Save conversation state to Redis with TTL and user mapping.\n\n    Args:\n        conversation_state: Conversation state to save\n        participants: Optional explicit participants list\n        metadata: Optional metadata patch merged into state metadata\n    \"\"\"\n    if not self.enable_sessions:\n        logger.debug(\"Redis session caching disabled \u2013 skipping save\")\n        return\n\n    session_key = self._session_key(conversation_state.session_id)\n    now = _utc_now()\n    now_iso = now.isoformat()\n    now_ts = now.timestamp()\n\n    # Validate and sanitize participants\n    participant_set: Set[str] = set()\n    for participant in (participants or conversation_state.participants or []):\n        if participant:\n            try:\n                validated_participant = _validate_identifier(participant, \"participant\")\n                participant_set.add(validated_participant)\n\n                # Enforce participant limit to prevent DoS\n                if len(participant_set) &gt; _MAX_PARTICIPANTS:\n                    logger.warning(\n                        f\"Participant limit ({_MAX_PARTICIPANTS}) exceeded for session {conversation_state.session_id}\"\n                    )\n                    break\n            except ValueError as e:\n                logger.warning(f\"Skipping invalid participant ID: {e}\")\n                continue\n\n    # Validate and add owner\n    if conversation_state.owner_user_id:\n        try:\n            # Quick fix: replace spaces in owner_user_id\n            conversation_state.owner_user_id = conversation_state.owner_user_id.replace(' ', '-')\n\n            validated_owner = _validate_identifier(conversation_state.owner_user_id, \"owner_user_id\")\n            participant_set.add(validated_owner)\n            conversation_state.owner_user_id = validated_owner\n        except ValueError as e:\n            logger.error(f\"Invalid owner_user_id: {e}\")\n            raise\n\n    conversation_state.participants = sorted(participant_set)\n    conversation_state.last_updated = now\n    conversation_state.schema_version = self.schema_version\n\n    if metadata:\n        conversation_state.metadata.update(metadata)\n\n    state_payload = conversation_state.model_dump(mode=\"json\")\n    state_payload[\"current_state\"] = conversation_state.current_state.value\n    state_payload[\"last_updated\"] = now_iso\n    state_payload[\"schema_version\"] = self.schema_version\n\n    session_hash = {\n        \"currentState\": conversation_state.current_state.value,\n        \"state\": json.dumps(state_payload, default=str),\n        \"language\": conversation_state.language,\n        \"lastTouched\": now_iso,\n        \"schemaVersion\": str(self.schema_version),\n        \"participants\": json.dumps(conversation_state.participants),\n        \"metadata\": json.dumps(conversation_state.metadata or {}),\n        \"ownerUserId\": conversation_state.owner_user_id or \"\",\n        \"customerId\": conversation_state.customer_id or \"\",\n    }\n\n    # \ud83d\udd12 CONCURRENCY SAFEGUARD: Use WATCH + MULTI for atomic participant updates\n    while True:\n        try:\n            async with self.redis.pipeline(transaction=True) as pipe:\n                await pipe.watch(session_key)\n                existing_participants_raw = await pipe.hget(session_key, \"participants\")\n                existing_participants: Set[str] = set()\n                if existing_participants_raw:\n                    try:\n                        existing_participants = set(json.loads(existing_participants_raw))\n                    except json.JSONDecodeError:\n                        existing_participants = set()\n\n                added_participants = participant_set - existing_participants\n                removed_participants = existing_participants - participant_set\n\n                pipe.multi()\n                pipe.hset(session_key, mapping=session_hash)\n                pipe.expire(session_key, self.ttl)\n                pipe.zadd(self.active_sessions_key, {conversation_state.session_id: now_ts})\n                pipe.expire(self.active_sessions_key, max(self.ttl, 2 * self.ttl))\n\n                for user_id in added_participants:\n                    if not user_id:\n                        continue\n                    user_key = self._user_sessions_key(user_id)\n                    pipe.sadd(user_key, conversation_state.session_id)\n                    pipe.expire(user_key, self.ttl)\n\n                for user_id in removed_participants:\n                    if not user_id:\n                        continue\n                    pipe.srem(self._user_sessions_key(user_id), conversation_state.session_id)\n\n                await pipe.execute()\n\n                # \u2705 VISIBILITY VERIFICATION: Ensure write succeeded\n                for _ in range(3):\n                    cached = await self.redis.hget(session_key, \"state\")\n                    if not cached:\n                        await asyncio.sleep(0.05)\n                        continue\n\n                    decoded = cached.decode(\"utf-8\") if isinstance(cached, (bytes, bytearray)) else cached\n                    if decoded == session_hash[\"state\"]:\n                        break\n\n                    logger.warning(f\"Redis visibility delay for {conversation_state.session_id}, retrying...\")\n                    await asyncio.sleep(0.05)\n\n                logger.info(\"Saved session %s to Redis (TTL: %ss)\", conversation_state.session_id, self.ttl)\n                break\n\n        except WatchError:\n            logger.debug(\"Watch conflict while saving session %s, retrying\", conversation_state.session_id)\n            continue\n        except Exception as exc:\n            logger.error(\"Failed to save session %s to Redis: %s\", conversation_state.session_id, exc)\n            raise\n</code></pre> <p>Concurrency Safeguards: 1. WATCH + MULTI: Atomic participant updates (prevents race conditions) 2. Retry Loop: Automatic retry on WatchError (optimistic locking) 3. Visibility Verification: 3 retries with 50ms delay to ensure write succeeded 4. Participant Validation: Prevents Redis key injection attacks 5. Participant Limit: Max 50 participants (DoS prevention)</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#in-memory-fallback-storage","title":"In-Memory Fallback Storage","text":"<p>InMemorySessionStorage provides Redis-compatible API when Redis is unavailable.</p> <pre><code>class InMemorySessionStorage:\n    \"\"\"\n    In-memory fallback for session storage when Redis is unavailable or disabled.\n\n    Mimics Redis-backed behaviour to keep API paths consistent.\n    Includes TTL enforcement with background cleanup to prevent memory leaks.\n    \"\"\"\n\n    def __init__(self, ttl: int = 3600):\n        self._sessions: Dict[str, ConversationState] = {}\n        self._user_sessions: Dict[str, Set[str]] = {}\n        self._session_metadata: Dict[str, Dict[str, Any]] = {}  # Track creation time and TTL\n        self.ttl = ttl\n        self._cleanup_task: Optional[asyncio.Task] = None\n        self._shutdown = False\n\n        # Start background cleanup if TTL is enabled\n        if self.ttl &gt; 0:\n            logger.info(f\"Starting in-memory session cleanup task (TTL: {self.ttl}s)\")\n            self._cleanup_task = asyncio.create_task(self._cleanup_loop())\n\n    async def _cleanup_loop(self):\n        \"\"\"Background task to periodically clean up expired sessions.\"\"\"\n        logger.info(\"In-memory session cleanup loop started\")\n        try:\n            while not self._shutdown:\n                await asyncio.sleep(60)  # Check every 60 seconds\n                if self._shutdown:\n                    break\n                await self._cleanup_expired_sessions()\n        except asyncio.CancelledError:\n            logger.info(\"Session cleanup loop cancelled\")\n        except Exception as e:\n            logger.error(f\"Error in session cleanup loop: {e}\", exc_info=True)\n\n    async def _cleanup_expired_sessions(self):\n        \"\"\"Remove sessions that have exceeded their TTL.\"\"\"\n        now = _utc_now()\n        expired_sessions = []\n\n        for session_id, metadata in self._session_metadata.items():\n            created_at = metadata.get(\"created_at\")\n            if not created_at:\n                continue\n\n            # Calculate age in seconds\n            age_seconds = (now - created_at).total_seconds()\n\n            if age_seconds &gt; self.ttl:\n                expired_sessions.append(session_id)\n\n        if expired_sessions:\n            logger.info(f\"Cleaning up {len(expired_sessions)} expired sessions\")\n            for session_id in expired_sessions:\n                await self.delete_session(session_id)\n                self._session_metadata.pop(session_id, None)\n            logger.debug(f\"Removed expired sessions: {expired_sessions}\")\n</code></pre> <p>Key Features: - TTL Enforcement: Background task cleans up expired sessions every 60s - Memory Leak Prevention: Automatic cleanup prevents unbounded growth - Graceful Shutdown: Cleanup task stops cleanly on application shutdown - API Compatibility: Same methods as RedisSessionStorage (drop-in replacement)</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#application-lifespan-management","title":"Application Lifespan Management","text":""},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#startup-sequence-mainpy","title":"Startup Sequence (main.py)","text":"<pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan manager - startup and shutdown\"\"\"\n\n    # Startup\n    logger.info(\"Starting Recommender_v2 application...\")\n\n    # 1. Initialize Databases\n    logger.info(\"Initializing databases...\")\n\n    # Check if Redis is enabled via environment variable\n    enable_redis = os.getenv(\"ENABLE_REDIS_CACHING\", \"true\").lower() == \"true\"\n\n    if enable_redis:\n        try:\n            # Initialize Redis for hot session data\n            await init_redis()\n            logger.info(\"\u2713 Redis initialized\")\n\n            # Initialize Redis session storage\n            redis_client = await get_redis_client()\n            session_ttl = get_config_service().get_session_ttl()\n            init_redis_session_storage(redis_client, ttl=session_ttl)\n            logger.info(\"\u2713 Redis session storage initialized\")\n        except Exception as e:\n            logger.warning(f\"Redis initialization failed: {e}. Continuing without Redis caching.\")\n    else:\n        # Redis disabled - use in-memory session storage\n        logger.info(\"Redis disabled via ENABLE_REDIS_CACHING=false\")\n        session_ttl = get_config_service().get_session_ttl()\n        init_redis_session_storage(redis_client=None, ttl=session_ttl)\n        logger.info(\"\u2713 In-memory session storage initialized (no persistence across restarts)\")\n\n    try:\n        # Initialize PostgreSQL for archival\n        init_postgresql()\n        logger.info(\"\u2713 PostgreSQL initialized\")\n\n        # Create database tables\n        from sqlalchemy.ext.asyncio import create_async_engine\n        from .database.database import postgresql_manager\n\n        async with postgresql_manager.engine.begin() as conn:\n            await conn.run_sync(Base.metadata.create_all)\n\n        logger.info(\"\u2713 Database tables created/verified\")\n\n    except Exception as e:\n        logger.warning(f\"PostgreSQL initialization failed: {e}. Continuing without archival.\")\n\n    # Initialize Neo4j driver (centralized connection management)\n    await init_neo4j(neo4j_uri, neo4j_username, neo4j_password)\n    neo4j_driver = await get_neo4j_driver()\n    logger.info(\"\u2713 Neo4j driver initialized\")\n\n    yield\n\n    # Shutdown\n    logger.info(\"Shutting down Recommender_v2 application...\")\n\n    # Stop in-memory session storage cleanup task if running\n    try:\n        from .database.redis_session_storage import get_redis_session_storage\n        storage = get_redis_session_storage()\n        if storage and hasattr(storage, 'stop_cleanup_loop'):\n            await storage.stop_cleanup_loop()\n            logger.info(\"\u2713 Session storage cleanup task stopped\")\n    except Exception as e:\n        logger.error(f\"Error stopping session storage cleanup: {e}\")\n\n    # Close databases\n    try:\n        await close_redis()\n        logger.info(\"\u2713 Redis closed\")\n    except Exception as e:\n        logger.error(f\"Error closing Redis: {e}\")\n\n    try:\n        await close_postgresql()\n        logger.info(\"\u2713 PostgreSQL closed\")\n    except Exception as e:\n        logger.error(f\"Error closing PostgreSQL: {e}\")\n\n    # Close Neo4j (centralized driver management)\n    try:\n        await close_neo4j()\n        logger.info(\"\u2713 Neo4j driver closed\")\n    except Exception as e:\n        logger.error(f\"Error closing Neo4j: {e}\")\n\n    logger.info(\"Shutdown complete\")\n</code></pre> <p>Startup Order (Importance): 1. Redis - Optional (graceful degradation) 2. PostgreSQL - Optional (warning if unavailable) 3. Neo4j - Required (application cannot start without it)</p> <p>Graceful Degradation: - Redis failure \u2192 Automatic fallback to in-memory storage - PostgreSQL failure \u2192 Warning logged, archival disabled - Neo4j failure \u2192 Application startup fails (critical dependency)</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#connection-leak-prevention-strategies","title":"Connection Leak Prevention Strategies","text":""},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#1-context-managers-guaranteed-cleanup","title":"1. Context Managers (Guaranteed Cleanup)","text":"<p>PostgreSQL Session Management: <pre><code>async def get_postgres_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    \"\"\"Dependency injection for PostgreSQL sessions with guaranteed cleanup.\"\"\"\n    if not postgresql_manager._initialized:\n        postgresql_manager.init_db()\n\n    async with postgresql_manager.session_factory() as session:\n        try:\n            yield session\n        except Exception:\n            await session.rollback()  # \u2705 Rollback on error\n            raise\n        finally:\n            await session.close()  # \u2705 ALWAYS close (even on exception)\n</code></pre></p> <p>Neo4j Session Management: <pre><code># Neo4j driver handles session lifecycle internally via connection pool\nasync with neo4j_driver.session() as session:\n    result = await session.run(\"RETURN 1\")\n    # Session automatically returns to pool after context exit\n</code></pre></p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#2-redis-connection-pooling","title":"2. Redis Connection Pooling","text":"<p>Redis async client maintains internal connection pool with automatic lifecycle management:</p> <pre><code># Redis connection created with implicit pool\nself.client = Redis(\n    host=self.redis_host,\n    port=self.redis_port,\n    password=self.redis_password,\n    db=self.redis_db,\n    decode_responses=True,  # Prevents memory leaks from byte accumulation\n    encoding=\"utf-8\"\n)\n\n# Connections automatically returned to pool after operation\nawait self.client.set(\"key\", \"value\")\n# Connection released automatically\n</code></pre> <p>Benefits: - Automatic Pooling: Redis client manages connection lifecycle - No Manual Cleanup: Connections released after each operation - Decode Responses: Prevents memory leaks from byte object accumulation</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#3-singleton-pattern-single-driver-instance","title":"3. Singleton Pattern (Single Driver Instance)","text":"<p>Neo4j uses singleton driver to prevent connection proliferation:</p> <pre><code># Global manager instance (singleton)\nneo4j_manager = Neo4jManager()\n\nasync def init_neo4j(uri: str, username: str, password: str):\n    \"\"\"Initialize Neo4j connection manager - only once per application.\"\"\"\n    await neo4j_manager.init_neo4j(uri, username, password)\n\nasync def get_neo4j_driver():\n    \"\"\"Get Neo4j driver instance - reuses existing driver.\"\"\"\n    return await neo4j_manager.get_driver()\n</code></pre> <p>Why Singleton? - Problem: Creating multiple drivers exhausts connection pools - Solution: Single driver instance shared across entire application - Benefit: Efficient connection pooling with bounded resource usage</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#4-nullpool-for-postgresql-anti-leak-strategy","title":"4. NullPool for PostgreSQL (Anti-Leak Strategy)","text":"<p>PostgreSQL uses NullPool to prevent connection leaks:</p> <pre><code># Create async engine with NullPool\nself.engine = create_async_engine(\n    database_url,\n    echo=False,\n    poolclass=NullPool,  # \u2705 No connection pooling = no leaks\n    future=True\n)\n</code></pre> <p>Trade-offs: - Pro: Zero risk of connection leaks (fresh connection per request) - Pro: No pool exhaustion issues - Con: Slightly higher latency (connection overhead per request) - Use Case: Async applications with variable concurrency</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#schema-migration-system","title":"Schema Migration System","text":""},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#automatic-schema-version-migration","title":"Automatic Schema Version Migration","text":"<pre><code>def _migrate_session_schema(self, payload: Dict[str, Any], session_id: str) -&gt; bool:\n    \"\"\"\n    Migrate session payload from old schema to current schema.\n\n    Args:\n        payload: Session payload dictionary (will be mutated in-place)\n        session_id: Session ID for logging\n\n    Returns:\n        True if migration was performed, False otherwise\n    \"\"\"\n    stored_version = payload.get(\"schema_version\", 0)\n\n    # No migration needed if already at current version\n    if stored_version == self.schema_version:\n        return False\n\n    logger.info(\n        \"Migrating session %s from schema v%d to v%d\",\n        session_id,\n        stored_version,\n        self.schema_version,\n    )\n\n    # Migration from v0 (no schema_version) to v1 (adds multi-user fields)\n    if stored_version == 0:\n        # Add missing multi-user fields with defaults\n        if \"owner_user_id\" not in payload:\n            payload[\"owner_user_id\"] = None\n        if \"customer_id\" not in payload:\n            payload[\"customer_id\"] = None\n        if \"participants\" not in payload:\n            payload[\"participants\"] = []\n        if \"metadata\" not in payload:\n            payload[\"metadata\"] = {}\n\n        # Update schema version\n        payload[\"schema_version\"] = 1\n\n    # Add future migrations here as schema evolves\n    # if stored_version == 1:\n    #     # Migration from v1 to v2\n    #     payload[\"new_field\"] = default_value\n    #     payload[\"schema_version\"] = 2\n\n    return True\n</code></pre> <p>Migration Strategy: 1. On-Read Migration: Schema upgraded when session is loaded from Redis 2. Backward Compatible: Old sessions work with new code 3. Auto-Save: Migrated sessions automatically saved back to Redis 4. Versioned: <code>schema_version</code> field tracks current version 5. Extensible: Easy to add new migration steps</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#ttl-management","title":"TTL Management","text":""},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#session-ttl-refresh","title":"Session TTL Refresh","text":"<pre><code>async def extend_ttl(self, session_id: str, ttl: Optional[int] = None):\n    \"\"\"\n    Extend TTL for an existing session and refresh activity markers.\n    \"\"\"\n    if not self.enable_sessions:\n        return\n\n    session_key = self._session_key(session_id)\n    new_ttl = ttl or self.ttl\n    now = _utc_now()\n    try:\n        async with self.redis.pipeline(transaction=False) as pipe:\n            pipe.expire(session_key, new_ttl)  # \u2705 Refresh key TTL\n            pipe.hset(session_key, mapping={\"lastTouched\": now.isoformat()})  # \u2705 Update timestamp\n            pipe.zadd(self.active_sessions_key, {session_id: now.timestamp()})  # \u2705 Update sorted set\n            await pipe.execute()\n    except Exception as exc:\n        logger.error(\"Failed to extend TTL for session %s: %s\", session_id, exc)\n\nasync def touch_session(self, session_id: str):\n    \"\"\"Refresh TTL and activity timestamp without altering payload.\"\"\"\n    await self.extend_ttl(session_id)\n</code></pre> <p>TTL Refresh Strategy: - On Every Read: <code>get_session()</code> automatically calls <code>touch_session()</code> - On Every Write: <code>save_session()</code> sets TTL via <code>EXPIRE</code> command - Three Updates: Session key + lastTouched field + active sessions sorted set</p>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#related-documentation","title":"Related Documentation","text":"<ul> <li>Agent 1: ParameterExtractor - LLM-based parameter extraction</li> <li>Agent 2: ProductSearch - Neo4j graph database search</li> <li>Agent 3: MessageGenerator - Response generation</li> <li>Orchestrator Architecture - StateByStateOrchestrator</li> <li>API Documentation - REST API endpoints and flow</li> </ul>"},{"location":"DATABASE_CONNECTION_ARCHITECTURE/#file-locations","title":"File Locations","text":"<p>Source Files: - <code>src/backend/app/database/database.py</code> - Connection managers (Redis, PostgreSQL, Neo4j) - <code>src/backend/app/database/redis_session_storage.py</code> - Session storage service - <code>src/backend/app/database/postgres_archival.py</code> - PostgreSQL archival service - <code>src/backend/app/main.py</code> - Application lifespan and initialization</p>"},{"location":"LANGGRAPH_INTEGRATION/","title":"LangGraph Integration Architecture","text":""},{"location":"LANGGRAPH_INTEGRATION/#overview","title":"Overview","text":"<p>The Recommender_v2 system now uses LangGraph for workflow orchestration with LangSmith observability integration. This architecture provides:</p> <ul> <li>\u2705 Stateful Workflow Management - LangGraph StateGraph for S1\u2192SN dynamic progression</li> <li>\u2705 Session Persistence - Redis checkpointing for hot data (24hr TTL)</li> <li>\u2705 Long-term Archival - PostgreSQL for completed sessions</li> <li>\u2705 Observability - LangSmith @traceable decorators for workflow monitoring</li> <li>\u2705 Graceful Degradation - System continues if Redis/PostgreSQL unavailable</li> </ul>"},{"location":"LANGGRAPH_INTEGRATION/#architecture-layers","title":"Architecture Layers","text":""},{"location":"LANGGRAPH_INTEGRATION/#1-database-layer","title":"1. Database Layer","text":""},{"location":"LANGGRAPH_INTEGRATION/#redis-hot-session-data","title":"Redis (Hot Session Data)","text":"<ul> <li>Purpose: Fast session state storage with checkpointing</li> <li>TTL: 24 hours (configurable via <code>REDIS_TTL_SECONDS</code>)</li> <li>Configuration: <code>.env</code> variables (REDIS_URL, REDIS_HOST, REDIS_PORT)</li> <li>Manager: <code>RedisManager</code> in <code>backend/app/database/database.py</code></li> <li>Initialization: Async startup in <code>main.py</code> lifespan()</li> </ul> <pre><code># Redis Configuration\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_TTL_SECONDS=86400  # 24 hours\n</code></pre> <p>Features: - Connection pooling with <code>redis.asyncio.Redis</code> - Health check integration - Graceful degradation (app continues without Redis)</p>"},{"location":"LANGGRAPH_INTEGRATION/#postgresql-long-term-archival","title":"PostgreSQL (Long-term Archival)","text":"<ul> <li>Purpose: Archive completed sessions for analytics</li> <li>Driver: <code>asyncpg</code> for high-performance async operations</li> <li>ORM: SQLAlchemy 2.0 with async support</li> <li>Configuration: <code>.env</code> variables (POSTGRES_HOST, POSTGRES_PORT, POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB)</li> <li>Manager: <code>PostgreSQLManager</code> in <code>backend/app/database/database.py</code></li> </ul> <pre><code># PostgreSQL Configuration\nPOSTGRES_HOST=localhost\nPOSTGRES_PORT=5432\nPOSTGRES_USER=pconfig\nPOSTGRES_PASSWORD=your_password\nPOSTGRES_DB=pconfig\n</code></pre> <p>Schema: <pre><code>CREATE TABLE archived_sessions (\n    session_id VARCHAR(255) PRIMARY KEY,\n    master_parameters JSONB NOT NULL,\n    response_json JSONB NOT NULL,\n    conversation_messages JSONB NOT NULL,\n    agent_actions JSONB,\n    current_state VARCHAR(100),\n    user_selected_products JSONB,\n    compatibility_check_results JSONB,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    completed_at TIMESTAMP\n);\n\nCREATE INDEX idx_archived_sessions_created ON archived_sessions(created_at);\nCREATE INDEX idx_archived_sessions_state ON archived_sessions(current_state);\n</code></pre></p> <p>Archival Service: <code>PostgresArchivalService</code> in <code>backend/app/database/postgres_archival.py</code></p>"},{"location":"LANGGRAPH_INTEGRATION/#2-langgraph-state-models","title":"2. LangGraph State Models","text":""},{"location":"LANGGRAPH_INTEGRATION/#configuratorgraphstate-typeddict","title":"ConfiguratorGraphState (TypedDict)","text":"<p>Bridge between Pydantic <code>ConversationState</code> and LangGraph's TypedDict requirements.</p> <p>Location: <code>backend/app/models/graph_state.py</code></p> <pre><code>class ConfiguratorGraphState(TypedDict, total=False):\n    # Session &amp; State\n    session_id: str\n    thread_id: str\n    current_state: str\n\n    # Core Data\n    master_parameters: Dict[str, Any]\n    response_json: Dict[str, Any]\n\n    # Communication\n    messages: Annotated[List[Dict[str, str]], operator.add]\n\n    # Observability\n    agent_actions: Annotated[List[Dict[str, Any]], operator.add]\n    llm_extractions: List[Dict[str, Any]]\n    neo4j_queries: List[Dict[str, Any]]\n    state_transitions: List[Dict[str, Any]]\n</code></pre> <p>Key Features: - <code>Annotated[List, operator.add]</code> for append-only lists (messages, agent_actions) - Conversion functions: <code>conversation_state_to_graph_state()</code> and <code>graph_state_to_conversation_state()</code> - Pydantic models for observability: <code>AgentAction</code>, <code>Neo4jQuery</code>, <code>LLMExtraction</code>, <code>StateTransition</code></p>"},{"location":"LANGGRAPH_INTEGRATION/#3-langgraph-workflow","title":"3. LangGraph Workflow","text":""},{"location":"LANGGRAPH_INTEGRATION/#configuratorgraph","title":"ConfiguratorGraph","text":"<p>4-node workflow orchestrating the S1\u2192SN configurator.</p> <p>Location: <code>backend/app/services/graph/configurator_graph.py</code></p> <p>Nodes: 1. extract_parameters - LLM parameter extraction with schema-driven MasterParameterJSON 2. search_products - Neo4j product search based on extracted parameters 3. generate_response - Conversational response generation 4. determine_next_state - State machine logic for S1\u2192SN progression</p> <p>Workflow: <pre><code>START \u2192 extract_parameters \u2192 search_products \u2192 generate_response \u2192 determine_next_state \u2192 END\n</code></pre></p> <p>Code Structure: <pre><code>class ConfiguratorGraph:\n    def __init__(\n        self,\n        parameter_extractor: ParameterExtractor,\n        product_search: Neo4jProductSearch,\n        message_generator: MessageGenerator,\n        component_applicability_config: Dict,\n        redis_url: str = None\n    ):\n        self.graph = self._build_graph()\n\n        # Redis checkpointing\n        checkpointer = RedisSaver.from_conn_string(redis_url)\n        self.app = self.graph.compile(checkpointer=checkpointer)\n\n    @traceable(name=\"extract_parameters\", run_type=\"llm\")\n    async def extract_parameters_node(self, state: ConfiguratorGraphState):\n        # LLM parameter extraction\n        # Returns updated state with master_parameters\n\n    @traceable(name=\"search_products\", run_type=\"chain\")\n    async def search_products_node(self, state: ConfiguratorGraphState):\n        # Neo4j product search\n        # Returns updated state with products\n\n    @traceable(name=\"generate_response\", run_type=\"llm\")\n    async def generate_response_node(self, state: ConfiguratorGraphState):\n        # Conversational response generation\n        # Returns updated state with message\n\n    @traceable(name=\"determine_next_state\", run_type=\"tool\")\n    async def determine_next_state_node(self, state: ConfiguratorGraphState):\n        # State machine logic\n        # Returns updated state with current_state\n</code></pre></p> <p>LangSmith Integration: - Each node decorated with <code>@traceable</code> for run tracking - Captures inputs, outputs, and execution time - Enables LangSmith UI visualization</p>"},{"location":"LANGGRAPH_INTEGRATION/#4-observability-service","title":"4. Observability Service","text":""},{"location":"LANGGRAPH_INTEGRATION/#langsmithservice","title":"LangSmithService","text":"<p>Centralized observability service for workflow tracking.</p> <p>Location: <code>backend/app/services/observability/langsmith_service.py</code></p> <p>Configuration: <pre><code># .env\nLANGSMITH_API_KEY=your_api_key\nLANGSMITH_PROJECT=Recommender  # Optional, defaults to \"Recommender\"\n</code></pre></p> <p>Features: - <code>track_workflow_execution()</code> - Track complete workflow runs - <code>log_agent_action()</code> - Log individual agent actions - <code>log_performance_metrics()</code> - Log performance data - <code>log_error()</code> - Centralized error logging</p> <p>Usage: <pre><code>from .services.observability.langsmith_service import langsmith_service\n\n# Check if enabled\nif langsmith_service.is_enabled():\n    # Track workflow\n    await langsmith_service.track_workflow_execution(\n        session_id=\"abc123\",\n        user_message=\"I need a 500A power source\",\n        current_state=\"power_source_selection\",\n        result={\"message\": \"Response text\"}\n    )\n</code></pre></p>"},{"location":"LANGGRAPH_INTEGRATION/#integration-points","title":"Integration Points","text":""},{"location":"LANGGRAPH_INTEGRATION/#fastapi-application-mainpy","title":"FastAPI Application (main.py)","text":"<p>Lifespan Management: <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    logger.info(\"Starting Recommender_v2 application...\")\n\n    # Initialize databases\n    try:\n        await init_redis()\n        logger.info(\"\u2713 Redis initialized\")\n    except Exception as e:\n        logger.warning(f\"Redis initialization failed: {e}. Continuing without Redis caching.\")\n\n    try:\n        init_postgresql()\n        logger.info(\"\u2713 PostgreSQL initialized\")\n\n        # Create database tables\n        async with postgresql_manager.engine.begin() as conn:\n            await conn.run_sync(Base.metadata.create_all)\n        logger.info(\"\u2713 Database tables created/verified\")\n    except Exception as e:\n        logger.warning(f\"PostgreSQL initialization failed: {e}. Continuing without archival.\")\n\n    # Initialize LangSmith\n    if langsmith_service.is_enabled():\n        logger.info(\"\u2713 LangSmith observability enabled\")\n    else:\n        logger.info(\"LangSmith observability disabled\")\n\n    # Initialize orchestrator and other services...\n\n    yield\n\n    # Shutdown\n    await close_redis()\n    await close_postgresql()\n    logger.info(\"Shutdown complete\")\n</code></pre></p> <p>Health Check: <pre><code>@app.get(\"/health\")\nasync def health_check():\n    from .database.database import redis_manager, postgresql_manager\n\n    health_status = {\n        \"status\": \"healthy\",\n        \"services\": {\n            \"parameter_extractor\": parameter_extractor is not None,\n            \"neo4j_search\": neo4j_search is not None,\n            \"message_generator\": message_generator is not None,\n            \"orchestrator\": orchestrator is not None,\n            \"redis\": redis_manager._initialized,\n            \"postgresql\": postgresql_manager._initialized,\n            \"langsmith\": langsmith_service.is_enabled()\n        }\n    }\n\n    # Core services must be healthy\n    core_services_healthy = all([\n        health_status[\"services\"][\"parameter_extractor\"],\n        health_status[\"services\"][\"neo4j_search\"],\n        health_status[\"services\"][\"message_generator\"],\n        health_status[\"services\"][\"orchestrator\"]\n    ])\n\n    if not core_services_healthy:\n        health_status[\"status\"] = \"unhealthy\"\n\n    return health_status\n</code></pre></p>"},{"location":"LANGGRAPH_INTEGRATION/#session-lifecycle","title":"Session Lifecycle","text":""},{"location":"LANGGRAPH_INTEGRATION/#1-session-creation","title":"1. Session Creation","text":"<pre><code>User Request \u2192 Create Session \u2192 Initialize ConversationState \u2192 Store in Redis\n</code></pre>"},{"location":"LANGGRAPH_INTEGRATION/#2-message-processing","title":"2. Message Processing","text":"<pre><code>User Message \u2192 LangGraph Workflow \u2192 Update State \u2192 Redis Checkpoint\n</code></pre> <p>LangGraph Workflow Steps: 1. Extract Parameters - LLM extracts MasterParameterJSON from user message 2. Search Products - Neo4j searches based on extracted parameters 3. Generate Response - Creates conversational response 4. Determine Next State - Updates state machine (S1\u2192SN)</p>"},{"location":"LANGGRAPH_INTEGRATION/#3-session-archival","title":"3. Session Archival","text":"<pre><code>Session Complete \u2192 PostgreSQL Archive \u2192 Remove from Redis\n</code></pre> <p>Archival Trigger: Manual or automatic based on business logic</p>"},{"location":"LANGGRAPH_INTEGRATION/#configuration","title":"Configuration","text":""},{"location":"LANGGRAPH_INTEGRATION/#environment-variables","title":"Environment Variables","text":"<p>Redis: <pre><code>REDIS_URL=redis://localhost:6379  # Optional full URL\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_TTL_SECONDS=86400  # 24 hours\n</code></pre></p> <p>PostgreSQL: <pre><code>POSTGRES_HOST=localhost\nPOSTGRES_PORT=5432\nPOSTGRES_USER=pconfig\nPOSTGRES_PASSWORD=your_password\nPOSTGRES_DB=pconfig\n</code></pre></p> <p>LangSmith: <pre><code>LANGSMITH_API_KEY=your_api_key\nLANGSMITH_PROJECT=Recommender  # Optional\n</code></pre></p> <p>OpenAI (for LLM): <pre><code>OPENAI_API_KEY=your_openai_key\n</code></pre></p> <p>Neo4j (for product search): <pre><code>NEO4J_URI=neo4j+s://your_instance.databases.neo4j.io\nNEO4J_USERNAME=neo4j\nNEO4J_PASSWORD=your_password\n</code></pre></p>"},{"location":"LANGGRAPH_INTEGRATION/#deployment","title":"Deployment","text":""},{"location":"LANGGRAPH_INTEGRATION/#local-development","title":"Local Development","text":"<pre><code># Start servers\n./start_servers.sh\n\n# Backend: http://localhost:8000\n# Frontend: http://localhost:3001\n# API Docs: http://localhost:8000/docs\n# Health: http://localhost:8000/health\n\n# Stop servers\n./stop_servers.sh\n</code></pre>"},{"location":"LANGGRAPH_INTEGRATION/#docker-deployment","title":"Docker Deployment","text":"<pre><code># docker-compose.yml\nversion: '3.8'\n\nservices:\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis_data:/data\n\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_USER: pconfig\n      POSTGRES_PASSWORD: your_password\n      POSTGRES_DB: pconfig\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\n  backend:\n    build: ./backend\n    ports:\n      - \"8000:8000\"\n    environment:\n      - REDIS_HOST=redis\n      - POSTGRES_HOST=postgres\n      - OPENAI_API_KEY=${OPENAI_API_KEY}\n      - NEO4J_URI=${NEO4J_URI}\n      - NEO4J_USERNAME=${NEO4J_USERNAME}\n      - NEO4J_PASSWORD=${NEO4J_PASSWORD}\n      - LANGSMITH_API_KEY=${LANGSMITH_API_KEY}\n    depends_on:\n      - redis\n      - postgres\n\nvolumes:\n  redis_data:\n  postgres_data:\n</code></pre>"},{"location":"LANGGRAPH_INTEGRATION/#monitoring-observability","title":"Monitoring &amp; Observability","text":""},{"location":"LANGGRAPH_INTEGRATION/#langsmith-dashboard","title":"LangSmith Dashboard","text":"<ul> <li>Workflow Visualization: See complete S1\u2192SN progression</li> <li>Node Performance: Track execution time per node</li> <li>Error Tracking: Centralized error logging</li> <li>Run History: Search and filter past executions</li> </ul> <p>Access: https://smith.langchain.com/ (requires LANGSMITH_API_KEY)</p>"},{"location":"LANGGRAPH_INTEGRATION/#health-checks","title":"Health Checks","text":"<pre><code># Check system health\ncurl http://localhost:8000/health\n\n# Expected response\n{\n  \"status\": \"healthy\",\n  \"services\": {\n    \"parameter_extractor\": true,\n    \"neo4j_search\": true,\n    \"message_generator\": true,\n    \"orchestrator\": true,\n    \"redis\": true,\n    \"postgresql\": true,\n    \"langsmith\": false  # true if LANGSMITH_API_KEY set\n  }\n}\n</code></pre>"},{"location":"LANGGRAPH_INTEGRATION/#database-monitoring","title":"Database Monitoring","text":"<pre><code># Redis\nredis-cli ping\nredis-cli info\n\n# PostgreSQL\npsql -h localhost -U pconfig -d pconfig -c \"\\dt\"\npsql -h localhost -U pconfig -d pconfig -c \"SELECT COUNT(*) FROM archived_sessions;\"\n</code></pre>"},{"location":"LANGGRAPH_INTEGRATION/#testing","title":"Testing","text":""},{"location":"LANGGRAPH_INTEGRATION/#unit-tests","title":"Unit Tests","text":"<pre><code>cd backend\nsource venv/bin/activate\npytest tests/\n</code></pre>"},{"location":"LANGGRAPH_INTEGRATION/#integration-tests","title":"Integration Tests","text":"<pre><code># Test API endpoint\ncurl -X POST http://localhost:8000/api/v1/configurator/message \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"message\": \"I need a 500A power source\", \"session_id\": null}'\n\n# Expected: Session creation + parameter extraction\n</code></pre>"},{"location":"LANGGRAPH_INTEGRATION/#frontend-testing","title":"Frontend Testing","text":"<ol> <li>Navigate to http://localhost:3001/test_extraction.html</li> <li>Enter query: \"I need a 500A power source\"</li> <li>Click \"Extract Parameters\"</li> <li>Verify extraction results in output section</li> </ol>"},{"location":"LANGGRAPH_INTEGRATION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"LANGGRAPH_INTEGRATION/#redis-connection-issues","title":"Redis Connection Issues","text":"<pre><code># Check Redis is running\nredis-cli ping\n\n# Check logs\ntail -f backend.log | grep -i redis\n\n# Common fixes\n# 1. Ensure Redis is installed and running\n# 2. Check firewall rules\n# 3. Verify .env configuration\n</code></pre>"},{"location":"LANGGRAPH_INTEGRATION/#postgresql-connection-issues","title":"PostgreSQL Connection Issues","text":"<pre><code># Check PostgreSQL is running\npg_isready -h localhost -p 5432\n\n# Check logs\ntail -f backend.log | grep -i postgresql\n\n# Common fixes\n# 1. Ensure PostgreSQL is installed and running\n# 2. Verify credentials in .env\n# 3. Create database: createdb -U pconfig pconfig\n</code></pre>"},{"location":"LANGGRAPH_INTEGRATION/#langsmith-not-enabled","title":"LangSmith Not Enabled","text":"<pre><code># Check configuration\necho $LANGSMITH_API_KEY\n\n# Verify in health check\ncurl http://localhost:8000/health | jq '.services.langsmith'\n\n# Enable LangSmith\nexport LANGSMITH_API_KEY=your_api_key\n# Restart backend\n</code></pre>"},{"location":"LANGGRAPH_INTEGRATION/#performance-considerations","title":"Performance Considerations","text":""},{"location":"LANGGRAPH_INTEGRATION/#redis-performance","title":"Redis Performance","text":"<ul> <li>Connection Pooling: Enabled by default with <code>redis.asyncio.Redis</code></li> <li>TTL Optimization: 24hr default, adjust based on usage patterns</li> <li>Memory Management: Monitor Redis memory usage, configure maxmemory policies</li> </ul>"},{"location":"LANGGRAPH_INTEGRATION/#postgresql-performance","title":"PostgreSQL Performance","text":"<ul> <li>Indexing: Created on <code>created_at</code> and <code>current_state</code> columns</li> <li>JSONB Storage: Efficient storage for master_parameters and response_json</li> <li>Connection Pooling: SQLAlchemy async engine with pool size management</li> </ul>"},{"location":"LANGGRAPH_INTEGRATION/#langsmith-performance","title":"LangSmith Performance","text":"<ul> <li>Async Logging: Non-blocking observability calls</li> <li>Batch Operations: Consider batching for high-volume scenarios</li> <li>Selective Tracing: Enable only for critical workflows in production</li> </ul>"},{"location":"LANGGRAPH_INTEGRATION/#future-enhancements","title":"Future Enhancements","text":""},{"location":"LANGGRAPH_INTEGRATION/#planned-features","title":"Planned Features","text":"<ol> <li>LangGraph Visualization: Real-time workflow visualization in frontend</li> <li>Session Analytics: PostgreSQL-based analytics dashboard</li> <li>Multi-tenancy: Support for multiple users with isolated sessions</li> <li>Workflow Variants: A/B testing different workflow configurations</li> <li>Advanced Checkpointing: Branching and rollback capabilities</li> </ol>"},{"location":"LANGGRAPH_INTEGRATION/#scalability-improvements","title":"Scalability Improvements","text":"<ol> <li>Redis Cluster: Horizontal scaling for high-volume scenarios</li> <li>PostgreSQL Read Replicas: Separate analytics workload from archival writes</li> <li>Load Balancing: Multiple backend instances with shared state</li> <li>Caching Layer: Additional caching for Neo4j query results</li> </ol>"},{"location":"LANGGRAPH_INTEGRATION/#references","title":"References","text":"<ul> <li>LangGraph Documentation: https://langchain-ai.github.io/langgraph/</li> <li>LangSmith Documentation: https://docs.smith.langchain.com/</li> <li>Redis Documentation: https://redis.io/docs/</li> <li>PostgreSQL Documentation: https://www.postgresql.org/docs/</li> <li>SQLAlchemy 2.0: https://docs.sqlalchemy.org/en/20/</li> <li>FastAPI Lifespan: https://fastapi.tiangolo.com/advanced/events/</li> </ul>"},{"location":"LANGGRAPH_INTEGRATION/#support","title":"Support","text":"<p>For issues or questions: 1. Check this documentation 2. Review backend.log for error messages 3. Verify health endpoint status 4. Check database connectivity 5. Consult LangSmith dashboard for workflow issues</p> <p>Last Updated: 2025-10-25 Version: 2.0.0</p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/","title":"Master Parameter JSON Architecture","text":"<p>Version: 1.0 Date: 2025-10-24 Status: Architecture Design - Critical Component</p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#executive-summary","title":"Executive Summary","text":"<p>The Master Parameter JSON is the deterministic semantic bridge between user intent and Neo4j search. It holds normalized, attribute-level parameters per component extracted by the LLM, serving as the single source of truth for what the user wants.</p> <p>Spec Reference: Section 1.1 (Lines 23-94)</p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#1-problem-statement","title":"1. Problem Statement","text":""},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#11-current-state","title":"1.1 Current State","text":"<p>Current Implementation: - Intent extracted into <code>EnhancedProcessedIntent</code> model - Attributes scattered across multiple models - No single normalized parameter structure - Difficult to track what user has specified vs. what's been inferred</p> <p>Current Models (<code>enhanced_state_models.py</code>): <pre><code>class EnhancedProcessedIntent(ExtractedIntent):\n    original_query: str\n    processed_query: str\n    detected_language: LanguageCode\n    expertise_mode: ExpertiseMode\n    # Attributes are in base ExtractedIntent:\n    # - welding_process: List[WeldingProcess]\n    # - current_amps: Optional[str]\n    # - material: Optional[Material]\n    # - thickness_mm: Optional[str]\n    # etc.\n</code></pre></p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#12-spec-requirement","title":"1.2 Spec Requirement","text":"<p>Master Parameter JSON Structure (Lines 29-62): <pre><code>{\n  \"PowerSource\": {\n    \"process\": \"\",\n    \"current_output\": \"\",\n    \"duty_cycle\": \"\",\n    \"material\": \"\",\n    \"phase\": \"\",\n    \"voltage\": \"\"\n  },\n  \"Feeder\": {\n    \"process\": \"\",\n    \"portability\": \"\",\n    \"wire_size\": \"\",\n    \"material\": \"\"\n  },\n  \"Cooler\": {\n    \"cooling_type\": \"\",\n    \"flow_rate\": \"\",\n    \"capacity\": \"\"\n  },\n  \"Interconnect\": {\n    \"type\": \"\",\n    \"length\": \"\",\n    \"connector_type\": \"\"\n  },\n  \"Torch\": {\n    \"process\": \"\",\n    \"cooling_type\": \"\",\n    \"material\": \"\",\n    \"amperage_rating\": \"\"\n  }\n}\n</code></pre></p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#13-key-requirements-from-spec","title":"1.3 Key Requirements from Spec","text":"<p>1. Attribute Management (Lines 66-70): - Attributes refined/overwritten based on latest user input - Never arbitrarily deleted by system - User can change their mind - latest value wins</p> <p>2. Eligibility for Neo4j Search (Lines 71-73): - Component must have \u22651 parameter to be eligible - Exception: Direct product mentions bypass requirement</p> <p>3. Direct Product Mentions (Lines 75-78): - Product names trigger direct GIN lookup - System enriches Master JSON with product attributes from Neo4j</p> <p>4. Re-Validation Scope (Lines 80-83): - Updating component triggers re-validation ONLY for downstream - Downstream = all states after modified component</p> <p>5. Normalization Standards (Lines 85-93): - Current output: \"500 A\", \"300 A\" - Voltage: \"230V\", \"460V\" - Phase: \"single-phase\", \"3-phase\" - Process: \"MIG (GMAW)\", \"TIG (GTAW)\", \"Stick (SMAW)\" - Cooling type: \"water\", \"air\", \"none\" - Length: \"25 ft\", \"50 ft\" - Wire size: \"0.035 inch\", \"0.045 inch\"</p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#2-solution-architecture","title":"2. Solution Architecture","text":""},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#21-master-parameter-json-model","title":"2.1 Master Parameter JSON Model","text":"<p>Location: <code>/backend/app/models/master_parameter.py</code></p> <pre><code>from typing import Optional, Dict, Any, List\nfrom pydantic import BaseModel, Field, validator\nfrom datetime import datetime\nfrom enum import Enum\n\nclass WeldingProcess(str, Enum):\n    \"\"\"Normalized welding process names\"\"\"\n    MIG = \"MIG (GMAW)\"\n    TIG = \"TIG (GTAW)\"\n    STICK = \"Stick (SMAW)\"\n    FLUX_CORE = \"Flux-Cored (FCAW)\"\n    SAW = \"Submerged Arc (SAW)\"\n\n\nclass CoolingType(str, Enum):\n    \"\"\"Normalized cooling types\"\"\"\n    WATER = \"water\"\n    AIR = \"air\"\n    NONE = \"none\"\n\n\nclass PhaseType(str, Enum):\n    \"\"\"Normalized phase types\"\"\"\n    SINGLE = \"single-phase\"\n    THREE = \"3-phase\"\n\n\nclass PowerSourceParameters(BaseModel):\n    \"\"\"Normalized parameters for Power Source component\"\"\"\n\n    process: Optional[str] = \"\"  # WeldingProcess enum value\n    current_output: Optional[str] = \"\"  # e.g., \"500 A\"\n    duty_cycle: Optional[str] = \"\"  # e.g., \"60%\", \"100%\"\n    material: Optional[str] = \"\"  # e.g., \"aluminum\", \"steel\", \"stainless\"\n    phase: Optional[str] = \"\"  # PhaseType enum value\n    voltage: Optional[str] = \"\"  # e.g., \"230V\", \"460V\"\n\n    # Metadata\n    has_parameters: bool = False\n    direct_product_mention: Optional[str] = None  # e.g., \"Aristo 500ix\"\n\n    @validator('current_output')\n    def normalize_current(cls, v):\n        \"\"\"Normalize current to 'XXX A' format\"\"\"\n        if not v:\n            return v\n        # Extract number and add unit\n        import re\n        match = re.search(r'(\\d+)', str(v))\n        if match:\n            return f\"{match.group(1)} A\"\n        return v\n\n    @validator('voltage')\n    def normalize_voltage(cls, v):\n        \"\"\"Normalize voltage to 'XXXV' format\"\"\"\n        if not v:\n            return v\n        import re\n        match = re.search(r'(\\d+)', str(v))\n        if match:\n            return f\"{match.group(1)}V\"\n        return v\n\n    @validator('phase')\n    def normalize_phase(cls, v):\n        \"\"\"Normalize phase to standard format\"\"\"\n        if not v:\n            return v\n        v_lower = str(v).lower()\n        if '3' in v_lower or 'three' in v_lower:\n            return PhaseType.THREE.value\n        elif '1' in v_lower or 'single' in v_lower:\n            return PhaseType.SINGLE.value\n        return v\n\n    def update_from_dict(self, updates: Dict[str, Any]):\n        \"\"\"Update parameters from dict, overwriting existing values\"\"\"\n        for key, value in updates.items():\n            if hasattr(self, key) and value:\n                setattr(self, key, value)\n        self._update_has_parameters()\n\n    def _update_has_parameters(self):\n        \"\"\"Check if any parameter is set\"\"\"\n        self.has_parameters = any([\n            self.process, self.current_output, self.duty_cycle,\n            self.material, self.phase, self.voltage\n        ])\n\n\nclass FeederParameters(BaseModel):\n    \"\"\"Normalized parameters for Feeder component\"\"\"\n\n    process: Optional[str] = \"\"\n    portability: Optional[str] = \"\"  # \"portable\", \"stationary\"\n    wire_size: Optional[str] = \"\"  # e.g., \"0.035 inch\", \"0.045 inch\"\n    material: Optional[str] = \"\"\n\n    # Metadata\n    has_parameters: bool = False\n    direct_product_mention: Optional[str] = None\n\n    @validator('wire_size')\n    def normalize_wire_size(cls, v):\n        \"\"\"Normalize wire size to 'X.XXX inch' format\"\"\"\n        if not v:\n            return v\n        import re\n        # Extract decimal number\n        match = re.search(r'(\\d+\\.?\\d*)', str(v))\n        if match:\n            size = match.group(1)\n            # Ensure leading zero for decimals\n            if '.' in size and not size.startswith('0'):\n                size = '0' + size\n            return f\"{size} inch\"\n        return v\n\n    def update_from_dict(self, updates: Dict[str, Any]):\n        \"\"\"Update parameters from dict\"\"\"\n        for key, value in updates.items():\n            if hasattr(self, key) and value:\n                setattr(self, key, value)\n        self._update_has_parameters()\n\n    def _update_has_parameters(self):\n        self.has_parameters = any([\n            self.process, self.portability, self.wire_size, self.material\n        ])\n\n\nclass CoolerParameters(BaseModel):\n    \"\"\"Normalized parameters for Cooler component\"\"\"\n\n    cooling_type: Optional[str] = \"\"  # CoolingType enum value\n    flow_rate: Optional[str] = \"\"  # e.g., \"2 GPM\", \"4 GPM\"\n    capacity: Optional[str] = \"\"  # e.g., \"3 gallon\", \"5 gallon\"\n\n    # Metadata\n    has_parameters: bool = False\n    direct_product_mention: Optional[str] = None\n\n    @validator('cooling_type')\n    def normalize_cooling(cls, v):\n        \"\"\"Normalize cooling type to lowercase\"\"\"\n        if not v:\n            return v\n        v_lower = str(v).lower()\n        if 'water' in v_lower:\n            return CoolingType.WATER.value\n        elif 'air' in v_lower:\n            return CoolingType.AIR.value\n        return v\n\n    def update_from_dict(self, updates: Dict[str, Any]):\n        \"\"\"Update parameters from dict\"\"\"\n        for key, value in updates.items():\n            if hasattr(self, key) and value:\n                setattr(self, key, value)\n        self._update_has_parameters()\n\n    def _update_has_parameters(self):\n        self.has_parameters = any([\n            self.cooling_type, self.flow_rate, self.capacity\n        ])\n\n\nclass InterconnectorParameters(BaseModel):\n    \"\"\"Normalized parameters for Interconnector component\"\"\"\n\n    type: Optional[str] = \"\"  # Cable type\n    length: Optional[str] = \"\"  # e.g., \"25 ft\", \"50 ft\"\n    connector_type: Optional[str] = \"\"\n\n    # Metadata\n    has_parameters: bool = False\n    direct_product_mention: Optional[str] = None\n\n    @validator('length')\n    def normalize_length(cls, v):\n        \"\"\"Normalize length to 'XX ft' format\"\"\"\n        if not v:\n            return v\n        import re\n        match = re.search(r'(\\d+)', str(v))\n        if match:\n            return f\"{match.group(1)} ft\"\n        return v\n\n    def update_from_dict(self, updates: Dict[str, Any]):\n        \"\"\"Update parameters from dict\"\"\"\n        for key, value in updates.items():\n            if hasattr(self, key) and value:\n                setattr(self, key, value)\n        self._update_has_parameters()\n\n    def _update_has_parameters(self):\n        self.has_parameters = any([\n            self.type, self.length, self.connector_type\n        ])\n\n\nclass TorchParameters(BaseModel):\n    \"\"\"Normalized parameters for Torch component\"\"\"\n\n    process: Optional[str] = \"\"\n    cooling_type: Optional[str] = \"\"  # CoolingType enum value\n    material: Optional[str] = \"\"\n    amperage_rating: Optional[str] = \"\"  # e.g., \"400 A\", \"500 A\"\n\n    # Metadata\n    has_parameters: bool = False\n    direct_product_mention: Optional[str] = None\n\n    @validator('amperage_rating')\n    def normalize_amperage(cls, v):\n        \"\"\"Normalize amperage to 'XXX A' format\"\"\"\n        if not v:\n            return v\n        import re\n        match = re.search(r'(\\d+)', str(v))\n        if match:\n            return f\"{match.group(1)} A\"\n        return v\n\n    def update_from_dict(self, updates: Dict[str, Any]):\n        \"\"\"Update parameters from dict\"\"\"\n        for key, value in updates.items():\n            if hasattr(self, key) and value:\n                setattr(self, key, value)\n        self._update_has_parameters()\n\n    def _update_has_parameters(self):\n        self.has_parameters = any([\n            self.process, self.cooling_type, self.material, self.amperage_rating\n        ])\n\n\nclass MasterParameterJSON(BaseModel):\n    \"\"\"\n    Master Parameter JSON - Semantic bridge between user intent and Neo4j\n\n    Spec Reference: Section 1.1 (Lines 23-94)\n\n    Holds normalized, attribute-level parameters per component inferred by LLM.\n    Acts as single source of truth for user requirements.\n    \"\"\"\n\n    # Component parameters\n    PowerSource: PowerSourceParameters = Field(default_factory=PowerSourceParameters)\n    Feeder: FeederParameters = Field(default_factory=FeederParameters)\n    Cooler: CoolerParameters = Field(default_factory=CoolerParameters)\n    Interconnect: InterconnectorParameters = Field(default_factory=InterconnectorParameters)\n    Torch: TorchParameters = Field(default_factory=TorchParameters)\n\n    # Metadata\n    version: str = \"1.0\"\n    created_at: datetime = Field(default_factory=datetime.now)\n    last_updated: datetime = Field(default_factory=datetime.now)\n\n    # Conversation context\n    original_queries: List[str] = Field(default_factory=list)\n\n    def update_component(self, component: str, parameters: Dict[str, Any]):\n        \"\"\"\n        Update parameters for a component\n\n        Implements spec requirement: \"Attributes refined or overwritten based on latest input\"\n        Latest value wins - user can change their mind\n        \"\"\"\n        if hasattr(self, component):\n            component_params = getattr(self, component)\n            component_params.update_from_dict(parameters)\n            self.last_updated = datetime.now()\n\n    def get_component_parameters(self, component: str) -&gt; Optional[BaseModel]:\n        \"\"\"Get parameters for a component\"\"\"\n        return getattr(self, component, None)\n\n    def is_component_eligible_for_search(self, component: str) -&gt; bool:\n        \"\"\"\n        Check if component has enough parameters for Neo4j search\n\n        Spec requirement: Component must have \u22651 parameter OR direct product mention\n        \"\"\"\n        component_params = self.get_component_parameters(component)\n        if not component_params:\n            return False\n\n        # Direct product mention bypasses parameter requirement\n        if component_params.direct_product_mention:\n            return True\n\n        # Check if has at least 1 parameter\n        return component_params.has_parameters\n\n    def get_search_text(self, component: str) -&gt; str:\n        \"\"\"\n        Generate search text for Neo4j embedding search\n\n        Example: \"PowerSource 500A 3-phase MIG aluminum\"\n        \"\"\"\n        component_params = self.get_component_parameters(component)\n        if not component_params:\n            return \"\"\n\n        # If direct product mention, use that\n        if component_params.direct_product_mention:\n            return component_params.direct_product_mention\n\n        # Build search text from parameters\n        text_parts = [component]\n\n        for field, value in component_params.dict().items():\n            if field in ['has_parameters', 'direct_product_mention']:\n                continue\n            if value:\n                text_parts.append(str(value))\n\n        return \" \".join(text_parts)\n\n    def enrich_from_product(self, component: str, product_data: Dict[str, Any]):\n        \"\"\"\n        Enrich Master JSON with product attributes from Neo4j node\n\n        Spec requirement: When direct product mentioned, system enriches JSON\n        Example: \"Aristo 500ix\" \u2192 add current_output=\"500 A\", process=\"MIG (GMAW)\"\n        \"\"\"\n        if component == \"PowerSource\":\n            updates = {}\n            if 'current_output' in product_data:\n                updates['current_output'] = product_data['current_output']\n            if 'process' in product_data:\n                updates['process'] = product_data['process']\n            if 'voltage' in product_data:\n                updates['voltage'] = product_data['voltage']\n            if 'phase' in product_data:\n                updates['phase'] = product_data['phase']\n\n            self.update_component(component, updates)\n\n        # Similar logic for other components...\n\n    def clear_downstream_components(self, modified_component: str):\n        \"\"\"\n        Clear parameters for downstream components\n\n        Spec requirement: Updating component triggers re-validation for downstream only\n        Downstream = all states after modified component in S1\u2192SN sequence\n        \"\"\"\n        component_order = [\n            \"PowerSource\",  # S1\n            \"Feeder\",       # S2\n            \"Cooler\",       # S3\n            \"Interconnect\", # S4\n            \"Torch\"         # S5\n        ]\n\n        try:\n            modified_index = component_order.index(modified_component)\n        except ValueError:\n            return\n\n        # Clear all downstream components\n        for i in range(modified_index + 1, len(component_order)):\n            downstream_component = component_order[i]\n            # Reset to empty parameters\n            if downstream_component == \"PowerSource\":\n                self.PowerSource = PowerSourceParameters()\n            elif downstream_component == \"Feeder\":\n                self.Feeder = FeederParameters()\n            elif downstream_component == \"Cooler\":\n                self.Cooler = CoolerParameters()\n            elif downstream_component == \"Interconnect\":\n                self.Interconnect = InterconnectorParameters()\n            elif downstream_component == \"Torch\":\n                self.Torch = TorchParameters()\n\n        self.last_updated = datetime.now()\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Export as dictionary for API/storage\"\"\"\n        return {\n            \"PowerSource\": self.PowerSource.dict(),\n            \"Feeder\": self.Feeder.dict(),\n            \"Cooler\": self.Cooler.dict(),\n            \"Interconnect\": self.Interconnect.dict(),\n            \"Torch\": self.Torch.dict(),\n            \"metadata\": {\n                \"version\": self.version,\n                \"created_at\": self.created_at.isoformat(),\n                \"last_updated\": self.last_updated.isoformat(),\n                \"original_queries\": self.original_queries\n            }\n        }\n</code></pre>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#3-llm-entity-extraction-service","title":"3. LLM Entity Extraction Service","text":""},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#31-intent-to-master-json-converter","title":"3.1 Intent to Master JSON Converter","text":"<p>Location: <code>/backend/app/services/extraction/master_parameter_extractor.py</code></p> <pre><code>from typing import Dict, Any\nfrom ...models.master_parameter import MasterParameterJSON\nfrom ..enterprise.enhanced_state_models import EnhancedProcessedIntent\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass MasterParameterExtractor:\n    \"\"\"\n    Extracts and normalizes parameters from LLM intent into Master Parameter JSON\n\n    Implements spec Section 7: LLM Semantic Extraction\n    \"\"\"\n\n    def extract_from_intent(\n        self,\n        intent: EnhancedProcessedIntent,\n        master_json: MasterParameterJSON,\n        user_message: str\n    ) -&gt; MasterParameterJSON:\n        \"\"\"\n        Extract parameters from intent and update Master JSON\n\n        Args:\n            intent: Processed intent from intelligent_intent_service\n            master_json: Current Master Parameter JSON to update\n            user_message: Original user message\n\n        Returns:\n            Updated Master Parameter JSON\n        \"\"\"\n\n        # Add original query to history\n        master_json.original_queries.append(user_message)\n\n        # Extract PowerSource parameters\n        ps_params = self._extract_power_source_params(intent)\n        if ps_params:\n            master_json.update_component(\"PowerSource\", ps_params)\n\n        # Extract Feeder parameters\n        feeder_params = self._extract_feeder_params(intent)\n        if feeder_params:\n            master_json.update_component(\"Feeder\", feeder_params)\n\n        # Extract Cooler parameters\n        cooler_params = self._extract_cooler_params(intent)\n        if cooler_params:\n            master_json.update_component(\"Cooler\", cooler_params)\n\n        # Extract Interconnector parameters\n        interconnect_params = self._extract_interconnect_params(intent)\n        if interconnect_params:\n            master_json.update_component(\"Interconnect\", interconnect_params)\n\n        # Extract Torch parameters\n        torch_params = self._extract_torch_params(intent)\n        if torch_params:\n            master_json.update_component(\"Torch\", torch_params)\n\n        # Check for direct product mentions\n        self._detect_product_mentions(user_message, master_json)\n\n        return master_json\n\n    def _extract_power_source_params(self, intent: EnhancedProcessedIntent) -&gt; Dict[str, Any]:\n        \"\"\"Extract PowerSource parameters from intent\"\"\"\n        params = {}\n\n        # Process\n        if hasattr(intent, 'welding_process') and intent.welding_process:\n            # welding_process is a list\n            processes = [p.value if hasattr(p, 'value') else str(p) for p in intent.welding_process]\n            params['process'] = processes[0] if processes else None\n\n        # Current output\n        if hasattr(intent, 'current_amps') and intent.current_amps:\n            params['current_output'] = str(intent.current_amps)\n\n        # Material\n        if hasattr(intent, 'material') and intent.material:\n            params['material'] = intent.material.value if hasattr(intent.material, 'value') else str(intent.material)\n\n        # Voltage\n        if hasattr(intent, 'voltage') and intent.voltage:\n            params['voltage'] = str(intent.voltage)\n\n        # Phase (extract from extracted_entities if available)\n        if hasattr(intent, 'extracted_entities') and intent.extracted_entities:\n            if 'phase' in intent.extracted_entities:\n                params['phase'] = intent.extracted_entities['phase']\n\n        return params\n\n    def _extract_feeder_params(self, intent: EnhancedProcessedIntent) -&gt; Dict[str, Any]:\n        \"\"\"Extract Feeder parameters from intent\"\"\"\n        params = {}\n\n        # Process (same as power source)\n        if hasattr(intent, 'welding_process') and intent.welding_process:\n            processes = [p.value if hasattr(p, 'value') else str(p) for p in intent.welding_process]\n            params['process'] = processes[0] if processes else None\n\n        # Check extracted_entities for feeder-specific params\n        if hasattr(intent, 'extracted_entities') and intent.extracted_entities:\n            entities = intent.extracted_entities\n\n            if 'portability' in entities:\n                params['portability'] = entities['portability']\n\n            if 'wire_size' in entities:\n                params['wire_size'] = entities['wire_size']\n\n        return params\n\n    def _extract_cooler_params(self, intent: EnhancedProcessedIntent) -&gt; Dict[str, Any]:\n        \"\"\"Extract Cooler parameters from intent\"\"\"\n        params = {}\n\n        if hasattr(intent, 'extracted_entities') and intent.extracted_entities:\n            entities = intent.extracted_entities\n\n            if 'cooling_type' in entities:\n                params['cooling_type'] = entities['cooling_type']\n\n            if 'flow_rate' in entities:\n                params['flow_rate'] = entities['flow_rate']\n\n            if 'capacity' in entities:\n                params['capacity'] = entities['capacity']\n\n        return params\n\n    def _extract_interconnect_params(self, intent: EnhancedProcessedIntent) -&gt; Dict[str, Any]:\n        \"\"\"Extract Interconnector parameters from intent\"\"\"\n        params = {}\n\n        if hasattr(intent, 'extracted_entities') and intent.extracted_entities:\n            entities = intent.extracted_entities\n\n            if 'cable_length' in entities:\n                params['length'] = entities['cable_length']\n\n            if 'connector_type' in entities:\n                params['connector_type'] = entities['connector_type']\n\n        return params\n\n    def _extract_torch_params(self, intent: EnhancedProcessedIntent) -&gt; Dict[str, Any]:\n        \"\"\"Extract Torch parameters from intent\"\"\"\n        params = {}\n\n        # Process\n        if hasattr(intent, 'welding_process') and intent.welding_process:\n            processes = [p.value if hasattr(p, 'value') else str(p) for p in intent.welding_process]\n            params['process'] = processes[0] if processes else None\n\n        if hasattr(intent, 'extracted_entities') and intent.extracted_entities:\n            entities = intent.extracted_entities\n\n            if 'torch_cooling' in entities:\n                params['cooling_type'] = entities['torch_cooling']\n\n            if 'torch_amperage' in entities:\n                params['amperage_rating'] = entities['torch_amperage']\n\n        return params\n\n    def _detect_product_mentions(self, user_message: str, master_json: MasterParameterJSON):\n        \"\"\"\n        Detect direct product name mentions\n\n        Spec: Product names (e.g., \"Aristo 500ix\") trigger direct GIN lookup\n        \"\"\"\n        # Known product patterns\n        product_patterns = {\n            \"Aristo\": \"PowerSource\",\n            \"Renegade\": \"PowerSource\",\n            \"Warrior\": \"PowerSource\",\n            \"Dynasty\": \"PowerSource\",\n            \"Python\": \"Feeder\",\n            \"Bernard\": \"Torch\",\n            \"Tweco\": \"Torch\"\n        }\n\n        message_lower = user_message.lower()\n\n        for product_name, component in product_patterns.items():\n            if product_name.lower() in message_lower:\n                # Extract full product name (e.g., \"Aristo 500ix\")\n                import re\n                pattern = f\"{product_name}\\\\s*\\\\w*\"\n                match = re.search(pattern, user_message, re.IGNORECASE)\n                if match:\n                    full_name = match.group(0)\n\n                    # Set direct product mention\n                    component_params = master_json.get_component_parameters(component)\n                    if component_params:\n                        component_params.direct_product_mention = full_name\n                        logger.info(f\"Detected product mention: {full_name} for {component}\")\n\n\ndef get_master_parameter_extractor() -&gt; MasterParameterExtractor:\n    \"\"\"Get extractor instance\"\"\"\n    return MasterParameterExtractor()\n</code></pre>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#4-integration-with-existing-system","title":"4. Integration with Existing System","text":""},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#41-session-state-enhancement","title":"4.1 Session State Enhancement","text":"<p>Modify <code>/backend/app/models/conversation_models.py</code>:</p> <pre><code>from .master_parameter import MasterParameterJSON\n\nclass ConversationHistory:\n    \"\"\"Conversation session history\"\"\"\n\n    # ... existing fields ...\n\n    # Add Master Parameter JSON\n    master_parameters: MasterParameterJSON = Field(default_factory=MasterParameterJSON)\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        if not self.master_parameters:\n            self.master_parameters = MasterParameterJSON()\n</code></pre>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#42-conversational-manager-integration","title":"4.2 Conversational Manager Integration","text":"<p>Modify <code>/backend/app/services/enterprise/conversational_manager.py</code>:</p> <pre><code>from ..extraction.master_parameter_extractor import get_master_parameter_extractor\n\nclass ConversationalManager:\n\n    def __init__(self, intent_service, neo4j_service):\n        # ... existing initialization ...\n        self.parameter_extractor = get_master_parameter_extractor()\n\n    async def _process_turn(self, session, user_message):\n        # ... existing logic ...\n\n        # Extract intent\n        intent_result = await self.intent_service.process_query(\n            query=user_message,\n            user_context=user_context,\n            trace_id=trace_id\n        )\n\n        # UPDATE MASTER PARAMETER JSON\n        session.master_parameters = self.parameter_extractor.extract_from_intent(\n            intent=intent_result,\n            master_json=session.master_parameters,\n            user_message=user_message\n        )\n\n        # Log extracted parameters\n        logger.info(f\"Master Parameters updated: {session.master_parameters.to_dict()}\")\n\n        # Continue with existing logic...\n</code></pre>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#43-neo4j-search-integration","title":"4.3 Neo4j Search Integration","text":"<p>Modify <code>/backend/app/services/enterprise/smart_neo4j_service.py</code>:</p> <pre><code>async def search_with_master_parameters(\n    self,\n    component: str,\n    master_json: MasterParameterJSON\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Search Neo4j using Master Parameter JSON\n\n    Implements spec Section 4.1: Retrieval Strategies\n    \"\"\"\n\n    # Check if component has direct product mention\n    component_params = master_json.get_component_parameters(component)\n    if not component_params:\n        return []\n\n    # Strategy 1: Direct GIN/Model Lookup\n    if component_params.direct_product_mention:\n        logger.info(f\"Using direct product lookup: {component_params.direct_product_mention}\")\n        return await self._direct_product_lookup(\n            component,\n            component_params.direct_product_mention\n        )\n\n    # Strategy 2: Attribute-Based Embedding Search\n    if master_json.is_component_eligible_for_search(component):\n        search_text = master_json.get_search_text(component)\n        logger.info(f\"Using embedding search: {search_text}\")\n        return await self.search_products_semantic(\n            query=search_text,\n            category=component\n        )\n\n    # Not eligible for search\n    logger.warning(f\"Component {component} not eligible for search (no parameters)\")\n    return []\n</code></pre>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#5-user-flow-example","title":"5. User Flow Example","text":""},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#51-scenario-user-specifies-aristo-500ix","title":"5.1 Scenario: User Specifies \"Aristo 500ix\"","text":"<p>User Input: \"I need an Aristo 500ix power source\"</p> <p>Processing:</p> <ol> <li> <p>Intent Extraction (intelligent_intent_service): <pre><code>intent = {\n    \"original_query\": \"I need an Aristo 500ix power source\",\n    \"welding_process\": [],\n    \"current_amps\": None,\n    \"extracted_entities\": {}\n}\n</code></pre></p> </li> <li> <p>Master Parameter Extraction: <pre><code># Detect product mention \"Aristo 500ix\"\nmaster_json.PowerSource.direct_product_mention = \"Aristo 500ix\"\n</code></pre></p> </li> <li> <p>Neo4j Direct Lookup: <pre><code>MATCH (p:Product)\nWHERE p.name CONTAINS \"Aristo 500ix\"\n   OR p.model_name = \"Aristo 500ix\"\n   OR p.gin = \"0446200880\"\nRETURN p\n</code></pre></p> </li> <li> <p>Enrich Master JSON from Product: <pre><code>product_data = {\n    \"gin\": \"0446200880\",\n    \"name\": \"Aristo 500ix\",\n    \"current_output\": \"500 A\",\n    \"process\": \"MIG (GMAW)\",\n    \"voltage\": \"230V\",\n    \"phase\": \"3-phase\"\n}\n\n# Enrich Master JSON\nmaster_json.enrich_from_product(\"PowerSource\", product_data)\n\n# Master JSON now has:\n{\n  \"PowerSource\": {\n    \"process\": \"MIG (GMAW)\",\n    \"current_output\": \"500 A\",\n    \"voltage\": \"230V\",\n    \"phase\": \"3-phase\",\n    \"direct_product_mention\": \"Aristo 500ix\"\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#52-scenario-user-changes-mind","title":"5.2 Scenario: User Changes Mind","text":"<p>Turn 1: \"I need 500 amps\" <pre><code>{\"PowerSource\": {\"current_output\": \"500 A\"}}\n</code></pre></p> <p>Turn 2: \"Actually, make that 300 amps\" <pre><code>{\"PowerSource\": {\"current_output\": \"300 A\"}}\n// Latest value wins!\n</code></pre></p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#53-scenario-downstream-re-validation","title":"5.3 Scenario: Downstream Re-Validation","text":"<p>Turn 1: Select Aristo 500ix (500A) <pre><code>{\n  \"PowerSource\": {\"current_output\": \"500 A\"},\n  \"Feeder\": {\"process\": \"MIG (GMAW)\"},\n  \"Cooler\": {\"cooling_type\": \"water\"},\n  \"Torch\": {\"amperage_rating\": \"500 A\"}\n}\n</code></pre></p> <p>Turn 2: User changes to Renegade ES300 (300A) <pre><code># Clear downstream components\nmaster_json.update_component(\"PowerSource\", {\"current_output\": \"300 A\"})\nmaster_json.clear_downstream_components(\"PowerSource\")\n\n# Result:\n{\n  \"PowerSource\": {\"current_output\": \"300 A\"},\n  \"Feeder\": {},  // CLEARED\n  \"Cooler\": {},  // CLEARED\n  \"Torch\": {}    // CLEARED\n}\n</code></pre></p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#6-benefits","title":"6. Benefits","text":""},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#61-deterministic-entity-extraction","title":"6.1 Deterministic Entity Extraction","text":"<p>\u2705 Single Source of Truth: All user requirements in one place \u2705 Normalized Format: Consistent attribute representation \u2705 Audit Trail: original_queries tracks conversation history \u2705 Searchable: Easy to query what user has specified</p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#62-flexible-intent-handling","title":"6.2 Flexible Intent Handling","text":"<p>\u2705 Latest Value Wins: User can change mind anytime \u2705 Never Delete: Attributes only overwritten, never removed arbitrarily \u2705 Downstream Cascade: Clear dependent components automatically \u2705 Product Enrichment: Auto-populate from known products</p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#63-neo4j-search-optimization","title":"6.3 Neo4j Search Optimization","text":"<p>\u2705 Eligibility Check: Only search when \u22651 parameter \u2705 Direct Lookup: Bypass search for known products \u2705 Semantic Search: Generate optimal search text from parameters \u2705 Strategy Selection: Choose best retrieval strategy automatically</p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#7-testing","title":"7. Testing","text":""},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#71-unit-tests","title":"7.1 Unit Tests","text":"<pre><code>def test_normalize_current_output():\n    \"\"\"Test current normalization\"\"\"\n    params = PowerSourceParameters(current_output=\"500\")\n    assert params.current_output == \"500 A\"\n\n    params = PowerSourceParameters(current_output=\"500 amps\")\n    assert params.current_output == \"500 A\"\n\ndef test_update_component():\n    \"\"\"Test component update (latest wins)\"\"\"\n    master = MasterParameterJSON()\n\n    # First update\n    master.update_component(\"PowerSource\", {\"current_output\": \"500\"})\n    assert master.PowerSource.current_output == \"500 A\"\n\n    # Second update (should overwrite)\n    master.update_component(\"PowerSource\", {\"current_output\": \"300\"})\n    assert master.PowerSource.current_output == \"300 A\"\n\ndef test_clear_downstream():\n    \"\"\"Test downstream clearing\"\"\"\n    master = MasterParameterJSON()\n\n    # Set all components\n    master.update_component(\"PowerSource\", {\"current_output\": \"500 A\"})\n    master.update_component(\"Feeder\", {\"process\": \"MIG (GMAW)\"})\n    master.update_component(\"Torch\", {\"amperage_rating\": \"500 A\"})\n\n    # Modify PowerSource (should clear Feeder and Torch)\n    master.clear_downstream_components(\"PowerSource\")\n\n    assert master.PowerSource.current_output == \"500 A\"  # Unchanged\n    assert master.Feeder.process == \"\"  # Cleared\n    assert master.Torch.amperage_rating == \"\"  # Cleared\n</code></pre>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#8-api-response-format","title":"8. API Response Format","text":""},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#81-include-master-json-in-response","title":"8.1 Include Master JSON in Response","text":"<pre><code>class ConversationQueryResponse(BaseModel):\n    # ... existing fields ...\n\n    master_parameters: Optional[Dict[str, Any]] = None\n\n    @classmethod\n    def from_session(cls, session: ConversationHistory):\n        return cls(\n            # ... existing fields ...\n            master_parameters=session.master_parameters.to_dict()\n        )\n</code></pre> <p>Example Response: <pre><code>{\n  \"session_id\": \"abc-123\",\n  \"message\": \"I've found the Aristo 500ix...\",\n  \"current_state\": \"FEEDER\",\n  \"master_parameters\": {\n    \"PowerSource\": {\n      \"process\": \"MIG (GMAW)\",\n      \"current_output\": \"500 A\",\n      \"voltage\": \"230V\",\n      \"phase\": \"3-phase\",\n      \"direct_product_mention\": \"Aristo 500ix\",\n      \"has_parameters\": true\n    },\n    \"Feeder\": {},\n    \"Cooler\": {},\n    \"Interconnect\": {},\n    \"Torch\": {},\n    \"metadata\": {\n      \"version\": \"1.0\",\n      \"created_at\": \"2025-10-24T10:00:00\",\n      \"last_updated\": \"2025-10-24T10:01:30\",\n      \"original_queries\": [\n        \"I need an Aristo 500ix power source\"\n      ]\n    }\n  }\n}\n</code></pre></p>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#9-implementation-checklist","title":"9. Implementation Checklist","text":"<ul> <li> Create <code>master_parameter.py</code> with all component parameter models</li> <li> Add normalization validators for each attribute type</li> <li> Implement <code>MasterParameterExtractor</code> service</li> <li> Integrate with <code>ConversationHistory</code> model</li> <li> Update <code>ConversationalManager</code> to use Master JSON</li> <li> Enhance <code>SmartNeo4jService</code> with parameter-based search</li> <li> Add Master JSON to API responses</li> <li> Write unit tests for normalization</li> <li> Write unit tests for update logic</li> <li> Write integration tests for user flow scenarios</li> <li> Document API changes in Swagger/OpenAPI</li> </ul>"},{"location":"MASTER_PARAMETER_JSON_ARCHITECTURE/#10-success-criteria","title":"10. Success Criteria","text":"<p>\u2705 Deterministic Extraction: Same input always produces same Master JSON \u2705 Normalization Accuracy: 100% of test cases normalize correctly \u2705 Latest Value Wins: User can change mind, latest value always used \u2705 Downstream Cascade: Modifying component clears all downstream \u2705 Product Enrichment: Direct mentions auto-populate attributes \u2705 Search Eligibility: Correct strategy selection (direct vs semantic)</p> <p>Status: Architecture Design Complete - Ready for Implementation Next: Integrate with Phase 1 implementation plan</p>"},{"location":"MKDOCS_UPDATE_GUIDE/","title":"MkDocs Documentation Update Guide","text":"<p>This guide explains how to update the MkDocs documentation that's served at <code>http://localhost:8000/mkdocs/</code>.</p>"},{"location":"MKDOCS_UPDATE_GUIDE/#quick-start","title":"Quick Start","text":"<p>When you add new documentation files to the <code>docs/</code> directory or update existing ones:</p> <pre><code># 1. Update mkdocs.yml navigation (if adding new pages)\n# Edit: mkdocs.yml\n\n# 2. Build the static site\ncd /Users/bharath/Desktop/Ayna_ESAB_Nov7\nmkdocs build\n\n# 3. The backend will automatically serve the updated docs at:\n#    http://localhost:8000/mkdocs/\n</code></pre> <p>That's it! No need to restart the backend server.</p>"},{"location":"MKDOCS_UPDATE_GUIDE/#directory-structure","title":"Directory Structure","text":"<pre><code>Ayna_ESAB_Nov7/\n\u251c\u2500\u2500 docs/                    # Documentation source files (Markdown)\n\u2502   \u251c\u2500\u2500 operations/\n\u2502   \u2502   \u251c\u2500\u2500 deployment-sizing-guide.md\n\u2502   \u2502   \u251c\u2500\u2500 runbook.md\n\u2502   \u2502   \u2514\u2500\u2500 scripts/\n\u2502   \u2502       \u2514\u2500\u2500 README.md\n\u2502   \u2514\u2500\u2500 ... other docs\n\u251c\u2500\u2500 mkdocs.yml               # MkDocs configuration\n\u251c\u2500\u2500 site/                    # Generated static site (gitignored)\n\u2502   \u2514\u2500\u2500 ... HTML files\n\u2514\u2500\u2500 src/backend/app/main.py  # FastAPI mounts site/ at /mkdocs (lines 440-443)\n</code></pre>"},{"location":"MKDOCS_UPDATE_GUIDE/#backend-configuration","title":"Backend Configuration","text":"<p>The FastAPI backend is configured to automatically serve MkDocs at <code>/mkdocs</code>:</p> <p>File: <code>src/backend/app/main.py</code> (lines 440-443) <pre><code># Mount MkDocs documentation\ndocs_dir = Path(__file__).parent.parent.parent.parent / \"site\"\nif docs_dir.exists():\n    app.mount(\"/mkdocs\", StaticFiles(directory=str(docs_dir), html=True), name=\"mkdocs\")\n    logger.info(f\"\u2713 MkDocs documentation mounted at /mkdocs from: {docs_dir}\")\n</code></pre></p> <p>This configuration is permanent and requires no additional setup.</p>"},{"location":"MKDOCS_UPDATE_GUIDE/#adding-new-documentation-pages","title":"Adding New Documentation Pages","text":""},{"location":"MKDOCS_UPDATE_GUIDE/#step-1-create-the-markdown-file","title":"Step 1: Create the Markdown file","text":"<pre><code># Example: Add a new troubleshooting guide\ncat &gt; docs/operations/troubleshooting.md &lt;&lt; 'EOF'\n# Troubleshooting Guide\n\n## Common Issues\n\n...\nEOF\n</code></pre>"},{"location":"MKDOCS_UPDATE_GUIDE/#step-2-update-mkdocsyml-navigation","title":"Step 2: Update mkdocs.yml navigation","text":"<p>Edit <code>mkdocs.yml</code> and add your new page to the appropriate section:</p> <pre><code>nav:\n  - Operations:\n      - Operations Runbook: operations/runbook.md\n      - Deployment &amp; Sizing: operations/deployment-sizing-guide.md\n      - Troubleshooting: operations/troubleshooting.md  # NEW\n      - Operational Scripts: operations/scripts/README.md\n</code></pre>"},{"location":"MKDOCS_UPDATE_GUIDE/#step-3-build-the-site","title":"Step 3: Build the site","text":"<pre><code>mkdocs build\n</code></pre> <p>The updated documentation will be immediately available at <code>http://localhost:8000/mkdocs/operations/troubleshooting/</code></p>"},{"location":"MKDOCS_UPDATE_GUIDE/#development-workflow","title":"Development Workflow","text":""},{"location":"MKDOCS_UPDATE_GUIDE/#local-development-with-live-reload","title":"Local Development with Live Reload","text":"<p>For rapid documentation development with live preview:</p> <pre><code># Option 1: Run MkDocs dev server on separate port\nmkdocs serve --dev-addr=0.0.0.0:8001\n# Access at: http://localhost:8001 (with live reload)\n\n# Option 2: Use the backend mount (requires rebuild)\nmkdocs build\n# Access at: http://localhost:8000/mkdocs/ (no live reload)\n</code></pre> <p>Recommendation: Use <code>mkdocs serve</code> during active documentation writing, then <code>mkdocs build</code> for final deployment.</p>"},{"location":"MKDOCS_UPDATE_GUIDE/#production-deployment","title":"Production Deployment","text":"<p>The production deployment process automatically builds MkDocs:</p> <pre><code># Included in deployment scripts\ncd /home/azureuser/esab_recommender-bh\nmkdocs build\nsudo systemctl restart esab-recommender.service\n</code></pre>"},{"location":"MKDOCS_UPDATE_GUIDE/#troubleshooting","title":"Troubleshooting","text":""},{"location":"MKDOCS_UPDATE_GUIDE/#documentation-not-updating","title":"Documentation not updating","text":"<pre><code># 1. Verify mkdocs.yml syntax\nmkdocs build --strict\n\n# 2. Check for build warnings\nmkdocs build 2&gt;&amp;1 | grep WARNING\n\n# 3. Force clean rebuild\nrm -rf site/\nmkdocs build\n\n# 4. Verify site directory exists\nls -la site/\n</code></pre>"},{"location":"MKDOCS_UPDATE_GUIDE/#404-errors-for-new-pages","title":"404 errors for new pages","text":"<ul> <li>Cause: Page not added to <code>mkdocs.yml</code> navigation</li> <li>Solution: Add the page to the <code>nav</code> section in <code>mkdocs.yml</code></li> </ul>"},{"location":"MKDOCS_UPDATE_GUIDE/#missing-dependencies","title":"Missing dependencies","text":"<pre><code># Install MkDocs and Material theme\npip install mkdocs mkdocs-material\n\n# Verify installation\nmkdocs --version\n</code></pre>"},{"location":"MKDOCS_UPDATE_GUIDE/#mkdocs-configuration","title":"MkDocs Configuration","text":"<p>Theme: Material for MkDocs (modern, responsive) Plugins: Search, mkdocstrings (API documentation) Extensions: Admonitions, code highlighting, Mermaid diagrams, tabbed content</p> <p>See <code>mkdocs.yml</code> for complete configuration.</p>"},{"location":"MKDOCS_UPDATE_GUIDE/#best-practices","title":"Best Practices","text":"<ol> <li>Navigation Organization: Group related docs logically (Architecture, Operations, etc.)</li> <li>File Naming: Use lowercase with hyphens (<code>deployment-sizing-guide.md</code>)</li> <li>Internal Links: Use relative paths (<code>../deployment/README.md</code>)</li> <li>Build Verification: Always run <code>mkdocs build</code> before committing to catch broken links</li> <li>Rebuild Frequency: Rebuild after any changes to docs or mkdocs.yml</li> </ol>"},{"location":"MKDOCS_UPDATE_GUIDE/#urls","title":"URLs","text":"<ul> <li>Local Development: http://localhost:8000/mkdocs/</li> <li>Production: http://your-server:8000/mkdocs/</li> <li>Dev Server (optional): http://localhost:8001/ (when using <code>mkdocs serve</code>)</li> </ul>"},{"location":"MKDOCS_UPDATE_GUIDE/#see-also","title":"See Also","text":"<ul> <li>MkDocs Documentation</li> <li>Material for MkDocs</li> <li>Markdown Guide</li> </ul>"},{"location":"MULTILINGUAL_FLOW/","title":"Multilingual Support - Complete Flow Documentation","text":""},{"location":"MULTILINGUAL_FLOW/#overview","title":"Overview","text":"<p>The Enterprise 3-Agent Agentic System includes comprehensive multilingual support that allows users to query in their native language and receive responses translated back to that language. The system supports 12 languages and automatically detects, translates, and adapts responses based on user expertise level.</p>"},{"location":"MULTILINGUAL_FLOW/#supported-languages","title":"Supported Languages","text":"<pre><code>class LanguageCode(str, Enum):\n    EN = \"en\"  # English (default)\n    ES = \"es\"  # Spanish\n    FR = \"fr\"  # French\n    DE = \"de\"  # German\n    PT = \"pt\"  # Portuguese\n    IT = \"it\"  # Italian\n    ZH = \"zh\"  # Chinese\n    JA = \"ja\"  # Japanese\n    KO = \"ko\"  # Korean\n    RU = \"ru\"  # Russian\n    AR = \"ar\"  # Arabic\n    HI = \"hi\"  # Hindi\n</code></pre> <p>File: <code>app/services/enterprise/enhanced_state_models.py:29-42</code></p>"},{"location":"MULTILINGUAL_FLOW/#complete-multilingual-flow","title":"Complete Multilingual Flow","text":""},{"location":"MULTILINGUAL_FLOW/#phase-1-language-detection-agent-1","title":"\ud83d\udd04 Phase 1: Language Detection (Agent 1)","text":"<p>Location: <code>app/services/enterprise/intelligent_intent_service.py:202-257</code></p>"},{"location":"MULTILINGUAL_FLOW/#step-11-user-query-input","title":"Step 1.1: User Query Input","text":"<pre><code># User submits query in any supported language\nquery = \"Necesito una m\u00e1quina de soldar MIG para acero\"  # Spanish\n</code></pre>"},{"location":"MULTILINGUAL_FLOW/#step-12-language-detection","title":"Step 1.2: Language Detection","text":"<pre><code>async def detect_language(self, query: str) -&gt; LanguageCode:\n    \"\"\"\n    Auto-detect language using keyword matching\n    \"\"\"\n    # Language-specific keyword sets\n    language_scores = {\n        \"es\": 0,  # Spanish\n        \"fr\": 0,  # French\n        \"de\": 0,  # German\n        \"en\": 0   # English (default)\n    }\n\n    # Spanish keywords\n    spanish_keywords = [\"necesito\", \"quiero\", \"para\", \"m\u00e1quina\", \"soldadura\"]\n\n    # Count keyword matches per language\n    for keyword in spanish_keywords:\n        if keyword.lower() in query.lower():\n            language_scores[\"es\"] += 1\n\n    # Return language with highest score\n    detected_lang = max(language_scores, key=language_scores.get)\n\n    return LanguageCode(detected_lang)\n</code></pre> <p>Output: <code>detected_language = LanguageCode.ES</code> (Spanish)</p>"},{"location":"MULTILINGUAL_FLOW/#phase-2-translation-to-english-agent-1","title":"\ud83d\udd04 Phase 2: Translation to English (Agent 1)","text":"<p>Location: <code>app/services/enterprise/intelligent_intent_service.py:259-320</code></p>"},{"location":"MULTILINGUAL_FLOW/#step-21-translate-query-to-english","title":"Step 2.1: Translate Query to English","text":"<pre><code>async def translate_to_english(\n    self,\n    query: str,\n    detected_language: LanguageCode\n) -&gt; str:\n    \"\"\"\n    Translate foreign language queries to English for processing\n    \"\"\"\n    if detected_language == LanguageCode.EN:\n        return query  # No translation needed\n\n    # Translation maps for each language\n    translation_maps = {\n        LanguageCode.ES: {\n            # Spanish \u2192 English\n            \"necesito\": \"I need\",\n            \"m\u00e1quina de soldar\": \"welding machine\",\n            \"soldadura\": \"welding\",\n            \"para\": \"for\",\n            \"acero\": \"steel\",\n            \"MIG\": \"MIG\",\n            \"TIG\": \"TIG\"\n        },\n        LanguageCode.FR: {\n            # French \u2192 English\n            \"j'ai besoin\": \"I need\",\n            \"machine \u00e0 souder\": \"welding machine\",\n            \"soudage\": \"welding\",\n            \"pour\": \"for\",\n            \"acier\": \"steel\"\n        },\n        LanguageCode.DE: {\n            # German \u2192 English\n            \"ich brauche\": \"I need\",\n            \"Schwei\u00dfmaschine\": \"welding machine\",\n            \"Schwei\u00dfen\": \"welding\",\n            \"f\u00fcr\": \"for\",\n            \"Stahl\": \"steel\"\n        }\n    }\n\n    # Apply translation\n    translated_query = query\n    if detected_language in translation_maps:\n        translation_map = translation_maps[detected_language]\n        for foreign_term, english_term in translation_map.items():\n            translated_query = translated_query.replace(foreign_term, english_term)\n\n    return translated_query\n</code></pre> <p>Input: <code>\"Necesito una m\u00e1quina de soldar MIG para acero\"</code> Output: <code>\"I need a welding machine MIG for steel\"</code></p>"},{"location":"MULTILINGUAL_FLOW/#phase-3-enhanced-intent-creation-agent-1","title":"\ud83d\udd04 Phase 3: Enhanced Intent Creation (Agent 1)","text":"<p>Location: <code>app/services/enterprise/intelligent_intent_service.py:367-400</code></p> <pre><code># Store both original and translated queries\nenhanced_intent = EnhancedProcessedIntent(\n    original_query=query,                    # Spanish: \"Necesito una...\"\n    processed_query=english_query,           # English: \"I need a...\"\n    detected_language=detected_language,     # LanguageCode.ES\n    language_detection_confidence=0.95,\n\n    # Extracted from English query\n    welding_process=[\"GMAW\"],\n    material=Material.STEEL,\n\n    # Auto-detected expertise\n    expertise_mode=ExpertiseMode.HYBRID,\n    mode_detection_confidence=0.85\n)\n</code></pre> <p>Output: Intent with language metadata preserved</p>"},{"location":"MULTILINGUAL_FLOW/#phase-4-neo4j-search-agent-2","title":"\ud83d\udd04 Phase 4: Neo4j Search (Agent 2)","text":"<p>Location: <code>app/services/enterprise/smart_neo4j_service.py</code></p> <pre><code># Agent 2 processes the ENGLISH query\n# Searches Neo4j using English-translated requirements\n# Returns Trinity packages with English product names/descriptions\n\nscored_recommendations = ScoredRecommendations(\n    packages=[\n        TrinityPackage(\n            power_source={\"product_name\": \"Aristo 500ix CE\", ...},\n            feeder={\"product_name\": \"Robust Feed 304\", ...},\n            cooler={\"product_name\": \"Cool 50 U42\", ...}\n        )\n    ]\n)\n</code></pre> <p>Note: Neo4j search happens in English. Product data in database is in English.</p>"},{"location":"MULTILINGUAL_FLOW/#phase-5-response-generation-in-english-agent-3","title":"\ud83d\udd04 Phase 5: Response Generation in English (Agent 3)","text":"<p>Location: <code>app/services/enterprise/multilingual_response_service.py:480-543</code></p>"},{"location":"MULTILINGUAL_FLOW/#step-51-generate-mode-aware-explanations","title":"Step 5.1: Generate Mode-Aware Explanations","text":"<pre><code># Generate explanations based on expertise mode\nif expertise_mode == ExpertiseMode.EXPERT:\n    explanations = {\n        \"technical_summary\": \"Optimal Trinity configuration identified...\",\n        \"compatibility_analysis\": \"Package 1: Trinity compliance...\",\n        \"performance_metrics\": \"Generated 3 packages, 3 Trinity-compliant...\"\n    }\nelif expertise_mode == ExpertiseMode.GUIDED:\n    explanations = {\n        \"beginner_summary\": \"I found a great welding package for you!...\",\n        \"component_education\": \"Understanding Your Welding Package...\",\n        \"usage_guidance\": \"Getting Started Tips...\"\n    }\n</code></pre>"},{"location":"MULTILINGUAL_FLOW/#step-52-format-response-in-english","title":"Step 5.2: Format Response in English","text":"<pre><code>formatted_response = MultilingualResponse(\n    title=\"Welding Package Recommendation\",\n    summary=\"Recommended Welding Package (Score: 95.0%)\",\n    detailed_explanation=\"**Power Source**: Aristo 500ix CE\\n**Wire Feeder**: Robust Feed 304\\n...\",\n    technical_notes=[\"This Trinity package ensures all components work together optimally.\"],\n    package_descriptions=[\"Package 1: Aristo 500ix CE system - $15,450.00 (Score: 95%)\"],\n    next_steps=[\"Review package details\", \"Check delivery options\", \"Contact sales if needed\"],\n    related_questions=[\"Are there other configurations available?\", \"What's the warranty coverage?\"],\n    response_language=LanguageCode.EN,  # Still in English\n    explanation_level=ExplanationLevel.BALANCED\n)\n</code></pre>"},{"location":"MULTILINGUAL_FLOW/#phase-6-translation-back-to-original-language-agent-3","title":"\ud83d\udd04 Phase 6: Translation Back to Original Language (Agent 3)","text":"<p>Location: <code>app/services/enterprise/multilingual_response_service.py:305-363</code></p>"},{"location":"MULTILINGUAL_FLOW/#step-61-check-if-translation-needed","title":"Step 6.1: Check if Translation Needed","text":"<pre><code># Original query was in Spanish (LanguageCode.ES)\nif original_intent.detected_language != LanguageCode.EN:\n    formatted_response = self.multilingual_translator.translate_response(\n        formatted_response,\n        original_intent.detected_language  # LanguageCode.ES\n    )\n</code></pre>"},{"location":"MULTILINGUAL_FLOW/#step-62-translate-response-to-spanish","title":"Step 6.2: Translate Response to Spanish","text":"<pre><code>class MultilingualTranslator:\n    def translate_response(\n        self,\n        response: MultilingualResponse,\n        target_language: LanguageCode\n    ) -&gt; MultilingualResponse:\n        \"\"\"Translate response back to user's original language\"\"\"\n\n        # Translation maps for key technical terms\n        translation_maps = {\n            LanguageCode.ES: {\n                \"Power Source\": \"Fuente de Poder\",\n                \"Wire Feeder\": \"Alimentador de Alambre\",\n                \"Cooling System\": \"Sistema de Enfriamiento\",\n                \"Total Package Price\": \"Precio Total del Paquete\",\n                \"Recommended\": \"Recomendado\",\n                \"Complete Trinity package\": \"Paquete Trinity Completo\",\n                \"Review package details\": \"Revisar detalles del paquete\",\n                \"Contact sales\": \"Contactar ventas\"\n            }\n        }\n\n        # Apply translations\n        translated_response = MultilingualResponse(\n            title=self._simple_translate(response.title, target_language),\n            summary=self._simple_translate(response.summary, target_language),\n            detailed_explanation=self._simple_translate(response.detailed_explanation, target_language),\n            technical_notes=[self._simple_translate(note, target_language) for note in response.technical_notes],\n            package_descriptions=[self._simple_translate(desc, target_language) for desc in response.package_descriptions],\n            next_steps=[self._simple_translate(step, target_language) for step in response.next_steps],\n            related_questions=[self._simple_translate(q, target_language) for q in response.related_questions],\n            response_language=target_language,  # LanguageCode.ES\n            explanation_level=response.explanation_level\n        )\n\n        return translated_response\n</code></pre> <p>Final Response in Spanish: <pre><code>MultilingualResponse(\n    title=\"Recomendado de Paquete de Soldadura\",\n    summary=\"Paquete de Soldadura Recomendado (Puntuaci\u00f3n: 95.0%)\",\n    detailed_explanation=\"**Fuente de Poder**: Aristo 500ix CE\\n**Alimentador de Alambre**: Robust Feed 304\\n...\",\n    technical_notes=[\"Este Paquete Trinity Completo asegura que todos los componentes funcionen juntos de manera \u00f3ptima.\"],\n    package_descriptions=[\"Paquete 1: Sistema Aristo 500ix CE - $15,450.00 (Puntuaci\u00f3n: 95%)\"],\n    next_steps=[\"Revisar detalles del paquete\", \"Verificar opciones de entrega\", \"Contactar ventas si es necesario\"],\n    related_questions=[\"\u00bfHay otras configuraciones disponibles?\", \"\u00bfCu\u00e1l es la cobertura de garant\u00eda?\"],\n    response_language=LanguageCode.ES,\n    explanation_level=ExplanationLevel.BALANCED\n)\n</code></pre></p>"},{"location":"MULTILINGUAL_FLOW/#expertise-based-response-adaptation","title":"Expertise-Based Response Adaptation","text":""},{"location":"MULTILINGUAL_FLOW/#expert-mode-expertisemodeexpert","title":"\ud83c\udfaf Expert Mode (ExpertiseMode.EXPERT)","text":"<p>Triggers: Technical keywords like \"amperage\", \"duty cycle\", \"GMAW\", \"DCEP\"</p> <p>Response Style: <pre><code>MultilingualResponse(\n    title=\"Technical Welding System Analysis\",\n    summary=\"Optimal Trinity configuration identified with 95.0% compatibility score. | PowerSource: Aristo 500ix CE | Wire Feeder: Robust Feed 304 | ...\",\n    detailed_explanation=\"Package 1: Trinity compliance True, Business rule compliance 92.5%, Compatibility score 0.95\",\n    technical_notes=[\"Generated 3 packages, 3 Trinity-compliant, Average score: 0.93\"],\n    next_steps=[\"Review technical specifications\", \"Validate power requirements\", \"Confirm installation requirements\"],\n    related_questions=[\"What are the duty cycle requirements?\", \"Do you need additional consumables?\"],\n    explanation_level=ExplanationLevel.TECHNICAL\n)\n</code></pre></p>"},{"location":"MULTILINGUAL_FLOW/#guided-mode-expertisemodeguided","title":"\ud83c\udf93 Guided Mode (ExpertiseMode.GUIDED)","text":"<p>Triggers: Keywords like \"beginner\", \"new to welding\", \"learning\", \"help me understand\"</p> <p>Response Style: <pre><code>MultilingualResponse(\n    title=\"Your Perfect Welding Package\",\n    summary=\"I found a great welding package for you! This complete setup includes everything you need:\\n\\n\ud83d\udd0c **Power Source**: Aristo 500ix CE - This is the main welding machine that provides the power.\\n\ud83d\udccb **Wire Feeder**: Robust Feed 304 - This feeds welding wire automatically so you can focus on your weld.\\n\u2744\ufe0f **Cooling System**: Cool 50 U42 - This keeps your torch cool during longer welding sessions.\",\n    detailed_explanation=\"**Understanding Your Welding Package:**\\n\ud83d\udd0c **Power Source (Welder)**: The heart of your setup - converts electricity into welding power\\n\ud83d\udccb **Wire Feeder**: Automatically feeds welding wire at the right speed (for MIG welding)\\n\u2744\ufe0f **Cooling System**: Prevents overheating during long welding sessions\\n\u26a1 **Why Trinity Matters**: These three components work together like a team\",\n    technical_notes=[\"**Getting Started Tips:**\\n\u2022 This setup is optimized for steel welding\\n\u2022 Start with practice pieces before your main project\\n\u2022 Make sure you have proper safety equipment\"],\n    next_steps=[\"Get safety equipment\", \"Consider training classes\", \"Plan your workspace\"],\n    related_questions=[\"What safety equipment do I need?\", \"Where can I learn welding?\"],\n    explanation_level=ExplanationLevel.EDUCATIONAL\n)\n</code></pre></p>"},{"location":"MULTILINGUAL_FLOW/#hybrid-mode-expertisemodehybrid","title":"\u2696\ufe0f Hybrid Mode (ExpertiseMode.HYBRID)","text":"<p>Default: Balanced technical and beginner-friendly information</p> <p>Response Style: <pre><code>MultilingualResponse(\n    title=\"Welding Package Recommendation\",\n    summary=\"**Recommended Welding Package** (Score: 95.0%)\\n**Power Source**: Aristo 500ix CE\\n**Wire Feeder**: Robust Feed 304\\n**Cooling**: Cool 50 U42\\n**Total**: $15,450.00\",\n    detailed_explanation=\"\u2705 Complete Trinity package (Power Source + Feeder + Cooler)\\n\u2705 Components verified for compatibility\\n\u2705 Business-grade quality and reliability\",\n    technical_notes=[\"Found 3 compatible packages. Top recommendation shown above.\"],\n    next_steps=[\"Review package details\", \"Check delivery options\", \"Contact sales if needed\"],\n    related_questions=[\"Are there other configurations available?\", \"What's the warranty coverage?\"],\n    explanation_level=ExplanationLevel.BALANCED\n)\n</code></pre></p>"},{"location":"MULTILINGUAL_FLOW/#complete-data-flow-diagram","title":"Complete Data Flow Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 USER INPUT                                                     \u2502\n\u2502 \"Necesito una m\u00e1quina de soldar MIG para acero\" (Spanish)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 AGENT 1: Intelligent Intent Service                           \u2502\n\u2502                                                                \u2502\n\u2502 Step 1: Language Detection                                    \u2502\n\u2502   \u251c\u2500 Keyword matching \u2192 LanguageCode.ES (Spanish)            \u2502\n\u2502   \u2514\u2500 Confidence: 95%                                          \u2502\n\u2502                                                                \u2502\n\u2502 Step 2: Translation to English                                \u2502\n\u2502   \u251c\u2500 Input: \"Necesito una m\u00e1quina de soldar MIG para acero\"  \u2502\n\u2502   \u2514\u2500 Output: \"I need a welding machine MIG for steel\"        \u2502\n\u2502                                                                \u2502\n\u2502 Step 3: Expertise Detection                                   \u2502\n\u2502   \u251c\u2500 Expert signals: 0                                        \u2502\n\u2502   \u251c\u2500 Guided signals: 0                                        \u2502\n\u2502   \u2514\u2500 Mode: ExpertiseMode.HYBRID (default)                    \u2502\n\u2502                                                                \u2502\n\u2502 Step 4: Intent Extraction (from English query)               \u2502\n\u2502   \u251c\u2500 Welding Process: GMAW (MIG)                            \u2502\n\u2502   \u251c\u2500 Material: STEEL                                          \u2502\n\u2502   \u2514\u2500 Confidence: 0.85                                         \u2502\n\u2502                                                                \u2502\n\u2502 OUTPUT: EnhancedProcessedIntent                               \u2502\n\u2502   - original_query: \"Necesito una...\" (Spanish)              \u2502\n\u2502   - processed_query: \"I need a...\" (English)                 \u2502\n\u2502   - detected_language: LanguageCode.ES                        \u2502\n\u2502   - expertise_mode: ExpertiseMode.HYBRID                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 AGENT 2: Smart Neo4j Service                                  \u2502\n\u2502                                                                \u2502\n\u2502 Step 1: Search Strategy Selection                             \u2502\n\u2502   \u2514\u2500 Strategy: HYBRID (semantic + graph)                     \u2502\n\u2502                                                                \u2502\n\u2502 Step 2: Neo4j Query Execution (in English)                   \u2502\n\u2502   \u251c\u2500 Search for: MIG welding, steel material               \u2502\n\u2502   \u251c\u2500 Algorithm: Trinity Semantic Search                      \u2502\n\u2502   \u2514\u2500 Results: 3 compatible Trinity packages                  \u2502\n\u2502                                                                \u2502\n\u2502 Step 3: Package Scoring &amp; Ranking                            \u2502\n\u2502   \u251c\u2500 Trinity compliance check                                \u2502\n\u2502   \u251c\u2500 Compatibility scoring                                   \u2502\n\u2502   \u2514\u2500 Business rules application                              \u2502\n\u2502                                                                \u2502\n\u2502 OUTPUT: ScoredRecommendations                                 \u2502\n\u2502   - packages: [TrinityPackage(Aristo 500ix CE, ...)]        \u2502\n\u2502   - trinity_formation_rate: 1.0 (100%)                       \u2502\n\u2502   - total_packages_found: 3                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 AGENT 3: Multilingual Response Service                        \u2502\n\u2502                                                                \u2502\n\u2502 Step 1: Business Context Re-ranking                           \u2502\n\u2502   \u251c\u2500 User: Anonymous                                          \u2502\n\u2502   \u251c\u2500 Organization: None                                       \u2502\n\u2502   \u2514\u2500 Priority: ESAB products, Trinity compliance             \u2502\n\u2502                                                                \u2502\n\u2502 Step 2: Mode-Aware Explanation Generation                    \u2502\n\u2502   \u251c\u2500 Mode: ExpertiseMode.HYBRID                              \u2502\n\u2502   \u2514\u2500 Explanations: Balanced technical + beginner-friendly    \u2502\n\u2502                                                                \u2502\n\u2502 Step 3: Response Formatting (in English)                     \u2502\n\u2502   \u251c\u2500 Title: \"Welding Package Recommendation\"                \u2502\n\u2502   \u251c\u2500 Summary: \"Recommended Welding Package (Score: 95%)\"    \u2502\n\u2502   \u2514\u2500 Details: PowerSource, Feeder, Cooler info              \u2502\n\u2502                                                                \u2502\n\u2502 Step 4: Translation to Original Language (Spanish)           \u2502\n\u2502   \u251c\u2500 Detect: detected_language = LanguageCode.ES            \u2502\n\u2502   \u251c\u2500 Translate: Apply Spanish translation map               \u2502\n\u2502   \u2502    - \"Power Source\" \u2192 \"Fuente de Poder\"                \u2502\n\u2502   \u2502    - \"Wire Feeder\" \u2192 \"Alimentador de Alambre\"          \u2502\n\u2502   \u2502    - \"Cooling System\" \u2192 \"Sistema de Enfriamiento\"      \u2502\n\u2502   \u2514\u2500 Output: MultilingualResponse (Spanish)                 \u2502\n\u2502                                                                \u2502\n\u2502 OUTPUT: EnterpriseRecommendationResponse                      \u2502\n\u2502   - formatted_response: MultilingualResponse (Spanish)       \u2502\n\u2502   - packages: [TrinityPackage(...)]                          \u2502\n\u2502   - overall_confidence: 0.92                                 \u2502\n\u2502   - trace_id: \"abc123\"                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 API RESPONSE (to user)                                         \u2502\n\u2502                                                                \u2502\n\u2502 {                                                              \u2502\n\u2502   \"formatted_response\": {                                     \u2502\n\u2502     \"title\": \"Recomendado de Paquete de Soldadura\",         \u2502\n\u2502     \"summary\": \"Paquete de Soldadura Recomendado...\",       \u2502\n\u2502     \"detailed_explanation\": \"**Fuente de Poder**: Aristo...\",\u2502\n\u2502     \"response_language\": \"es\",                               \u2502\n\u2502     \"explanation_level\": \"balanced\"                          \u2502\n\u2502   },                                                           \u2502\n\u2502   \"packages\": [...],                                          \u2502\n\u2502   \"overall_confidence\": 0.92                                  \u2502\n\u2502 }                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"MULTILINGUAL_FLOW/#key-files-reference","title":"Key Files Reference","text":"File Purpose Key Functions <code>enhanced_state_models.py:29-42</code> Language code definitions <code>LanguageCode</code> enum <code>intelligent_intent_service.py:202-320</code> Language detection &amp; translation <code>detect_language()</code>, <code>translate_to_english()</code> <code>multilingual_response_service.py:305-363</code> Response translation <code>translate_response()</code>, <code>_simple_translate()</code> <code>multilingual_response_service.py:27-243</code> Mode-aware explanations <code>generate_explanations()</code>, <code>_generate_expert_explanations()</code>, <code>_generate_guided_explanations()</code>"},{"location":"MULTILINGUAL_FLOW/#current-implementation-status","title":"Current Implementation Status","text":""},{"location":"MULTILINGUAL_FLOW/#implemented","title":"\u2705 Implemented","text":"<ul> <li>Language detection via keyword matching (12 languages)</li> <li>Translation to English for processing</li> <li>Mode-aware response generation (Expert/Guided/Hybrid)</li> <li>Translation back to original language</li> <li>Spanish, French, German translation maps</li> </ul>"},{"location":"MULTILINGUAL_FLOW/#mvp-limitations","title":"\u26a0\ufe0f MVP Limitations","text":"<ul> <li>Simple keyword-based translation (not professional-grade)</li> <li>Limited vocabulary in translation maps</li> <li>No full sentence structure translation</li> <li>Product names/descriptions remain in English (from database)</li> </ul>"},{"location":"MULTILINGUAL_FLOW/#future-enhancements","title":"\ud83d\ude80 Future Enhancements","text":"<ul> <li>Integration with professional translation API (Google Translate, DeepL)</li> <li>Multilingual product database</li> <li>Cultural adaptation beyond language translation</li> <li>Sentiment analysis for better expertise detection</li> <li>Dynamic translation quality scoring</li> </ul>"},{"location":"MULTILINGUAL_FLOW/#usage-example","title":"Usage Example","text":""},{"location":"MULTILINGUAL_FLOW/#request-spanish","title":"Request (Spanish)","text":"<pre><code>POST /api/v1/enterprise/orchestrator/recommend\n{\n  \"query\": \"Necesito una m\u00e1quina de soldar MIG de 500 amperios para acero inoxidable\",\n  \"user_context\": {\n    \"user_id\": \"user_123\",\n    \"preferred_language\": \"es\"\n  }\n}\n</code></pre>"},{"location":"MULTILINGUAL_FLOW/#response-spanish-with-english-product-names","title":"Response (Spanish with English product names)","text":"<pre><code>{\n  \"formatted_response\": {\n    \"title\": \"Recomendado de Paquete de Soldadura\",\n    \"summary\": \"Paquete de Soldadura Recomendado (Puntuaci\u00f3n: 95.0%)\\n\\n**Fuente de Poder**: Aristo 500ix CE\\n**Alimentador de Alambre**: Robust Feed 304\\n**Sistema de Enfriamiento**: Cool 50 U42\\n**Total**: $15,450.00\",\n    \"detailed_explanation\": \"\u2705 Paquete Trinity Completo (Fuente de Poder + Alimentador + Sistema de Enfriamiento)\\n\u2705 Componentes verificados para compatibilidad\\n\u2705 Calidad y fiabilidad de grado empresarial\",\n    \"response_language\": \"es\",\n    \"explanation_level\": \"balanced\"\n  },\n  \"overall_confidence\": 0.92,\n  \"original_intent\": {\n    \"original_query\": \"Necesito una m\u00e1quina de soldar MIG de 500 amperios para acero inoxidable\",\n    \"processed_query\": \"I need a MIG welding machine of 500 amps for stainless steel\",\n    \"detected_language\": \"es\"\n  }\n}\n</code></pre>"},{"location":"MULTILINGUAL_FLOW/#summary","title":"Summary","text":"<p>The multilingual system provides a complete translation pipeline from user input to final response:</p> <ol> <li>Agent 1: Detects language \u2192 Translates to English \u2192 Extracts intent</li> <li>Agent 2: Processes English query \u2192 Searches Neo4j \u2192 Returns results</li> <li>Agent 3: Generates English response \u2192 Translates to original language \u2192 Returns to user</li> </ol> <p>This approach ensures: - \u2705 All processing happens in English (Neo4j data is English) - \u2705 Users interact in their native language - \u2705 Responses adapt to expertise level AND language - \u2705 Full transparency with original and processed queries tracked</p>"},{"location":"OBSERVABILITY/","title":"Observability Architecture - LangSmith Integration","text":"<p>File: <code>src/backend/app/services/observability/langsmith_service.py</code></p> <p>The Observability System provides workflow tracing, performance monitoring, and error tracking through LangSmith integration.</p>"},{"location":"OBSERVABILITY/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Architecture Pattern</li> <li>Core Features</li> <li>@traceable Decorator</li> <li>Tracing Methods</li> <li>Environment Configuration</li> <li>Usage Examples</li> <li>LangSmith UI</li> <li>Related Documentation</li> </ul>"},{"location":"OBSERVABILITY/#overview","title":"Overview","text":"<p>The LangSmith observability service enables:</p> <ul> <li>Automatic Tracing: <code>@traceable</code> decorator for method instrumentation</li> <li>Performance Metrics: Execution time, token usage, success rates</li> <li>Error Monitoring: Exception tracking with context</li> <li>Agent Action Logging: Track Agent 1, 2, 3 operations</li> <li>Workflow Visualization: End-to-end conversation flow in LangSmith UI</li> </ul> <p>Architecture: Singleton Pattern + Decorator-Based Tracing</p> <pre><code>Application Code (@traceable methods)\n    \u2193\nLangSmith Client (Auto-instrumentation)\n    \u2193\nLangSmith API (https://api.smith.langchain.com)\n    \u2193\nLangSmith UI Dashboard\n</code></pre>"},{"location":"OBSERVABILITY/#architecture-pattern","title":"Architecture Pattern","text":""},{"location":"OBSERVABILITY/#singleton-pattern","title":"Singleton Pattern","text":"<p>Implementation (<code>langsmith_service.py:216-225</code>):</p> <pre><code># Global service instance - initialized lazily after .env is loaded\nlangsmith_service = None\n\ndef get_langsmith_service() -&gt; LangSmithService:\n    \"\"\"Get or create the LangSmith service instance.\"\"\"\n    global langsmith_service\n    if langsmith_service is None:\n        langsmith_service = LangSmithService()\n    return langsmith_service\n</code></pre> <p>Benefits: - Single LangSmith client instance across application - Shared connection pool for API requests - Consistent project/environment configuration - Lazy initialization (only created when first accessed)</p>"},{"location":"OBSERVABILITY/#decorator-based-tracing","title":"Decorator-Based Tracing","text":"<p>Pattern: <code>@traceable</code> decorator automatically instruments methods</p> <p>Automatic Capture: - Method inputs (function arguments) - Method outputs (return values) - Execution duration - Error messages (if exception occurs) - Call stack relationships (parent-child traces)</p> <p>Example: <pre><code>from langsmith import traceable\n\n@traceable(name=\"extract_parameters\", run_type=\"llm\")\nasync def extract_parameters(self, user_message: str, current_state: str):\n    # Method implementation\n    return extracted_parameters\n\n# LangSmith automatically logs:\n# - Input: user_message, current_state\n# - Output: extracted_parameters\n# - Duration: execution time in ms\n# - Parent trace: if called from another @traceable method\n</code></pre></p>"},{"location":"OBSERVABILITY/#core-features","title":"Core Features","text":""},{"location":"OBSERVABILITY/#1-automatic-environment-variable-configuration","title":"1. Automatic Environment Variable Configuration","text":"<p>Initialization (<code>langsmith_service.py:31-56</code>):</p> <pre><code>def __init__(self):\n    \"\"\"Initialize LangSmith client with .env configuration.\"\"\"\n    self.api_key = os.getenv(\"LANGSMITH_API_KEY\")\n    self.project = os.getenv(\"LANGSMITH_PROJECT\", \"Recommender\")\n    self.enable_tracing = os.getenv(\"LANGSMITH_TRACING\", \"true\").lower() == \"true\"\n\n    # Initialize client\n    if self.api_key and self.enable_tracing:\n        try:\n            self.client = Client(api_key=self.api_key)\n\n            # Set environment variables for @traceable decorator\n            os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"\n            os.environ[\"LANGCHAIN_API_KEY\"] = self.api_key\n            os.environ[\"LANGCHAIN_PROJECT\"] = self.project\n            os.environ[\"LANGCHAIN_ENDPOINT\"] = \"https://api.smith.langchain.com\"\n\n            logger.info(f\"LangSmith initialized for project: {self.project}\")\n            logger.info(\"\u2713 LangSmith tracing enabled with environment variables\")\n        except Exception as e:\n            logger.warning(f\"LangSmith client initialization failed: {e}\")\n            self.client = None\n    else:\n        self.client = None\n        logger.info(\"LangSmith tracing disabled\")\n</code></pre> <p>Environment Variables Set: - <code>LANGCHAIN_TRACING_V2=true</code> - Enable LangSmith tracing v2 - <code>LANGCHAIN_API_KEY</code> - API key for authentication - <code>LANGCHAIN_PROJECT</code> - Project name for trace organization - <code>LANGCHAIN_ENDPOINT</code> - LangSmith API endpoint</p>"},{"location":"OBSERVABILITY/#2-workflow-execution-tracking","title":"2. Workflow Execution Tracking","text":"<p>Method: <code>track_workflow_execution()</code> (<code>langsmith_service.py:61-109</code>)</p> <p>Purpose: Track complete configurator workflow execution in LangSmith</p> <p>Tracked Metrics: - Session ID - Current state - User message - AI response - Checkpoint count (for LangGraph) - Total message count - Error status - Agent action count - Neo4j query count - LLM extraction count</p> <p>Example: <pre><code>@traceable(name=\"configurator_workflow\", run_type=\"chain\")\nasync def track_workflow_execution(\n    self,\n    session_id: str,\n    user_message: str,\n    current_state: str,\n    result: Dict[str, Any]\n):\n    \"\"\"Track complete workflow execution in LangSmith.\"\"\"\n\n    workflow_metrics = {\n        \"session_id\": session_id,\n        \"current_state\": current_state,\n        \"user_message\": user_message,\n        \"ai_response\": result.get(\"ai_response\", \"\"),\n        \"checkpoint_count\": result.get(\"checkpoint_count\", 0),\n        \"total_messages\": len(result.get(\"messages\", [])),\n        \"had_error\": result.get(\"error\") is not None,\n        \"timestamp\": datetime.utcnow().isoformat()\n    }\n\n    # Additional agent metrics\n    if \"agent_actions\" in result:\n        workflow_metrics[\"agent_action_count\"] = len(result[\"agent_actions\"])\n\n    if \"neo4j_queries\" in result:\n        workflow_metrics[\"neo4j_query_count\"] = len(result[\"neo4j_queries\"])\n\n    if \"llm_extractions\" in result:\n        workflow_metrics[\"llm_extraction_count\"] = len(result[\"llm_extractions\"])\n\n    logger.info(f\"LangSmith workflow tracked: {workflow_metrics}\")\n</code></pre></p>"},{"location":"OBSERVABILITY/#3-agent-action-logging","title":"3. Agent Action Logging","text":"<p>Method: <code>log_agent_action()</code> (<code>langsmith_service.py:110-151</code>)</p> <p>Purpose: Log individual agent operations (Agent 1, 2, 3)</p> <p>Logged Data: - Agent type (parameter_extractor, product_searcher, response_generator) - Action name (extract_parameters, search_by_component, generate_message) - Input data - Output data - Duration (ms) - Success status - Error message (if failed)</p> <p>Example: <pre><code>def log_agent_action(\n    self,\n    action_type: str,\n    action_name: str,\n    input_data: Dict[str, Any],\n    output_data: Optional[Dict[str, Any]],\n    duration_ms: int,\n    success: bool,\n    error: Optional[str] = None\n):\n    \"\"\"Log individual agent action to LangSmith.\"\"\"\n\n    action_log = {\n        \"agent_type\": action_type,\n        \"action\": action_name,\n        \"input\": input_data,\n        \"output\": output_data,\n        \"duration_ms\": duration_ms,\n        \"success\": success,\n        \"error\": error,\n        \"timestamp\": datetime.utcnow().isoformat()\n    }\n\n    logger.info(f\"Agent action logged: {action_log}\")\n</code></pre></p>"},{"location":"OBSERVABILITY/#4-performance-metrics-logging","title":"4. Performance Metrics Logging","text":"<p>Method: <code>log_performance_metrics()</code> (<code>langsmith_service.py:153-179</code>)</p> <p>Purpose: Log performance metrics for monitoring</p> <p>Metrics: - Session ID - Execution time - Token usage - Database query count - Cache hit rate - Custom metrics</p> <p>Example: <pre><code>def log_performance_metrics(\n    self,\n    session_id: str,\n    metrics: Dict[str, Any]\n):\n    \"\"\"Log performance metrics to LangSmith.\"\"\"\n\n    perf_log = {\n        \"session_id\": session_id,\n        \"metrics\": metrics,\n        \"timestamp\": datetime.utcnow().isoformat()\n    }\n\n    logger.info(f\"Performance metrics logged: {perf_log}\")\n</code></pre></p>"},{"location":"OBSERVABILITY/#5-error-logging","title":"5. Error Logging","text":"<p>Method: <code>log_error()</code> (<code>langsmith_service.py:181-213</code>)</p> <p>Purpose: Log errors for monitoring and alerting</p> <p>Logged Data: - Session ID - Error type - Error message - Context (current state, user message, stack trace)</p> <p>Example: <pre><code>def log_error(\n    self,\n    session_id: str,\n    error_type: str,\n    error_message: str,\n    context: Dict[str, Any]\n):\n    \"\"\"Log error to LangSmith for monitoring.\"\"\"\n\n    error_log = {\n        \"session_id\": session_id,\n        \"error_type\": error_type,\n        \"error_message\": error_message,\n        \"context\": context,\n        \"timestamp\": datetime.utcnow().isoformat()\n    }\n\n    logger.error(f\"Error logged to LangSmith: {error_log}\")\n</code></pre></p>"},{"location":"OBSERVABILITY/#traceable-decorator","title":"@traceable Decorator","text":""},{"location":"OBSERVABILITY/#overview_1","title":"Overview","text":"<p>The <code>@traceable</code> decorator automatically instruments methods for LangSmith tracing.</p> <p>Import: <pre><code>from langsmith import traceable\n</code></pre></p>"},{"location":"OBSERVABILITY/#decorator-parameters","title":"Decorator Parameters","text":""},{"location":"OBSERVABILITY/#name-required","title":"<code>name</code> (required)","text":"<p>Human-readable name for the trace (appears in LangSmith UI).</p> <p>Example: <pre><code>@traceable(name=\"extract_parameters\", run_type=\"llm\")\nasync def extract_parameters(...):\n    pass\n</code></pre></p>"},{"location":"OBSERVABILITY/#run_type-required","title":"<code>run_type</code> (required)","text":"<p>Type of operation being traced. Common values:</p> <ul> <li>\"llm\": LLM API calls (OpenAI, Anthropic)</li> <li>\"chain\": Multi-step workflows</li> <li>\"retriever\": Database queries (Neo4j, PostgreSQL)</li> <li>\"tool\": Tool/function calls</li> </ul> <p>Example: <pre><code>@traceable(name=\"search_products\", run_type=\"retriever\")\nasync def search_products(...):\n    # Neo4j query\n    pass\n</code></pre></p>"},{"location":"OBSERVABILITY/#automatic-data-capture","title":"Automatic Data Capture","text":"<p>Inputs: Function arguments captured automatically</p> <pre><code>@traceable(name=\"extract_parameters\", run_type=\"llm\")\nasync def extract_parameters(self, user_message: str, current_state: str):\n    # LangSmith captures: user_message, current_state\n    pass\n</code></pre> <p>Outputs: Return values captured automatically</p> <pre><code>@traceable(name=\"search_products\", run_type=\"retriever\")\nasync def search_products(self, component_type: str):\n    products = await self.neo4j_query(...)\n    return products  # LangSmith captures return value\n</code></pre> <p>Errors: Exceptions captured automatically</p> <pre><code>@traceable(name=\"extract_parameters\", run_type=\"llm\")\nasync def extract_parameters(self, user_message: str):\n    try:\n        result = await openai_call(...)\n        return result\n    except Exception as e:\n        # LangSmith captures exception type and message\n        raise\n</code></pre>"},{"location":"OBSERVABILITY/#parent-child-traces","title":"Parent-Child Traces","text":"<p>LangSmith automatically tracks call hierarchies:</p> <pre><code>@traceable(name=\"orchestrator_process_message\", run_type=\"chain\")\nasync def process_message(self, user_message: str):\n    # Parent trace\n\n    # Child trace 1\n    parameters = await self.parameter_extractor.extract_parameters(user_message)\n\n    # Child trace 2\n    products = await self.product_search.search(parameters)\n\n    # Child trace 3\n    response = await self.message_generator.generate(products)\n\n    return response\n\n@traceable(name=\"extract_parameters\", run_type=\"llm\")\nasync def extract_parameters(self, user_message: str):\n    # This becomes a child trace of process_message\n    pass\n</code></pre> <p>LangSmith UI Hierarchy: <pre><code>orchestrator_process_message (parent)\n\u251c\u2500\u2500 extract_parameters (child 1)\n\u251c\u2500\u2500 search_products (child 2)\n\u2514\u2500\u2500 generate_response (child 3)\n</code></pre></p>"},{"location":"OBSERVABILITY/#tracing-methods","title":"Tracing Methods","text":""},{"location":"OBSERVABILITY/#agent-1-parameter-extractor","title":"Agent 1: Parameter Extractor","text":"<p>Method: <code>ParameterExtractor.extract_parameters()</code></p> <p>File: <code>src/backend/app/services/intent/parameter_extractor.py</code></p> <p>Decorator: <pre><code>@traceable(name=\"extract_parameters\", run_type=\"llm\")\nasync def extract_parameters(\n    self,\n    user_message: str,\n    current_state: str,\n    master_parameters: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"Extract parameters from user message using GPT-4.\"\"\"\n    # LLM call to OpenAI\n    response = await self.openai_client.chat.completions.create(...)\n    return extracted_parameters\n</code></pre></p> <p>Traced Data: - Input: user_message, current_state, master_parameters - Output: extracted_parameters dict - Model: gpt-4 - Token usage (if available from OpenAI response) - Duration</p>"},{"location":"OBSERVABILITY/#agent-2-product-search","title":"Agent 2: Product Search","text":"<p>Method: <code>Neo4jProductSearch.search_power_source()</code> (and others)</p> <p>File: <code>src/backend/app/services/neo4j/product_search.py</code></p> <p>Decorator: <pre><code>@traceable(name=\"search_products_power_source\", run_type=\"retriever\")\nasync def search_power_source(\n    self,\n    user_message: str,\n    master_parameters: Dict[str, Any],\n    limit: int = 10\n) -&gt; Dict[str, Any]:\n    \"\"\"Search for power sources in Neo4j.\"\"\"\n    # Neo4j query\n    results = await self.neo4j_query(...)\n    return results\n</code></pre></p> <p>Traced Data: - Input: user_message, master_parameters, limit - Output: search results (products list, total_count) - Query executed - Duration</p>"},{"location":"OBSERVABILITY/#agent-3-message-generator","title":"Agent 3: Message Generator","text":"<p>Method: <code>MessageGenerator.generate_response()</code></p> <p>File: <code>src/backend/app/services/response/message_generator.py</code></p> <p>Decorator: <pre><code>@traceable(name=\"generate_response\", run_type=\"llm\")\nasync def generate_response(\n    self,\n    current_state: str,\n    search_results: List[Dict],\n    language: str = \"en\"\n) -&gt; str:\n    \"\"\"Generate user-friendly response using GPT-4o-mini.\"\"\"\n    # LLM call for response generation\n    response = await self.openai_client.chat.completions.create(...)\n    return response_text\n</code></pre></p> <p>Traced Data: - Input: current_state, search_results, language - Output: response_text string - Model: gpt-4o-mini - Token usage - Duration</p>"},{"location":"OBSERVABILITY/#statebystateorchestrator","title":"StateByStateOrchestrator","text":"<p>Method: <code>StateByStateOrchestrator.process_message()</code></p> <p>File: <code>src/backend/app/services/orchestrator/state_orchestrator.py</code></p> <p>Decorator: <pre><code>@traceable(name=\"orchestrator_process_message\", run_type=\"chain\")\nasync def process_message(\n    self,\n    conversation_state: ConversationState,\n    user_message: str,\n    last_shown_products: Optional[List[Dict]] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"Process user message through 3-agent workflow.\"\"\"\n    # Coordinates Agent 1, 2, 3\n    # Creates parent trace for all agent operations\n    pass\n</code></pre></p> <p>Traced Data: - Input: conversation_state, user_message - Output: complete response dict - Child traces: All agent operations - Duration (total workflow time)</p>"},{"location":"OBSERVABILITY/#environment-configuration","title":"Environment Configuration","text":""},{"location":"OBSERVABILITY/#required-variables","title":"Required Variables","text":"<p><code>.env</code> file (src/backend/.env):</p> <pre><code># LangSmith Configuration\nLANGSMITH_API_KEY=lsv2_pt_xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nLANGSMITH_PROJECT=Recommender\nLANGSMITH_TRACING=true\n</code></pre>"},{"location":"OBSERVABILITY/#variable-details","title":"Variable Details","text":""},{"location":"OBSERVABILITY/#langsmith_api_key","title":"<code>LANGSMITH_API_KEY</code>","text":"<p>Purpose: Authentication for LangSmith API</p> <p>How to Get: 1. Sign up at https://smith.langchain.com 2. Navigate to Settings \u2192 API Keys 3. Create new API key 4. Copy key (starts with <code>lsv2_pt_</code>)</p> <p>Format: <code>lsv2_pt_</code> + 32-character alphanumeric string</p>"},{"location":"OBSERVABILITY/#langsmith_project","title":"<code>LANGSMITH_PROJECT</code>","text":"<p>Purpose: Project name for organizing traces</p> <p>Default: \"Recommender\"</p> <p>Customization: - Use different project names for dev/staging/production - Example: \"Recommender-Dev\", \"Recommender-Prod\"</p>"},{"location":"OBSERVABILITY/#langsmith_tracing","title":"<code>LANGSMITH_TRACING</code>","text":"<p>Purpose: Enable/disable tracing</p> <p>Values: - <code>true</code> - Enable tracing (default) - <code>false</code> - Disable tracing (no LangSmith API calls)</p> <p>Use Cases: - Set to <code>false</code> for local development without LangSmith account - Set to <code>false</code> to reduce API costs - Set to <code>true</code> for production observability</p>"},{"location":"OBSERVABILITY/#graceful-degradation","title":"Graceful Degradation","text":"<p>If LangSmith is not configured:</p> <pre><code>if not self.api_key or not self.enable_tracing:\n    self.client = None\n    logger.info(\"LangSmith tracing disabled\")\n</code></pre> <p>Behavior: - Application continues running normally - No LangSmith API calls made - <code>@traceable</code> decorators are no-ops (no overhead) - Logging still works via Python logging module</p>"},{"location":"OBSERVABILITY/#usage-examples","title":"Usage Examples","text":""},{"location":"OBSERVABILITY/#example-1-basic-tracing-setup","title":"Example 1: Basic Tracing Setup","text":"<pre><code># 1. Configure environment variables\n# .env file:\nLANGSMITH_API_KEY=lsv2_pt_your_key_here\nLANGSMITH_PROJECT=Recommender\nLANGSMITH_TRACING=true\n\n# 2. Initialize service (automatic in main.py)\nfrom app.services.observability.langsmith_service import get_langsmith_service\n\nlangsmith_service = get_langsmith_service()\n\n# 3. Add @traceable decorator to methods\nfrom langsmith import traceable\n\n@traceable(name=\"my_function\", run_type=\"llm\")\nasync def my_function(user_input: str):\n    # Your code here\n    return result\n\n# 4. LangSmith automatically captures:\n# - Input: user_input\n# - Output: result\n# - Duration\n# - Any errors\n</code></pre>"},{"location":"OBSERVABILITY/#example-2-workflow-tracking","title":"Example 2: Workflow Tracking","text":"<pre><code>from app.services.observability.langsmith_service import get_langsmith_service\n\nlangsmith_service = get_langsmith_service()\n\n# Track complete workflow execution\nawait langsmith_service.track_workflow_execution(\n    session_id=\"session-123\",\n    user_message=\"I need a 500A MIG welder\",\n    current_state=\"power_source_selection\",\n    result={\n        \"ai_response\": \"Here are some power sources...\",\n        \"checkpoint_count\": 3,\n        \"messages\": [...],\n        \"agent_actions\": [...]\n    }\n)\n\n# View in LangSmith UI:\n# - Session ID: session-123\n# - Message: \"I need a 500A MIG welder\"\n# - State: power_source_selection\n# - Response: \"Here are some power sources...\"\n# - Metrics: 3 checkpoints, X messages, Y agent actions\n</code></pre>"},{"location":"OBSERVABILITY/#example-3-agent-action-logging","title":"Example 3: Agent Action Logging","text":"<pre><code>import time\nfrom app.services.observability.langsmith_service import get_langsmith_service\n\nlangsmith_service = get_langsmith_service()\n\n# Track agent operation\nstart_time = time.time()\n\ntry:\n    # Agent 1: Parameter extraction\n    parameters = await parameter_extractor.extract_parameters(\n        user_message=\"I need a 500A MIG welder\",\n        current_state=\"power_source_selection\"\n    )\n\n    duration_ms = int((time.time() - start_time) * 1000)\n\n    # Log successful action\n    langsmith_service.log_agent_action(\n        action_type=\"parameter_extractor\",\n        action_name=\"extract_parameters\",\n        input_data={\n            \"user_message\": \"I need a 500A MIG welder\",\n            \"current_state\": \"power_source_selection\"\n        },\n        output_data={\"parameters\": parameters},\n        duration_ms=duration_ms,\n        success=True,\n        error=None\n    )\n\nexcept Exception as e:\n    duration_ms = int((time.time() - start_time) * 1000)\n\n    # Log failed action\n    langsmith_service.log_agent_action(\n        action_type=\"parameter_extractor\",\n        action_name=\"extract_parameters\",\n        input_data={\n            \"user_message\": \"I need a 500A MIG welder\",\n            \"current_state\": \"power_source_selection\"\n        },\n        output_data=None,\n        duration_ms=duration_ms,\n        success=False,\n        error=str(e)\n    )\n</code></pre>"},{"location":"OBSERVABILITY/#example-4-performance-metrics","title":"Example 4: Performance Metrics","text":"<pre><code>from app.services.observability.langsmith_service import get_langsmith_service\n\nlangsmith_service = get_langsmith_service()\n\n# Log performance metrics\nlangsmith_service.log_performance_metrics(\n    session_id=\"session-123\",\n    metrics={\n        \"total_execution_time_ms\": 1250,\n        \"llm_calls\": 2,\n        \"llm_tokens_used\": 1500,\n        \"neo4j_queries\": 3,\n        \"neo4j_query_time_ms\": 450,\n        \"cache_hits\": 5,\n        \"cache_misses\": 2\n    }\n)\n\n# View in LangSmith UI:\n# - Session: session-123\n# - Total time: 1.25s\n# - LLM: 2 calls, 1500 tokens\n# - Neo4j: 3 queries, 450ms\n# - Cache: 71% hit rate (5/7)\n</code></pre>"},{"location":"OBSERVABILITY/#example-5-error-logging","title":"Example 5: Error Logging","text":"<pre><code>from app.services.observability.langsmith_service import get_langsmith_service\n\nlangsmith_service = get_langsmith_service()\n\ntry:\n    # Some operation that might fail\n    result = await risky_operation()\nexcept Exception as e:\n    # Log error with context\n    langsmith_service.log_error(\n        session_id=\"session-123\",\n        error_type=type(e).__name__,\n        error_message=str(e),\n        context={\n            \"current_state\": \"power_source_selection\",\n            \"user_message\": \"I need a welder\",\n            \"stack_trace\": traceback.format_exc()\n        }\n    )\n\n    # Re-raise or handle error\n    raise\n</code></pre>"},{"location":"OBSERVABILITY/#langsmith-ui","title":"LangSmith UI","text":""},{"location":"OBSERVABILITY/#accessing-the-dashboard","title":"Accessing the Dashboard","text":"<p>URL: https://smith.langchain.com</p> <p>Navigation: 1. Sign in to LangSmith 2. Select your project (e.g., \"Recommender\") 3. View traces, runs, and metrics</p>"},{"location":"OBSERVABILITY/#trace-view-features","title":"Trace View Features","text":"<p>Hierarchy Visualization: <pre><code>orchestrator_process_message (2.5s)\n\u251c\u2500\u2500 extract_parameters (800ms) [LLM]\n\u2502   \u251c\u2500\u2500 Input: user_message, current_state\n\u2502   \u251c\u2500\u2500 Output: extracted_parameters\n\u2502   \u2514\u2500\u2500 Model: gpt-4\n\u251c\u2500\u2500 search_products (450ms) [Retriever]\n\u2502   \u251c\u2500\u2500 Input: component_type, parameters\n\u2502   \u251c\u2500\u2500 Output: 10 products\n\u2502   \u2514\u2500\u2500 Query: Neo4j Cypher\n\u2514\u2500\u2500 generate_response (1.2s) [LLM]\n    \u251c\u2500\u2500 Input: current_state, products\n    \u251c\u2500\u2500 Output: response_text\n    \u2514\u2500\u2500 Model: gpt-4o-mini\n</code></pre></p> <p>Metrics Dashboard: - Total runs - Success rate - Average latency - Token usage - Error rate</p> <p>Filtering: - By session ID - By agent type - By time range - By success/failure status</p>"},{"location":"OBSERVABILITY/#debugging-with-langsmith","title":"Debugging with LangSmith","text":"<p>Use Cases: 1. Performance Bottlenecks: Identify slow operations 2. Error Investigation: View full error context and stack traces 3. Token Optimization: Track LLM token usage across requests 4. Agent Behavior: Analyze parameter extraction patterns 5. Production Monitoring: Real-time alerting on failures</p>"},{"location":"OBSERVABILITY/#related-documentation","title":"Related Documentation","text":"<ul> <li>State Flow Architecture - Orchestrator workflow tracing</li> <li>Agent 1: Parameter Extractor - LLM tracing</li> <li>Agent 2: Product Search - Neo4j query tracing</li> <li>Agent 3: Message Generator - Response generation tracing</li> <li>LangGraph Integration - Workflow checkpointing with LangSmith</li> </ul>"},{"location":"OBSERVABILITY/#file-location","title":"File Location","text":"<p>Source: <code>src/backend/app/services/observability/langsmith_service.py</code></p> <p>Related Files: - <code>app/services/orchestrator/state_orchestrator.py</code> - Uses @traceable - <code>app/services/intent/parameter_extractor.py</code> - Uses @traceable - <code>app/services/neo4j/product_search.py</code> - Uses @traceable - <code>app/services/response/message_generator.py</code> - Uses @traceable - <code>app/services/graph/configurator_graph.py</code> - Uses @traceable</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/","title":"Orchestrator Architecture - StateByStateOrchestrator","text":"<p>File: <code>src/backend/app/services/orchestrator/state_orchestrator.py</code></p> <p>The StateByStateOrchestrator is the central coordinator of the 3-agent system, managing the S1\u2192SN dynamic state machine workflow.</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#overview","title":"Overview","text":"<p>The orchestrator is a thin coordination layer that delegates all state-specific logic to modular processors via the <code>StateProcessorRegistry</code>. It focuses solely on:</p> <ul> <li>State transitions between processors</li> <li>Special command handling (skip, done, finalize)</li> <li>Session management</li> <li>Compound request coordination</li> </ul> <p>Architecture Pattern: Registry + Delegation Pattern (~800-1000 lines vs previous 3,851 lines)</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#core-responsibilities","title":"Core Responsibilities","text":""},{"location":"ORCHESTRATOR_ARCHITECTURE/#1-processor-registry-management","title":"1. Processor Registry Management","text":"<pre><code>def __init__(\n    self,\n    parameter_extractor: ParameterExtractor,\n    message_generator: MessageGenerator,\n    search_orchestrator: SearchOrchestrator,\n    state_config_path: str = \"app/config/state_config.json\",\n    powersource_applicability_config: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"Initialize orchestrator with modular processor registry.\"\"\"\n    self.parameter_extractor = parameter_extractor\n    self.message_generator = message_generator\n    self.search_orchestrator = search_orchestrator\n    self.powersource_applicability_config = powersource_applicability_config or {}\n\n    # Initialize processor registry - handles all 13 state processors\n    self.registry = StateProcessorRegistry(\n        state_config_path=state_config_path,\n        search_orchestrator=search_orchestrator,\n    )\n\n    # Initialize auto-skip service for unified skip decision logic\n    self.auto_skip_service = AutoSkipService()\n\n    logger.info(\"\u2705 StateByStateOrchestrator initialized with processor registry\")\n    logger.info(f\"   Processors loaded: {len(self.registry._processors)} states\")\n</code></pre> <p>Key Components: - <code>StateProcessorRegistry</code>: Manages 13 state processors (PowerSource, Feeder, Cooler, etc.) - <code>AutoSkipService</code>: Unified skip decision logic for component applicability - Agent 1: ParameterExtractor (LLM-based parameter extraction) - Agent 3: MessageGenerator (Template-based + LLM translation) - <code>SearchOrchestrator</code>: Coordinates Agent 2 (ProductSearch)</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#2-component-applicability-management","title":"2. Component Applicability Management","text":"<pre><code>def _load_applicability_for_powersource(self, power_source_gin: str) -&gt; ComponentApplicability:\n    \"\"\"\n    Load component applicability from configuration for a specific PowerSource.\n\n    Args:\n        power_source_gin: GIN of the selected PowerSource\n\n    Returns:\n        ComponentApplicability with Y/N/O rules for each component\n    \"\"\"\n    power_sources = self.powersource_applicability_config.get(\"power_sources\", {})\n    ps_config = power_sources.get(power_source_gin)\n\n    if ps_config:\n        # Found config for this specific PowerSource\n        applicability_data = ps_config.get(\"applicability\", {})\n        logger.info(f\"   Loaded applicability for {ps_config.get('name', power_source_gin)}: {applicability_data}\")\n        return ComponentApplicability(**applicability_data)\n    else:\n        # PowerSource not in config - use default policy\n        default_policy = self.powersource_applicability_config.get(\"default_policy\", {})\n        applicability_data = default_policy.get(\"applicability\", {})\n        logger.warning(\n            f\"   PowerSource {power_source_gin} not in config - using default applicability: {applicability_data}\"\n        )\n        return ComponentApplicability(**applicability_data)\n</code></pre> <p>Configuration: Loads from <code>component_applicability.json</code> which defines Y/N/O flags for each component based on selected PowerSource.</p> <p>Example: <pre><code>{\n  \"power_sources\": {\n    \"0446200880\": {\n      \"name\": \"Aristo 500ix\",\n      \"applicability\": {\n        \"Feeder\": \"Y\",\n        \"Cooler\": \"Y\",\n        \"Interconnector\": \"Y\",\n        \"Torch\": \"Y\",\n        \"Accessories\": \"Y\"\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#3-main-processing-flow-process_message","title":"3. Main Processing Flow - <code>process_message()</code>","text":"<pre><code>@traceable(name=\"orchestrator_process_message\", run_type=\"chain\")\nasync def process_message(\n    self,\n    conversation_state: ConversationState,\n    user_message: str,\n    last_shown_products: Optional[List[Dict]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Process user message in current state using modular processors.\n\n    Flow:\n    1. Check for special commands (skip, done, finalize)\n    2. Extract parameters via ParameterExtractor (Agent 1)\n    3. Detect compound requests\n    4. Delegate to processor for current state\n    5. Handle state transition\n    6. Generate response via MessageGenerator (Agent 3)\n\n    Args:\n        conversation_state: Current session state\n        user_message: User's input message\n        last_shown_products: Previously shown products (for selection detection)\n\n    Returns:\n        Dict with response, state, products, selection status\n    \"\"\"\n    language = conversation_state.language or \"en\"\n    logger.info(f\"\ud83c\udfaf Processing message in state: {conversation_state.current_state}\")\n\n    try:\n        # STEP 1: Handle special commands first\n        if self._is_special_command(user_message):\n            return await self._handle_special_command(\n                user_message, conversation_state, language\n            )\n\n        # STEP 2: Extract parameters using Agent 1 (LLM)\n        master_parameters = await self.parameter_extractor.extract_parameters(\n            user_message=user_message,\n            current_state=conversation_state.current_state,\n            master_parameters=conversation_state.master_parameters,\n        )\n\n        # Update conversation state with extracted parameters\n        conversation_state.master_parameters = master_parameters\n\n        # Log extracted parameters for debugging\n        import json\n        master_params_dict = master_parameters.model_dump() if hasattr(master_parameters, 'model_dump') else master_parameters\n        non_empty_params = {\n            k: v for k, v in master_params_dict.items()\n            if k != \"last_updated\" and v and v != {} and v != []\n        }\n        if non_empty_params:\n            logger.info(f\"\ud83d\udd0d LLM EXTRACTED PARAMETERS:\\n{json.dumps(non_empty_params, indent=2)}\")\n        else:\n            logger.info(\"\ud83d\udd0d LLM EXTRACTED: No parameters extracted from user message\")\n\n        # STEP 3: Check for compound request (multiple components specified)\n        if self._is_compound_request(master_parameters, conversation_state):\n            return await self._handle_compound_request(\n                master_parameters, conversation_state, language\n            )\n\n        # STEP 4: Delegate to processor for current state\n        return await self._process_single_state(\n            user_message, master_parameters, conversation_state, language\n        )\n\n    except Exception as e:\n        logger.error(f\"\u274c Error in process_message: {e}\", exc_info=True)\n        return self._generate_error_response(str(e), conversation_state, language)\n</code></pre> <p>Key Features: - LangSmith Tracing: <code>@traceable</code> decorator for observability - Special Commands: Handles <code>skip</code>, <code>done</code>, <code>finalize</code> commands - Agent 1 Integration: Calls <code>ParameterExtractor.extract_parameters()</code> for LLM-based intent extraction - Compound Request Detection: Multi-component requests like \"Aristo 500ix with RobustFeed U6\" - Processor Delegation: Routes to appropriate state processor for search and validation</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#4-product-selection-flow-select_product","title":"4. Product Selection Flow - <code>select_product()</code>","text":"<pre><code>@traceable(name=\"orchestrator_select_product\", run_type=\"chain\")\nasync def select_product(\n    self,\n    product_gin: str,\n    product_data: Dict[str, Any],\n    conversation_state: ConversationState,\n    language: str = \"en\",\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Handle explicit product selection using modular processors.\n\n    Flow:\n    1. Get processor for current state\n    2. Create SelectedProduct from product data\n    3. Add to response_json\n    4. Check if proactive display enabled for next state\n    5. Generate response with selection confirmation\n\n    Args:\n        product_gin: Selected product GIN\n        product_data: Product details\n        conversation_state: Current session state\n        language: ISO 639-1 language code\n\n    Returns:\n        Dict with response, updated state, next products\n    \"\"\"\n    logger.info(f\"\u2705 Product selected: {product_gin} in state {conversation_state.current_state}\")\n\n    try:\n        # Guard: Reject selections in FINALIZE state\n        if str(conversation_state.current_state) == \"finalize\" or conversation_state.current_state == ConfiguratorState.FINALIZE:\n            logger.warning(f\"\u274c Cannot select products in FINALIZE state\")\n            return {\n                \"response\": \"Configuration is complete. Cannot add more products.\",\n                \"current_state\": conversation_state.current_state,\n                \"products\": [],\n                \"can_finalize\": True\n            }\n\n        # Get processor for current state\n        processor = self.registry.get_processor(conversation_state.current_state)\n        if not processor:\n            raise ValueError(f\"No processor found for state: {conversation_state.current_state}\")\n\n        # Create selected product\n        selected_product = SelectedProduct(\n            gin=product_gin,\n            name=product_data.get(\"name\", \"Unknown\"),\n            category=product_data.get(\"category\", \"\"),\n            description=product_data.get(\"description\", \"\"),\n        )\n\n        # Add to response_json based on component type\n        component_key = processor.component_type\n        field_name = config_service.get_response_json_field_name(component_key)\n\n        if processor.is_multi_select():\n            # Multi-select: Add to list (e.g., Accessories)\n            current_list = getattr(conversation_state.response_json, field_name, [])\n            if not isinstance(current_list, list):\n                current_list = []\n            current_list.append(selected_product)\n            setattr(conversation_state.response_json, field_name, current_list)\n        else:\n            # Single-select: Replace existing\n            setattr(conversation_state.response_json, field_name, selected_product)\n\n        # ... handle state transition and response generation\n</code></pre> <p>Key Features: - FINALIZE Guard: Prevents selection after configuration is complete - Multi-Select Support: Handles accessories (multiple) vs single components - Dynamic Field Mapping: Maps component_key to ResponseJSON field names - State Transition: Automatically advances to next applicable state</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#special-command-handling","title":"Special Command Handling","text":""},{"location":"ORCHESTRATOR_ARCHITECTURE/#skip-command","title":"Skip Command","text":"<pre><code>def _is_special_command(self, user_message: str) -&gt; bool:\n    \"\"\"Check if message is a special command.\"\"\"\n    message_lower = user_message.lower().strip()\n    return message_lower in [\"skip\", \"done\", \"finalize\"]\n</code></pre> <p>Skip Logic: 1. Checks if component is skippable (applicability != \"Y\") 2. Marks component as skipped in response_json 3. Advances to next applicable state 4. Validates only mandatory PowerSource is required</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#compound-request-handling-new-in-v21","title":"Compound Request Handling (NEW in v2.1)","text":""},{"location":"ORCHESTRATOR_ARCHITECTURE/#detection","title":"Detection","text":"<pre><code>def _is_compound_request(self, master_parameters: Any, conversation_state: ConversationState) -&gt; bool:\n    \"\"\"\n    Detect if user specified multiple components in one message.\n\n    Example: \"Aristo 500ix with RobustFeed U6\"\n    \"\"\"\n    # Check how many components have specifications\n    specified_count = sum(1 for component_params in master_params if component_params)\n    return specified_count &gt; 1 or (specified_count == 1 and not at_powersource_state)\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#processing","title":"Processing","text":"<pre><code>async def _handle_compound_request(\n    self,\n    master_parameters: Any,\n    conversation_state: ConversationState,\n    language: str,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Process compound requests where user specifies multiple components.\n\n    Flow:\n    1. Validate PowerSource dependency\n    2. Search all specified components in parallel\n    3. Auto-select if exactly 1 match found\n    4. Queue for disambiguation if 2+ matches\n    5. Advance state appropriately\n    \"\"\"\n</code></pre> <p>Auto-Selection Logic: - 1 result: Auto-select and add to ResponseJSON - 2+ results: Queue for user disambiguation - 0 results: Show all compatible products</p> <p>User Experience: <pre><code>BEFORE: \"Aristo 500ix with RobustFeed U6\" \u2192 6 interactions (sequential)\nAFTER:  \"Aristo 500ix with RobustFeed U6\" \u2192 1 interaction (compound)\n</code></pre></p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#state-transition-logic","title":"State Transition Logic","text":""},{"location":"ORCHESTRATOR_ARCHITECTURE/#next-state-determination","title":"Next State Determination","text":"<pre><code>def _determine_next_state(\n    self,\n    conversation_state: ConversationState,\n    processor: Any,\n) -&gt; ConfiguratorState:\n    \"\"\"\n    Determine next state based on applicability and auto-skip rules.\n\n    Uses ConversationState.get_next_state() which:\n    1. Checks component applicability (Y/N/O)\n    2. Auto-skips \"N\" components\n    3. Returns next applicable component\n    4. Returns FINALIZE when all components handled\n    \"\"\"\n    return conversation_state.get_next_state()\n</code></pre> <p>State Flow Example: <pre><code>S1 (PowerSource) \u2192 Applicability Loaded\n   \u2193 (Feeder: Y)\nS2 (Feeder) \u2192 User selects feeder\n   \u2193 (Cooler: N - Auto-skip)\n   \u2193 (Interconnector: Y)\nS3 (Interconnector) \u2192 User selects interconnector\n   \u2193\nS7 (FINALIZE)\n</code></pre></p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#agent-integration","title":"Agent Integration","text":""},{"location":"ORCHESTRATOR_ARCHITECTURE/#agent-1-parameterextractor-llm","title":"Agent 1: ParameterExtractor (LLM)","text":"<pre><code># Called in process_message()\nmaster_parameters = await self.parameter_extractor.extract_parameters(\n    user_message=user_message,\n    current_state=conversation_state.current_state,\n    master_parameters=conversation_state.master_parameters,\n)\n</code></pre> <p>Purpose: Extract welding parameters from natural language using GPT-4</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#agent-2-productsearch-neo4j-via-searchorchestrator","title":"Agent 2: ProductSearch (Neo4j) via SearchOrchestrator","text":"<pre><code># Delegated to state processors via registry\nprocessor = self.registry.get_processor(conversation_state.current_state)\nresult = await processor.process(\n    user_message=user_message,\n    master_parameters=master_parameters,\n    selected_components=conversation_state.response_json,\n    language=language,\n)\n</code></pre> <p>Purpose: Search Neo4j graph database for compatible products</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#agent-3-messagegenerator-templates-llm","title":"Agent 3: MessageGenerator (Templates + LLM)","text":"<pre><code># Called at end of processing flow\nresponse_message = await self.message_generator.generate_response(\n    current_state=conversation_state.current_state,\n    search_results=products,\n    master_parameters=master_parameters,\n    response_json=conversation_state.response_json,\n    language=language,\n)\n</code></pre> <p>Purpose: Generate user-friendly multilingual responses</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#error-handling","title":"Error Handling","text":"<pre><code>def _generate_error_response(\n    self,\n    error_message: str,\n    conversation_state: ConversationState,\n    language: str,\n) -&gt; Dict[str, Any]:\n    \"\"\"Generate user-friendly error response.\"\"\"\n    logger.error(f\"\u274c Generating error response: {error_message}\")\n    return {\n        \"response\": f\"An error occurred: {error_message}. Please try again.\",\n        \"current_state\": conversation_state.current_state,\n        \"products\": [],\n        \"master_parameters\": conversation_state.master_parameters.model_dump(),\n        \"response_json\": conversation_state.response_json.model_dump(),\n        \"can_finalize\": False,\n    }\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#langsmith-observability","title":"LangSmith Observability","text":"<p>Tracing: All major methods decorated with <code>@traceable</code> for monitoring in LangSmith: - <code>process_message()</code> - Main entry point - <code>select_product()</code> - Product selection flow</p> <p>Environment Variables: <pre><code>LANGSMITH_API_KEY=ls_...\nLANGSMITH_PROJECT=Recommender\nLANGSMITH_TRACING=true\n</code></pre></p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#state-processor-architecture","title":"State Processor Architecture","text":"<p>The orchestrator delegates all state-specific logic to modular processors managed by <code>StateProcessorRegistry</code>. This architecture enables clean separation of concerns and easy extension.</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#stateprocessorregistry","title":"StateProcessorRegistry","text":"<p>File: <code>src/backend/app/services/processors/registry.py</code></p> <p>Purpose: Manages lifecycle and retrieval of all 14 state processors</p> <p>Key Features: - Centralized Management: Single registry for all processors - Configuration-Driven: Loads processors from <code>state_config.json</code> and <code>component_types.json</code> - Factory Pattern: Creates accessory processors dynamically from configuration - Dependency Injection: Injects <code>SearchOrchestrator</code> into all processors</p> <p>Initialization (<code>registry.py:20-70</code>):</p> <pre><code>class StateProcessorRegistry:\n    \"\"\"Registry for all state processors\"\"\"\n\n    def __init__(self, state_config_path: str, search_orchestrator):\n        self.search_orchestrator = search_orchestrator\n        self.state_config_dict = load_state_config()\n        self._processors: Dict[str, StateProcessor] = {}\n        self._initialize_processors()\n\n    def _initialize_processors(self):\n        \"\"\"Initialize all 14 state processors\"\"\"\n        states = self.state_config_dict.get(\"states\", {})\n\n        # S1: Power Source (MANDATORY)\n        if \"power_source_selection\" in states:\n            self._processors[\"power_source_selection\"] = PowerSourceStateProcessor(\n                state_name=\"power_source_selection\",\n                component_type=\"PowerSource\",\n                state_config=states[\"power_source_selection\"],\n                search_orchestrator=self.search_orchestrator\n            )\n\n        # S2-S5: Primary components\n        # ... similar initialization for Feeder, Cooler, Interconnector, Torch\n\n        # S6: Accessories (9 accessory states using factory)\n        accessory_processors = create_accessory_processors(\n            self.state_config_dict,\n            self.search_orchestrator\n        )\n        self._processors.update(accessory_processors)\n</code></pre> <p>14 Processors Managed: 1. <code>power_source_selection</code> - PowerSourceStateProcessor (S1, mandatory) 2. <code>feeder_selection</code> - SingleSelectionProcessor (S2) 3. <code>cooler_selection</code> - SingleSelectionProcessor (S3) 4. <code>interconnector_selection</code> - SingleSelectionProcessor (S4) 5. <code>torch_selection</code> - SingleSelectionProcessor (S5) 6. <code>powersource_accessories_selection</code> - AccessoryStateProcessor (S6a) 7. <code>feeder_accessories_selection</code> - AccessoryStateProcessor (S6b) 8. <code>feeder_conditional_accessories</code> - AccessoryStateProcessor (S6c) 9. <code>interconnector_accessories_selection</code> - AccessoryStateProcessor (S6d) 10. <code>remote_selection</code> - AccessoryStateProcessor (S6e) 11. <code>remote_accessories_selection</code> - AccessoryStateProcessor (S6f) 12. <code>remote_conditional_accessories</code> - AccessoryStateProcessor (S6g) 13. <code>connectivity_selection</code> - AccessoryStateProcessor (S6h) 14. <code>finalize</code> - Special state (no processor)</p> <p>Processor Retrieval:</p> <pre><code>def get_processor(self, state_name: str) -&gt; Optional[StateProcessor]:\n    \"\"\"Get processor for given state name\"\"\"\n    return self._processors.get(state_name)\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#stateprocessor-base-class","title":"StateProcessor Base Class","text":"<p>File: <code>src/backend/app/services/processors/base.py</code></p> <p>Purpose: Abstract base class defining interface for all processors</p> <p>Core Interface:</p> <pre><code>class StateProcessor(ABC):\n    \"\"\"Abstract base class for state processors\"\"\"\n\n    def __init__(\n        self,\n        state_name: str,\n        component_type: str,\n        state_config: Dict[str, Any],\n        search_orchestrator\n    ):\n        self.state_name = state_name\n        self.component_type = component_type\n        self.state_config = state_config\n        self.search_orchestrator = search_orchestrator\n\n        # Extract configuration\n        self.mandatory = state_config.get(\"mandatory\", False)\n        self.proactive_display = state_config.get(\"proactive_display\", False)\n        self.search_limit = state_config.get(\"search_limit\", 10)\n        self.multi_select = state_config.get(\"multi_select\", False)\n        self.allow_skip = state_config.get(\"allow_skip\", True)\n\n    @abstractmethod\n    async def search_products(\n        self, user_message, master_parameters, selected_components, limit, offset\n    ):\n        \"\"\"Search for products for this state's component type\"\"\"\n        pass\n\n    @abstractmethod\n    def get_next_state(self, conversation_state, selection_made):\n        \"\"\"Determine the next state after this state\"\"\"\n        pass\n\n    def validate_selection(self, product_gin, product_data, selected_components):\n        \"\"\"Validate a product selection\"\"\"\n        return True, None\n\n    async def get_proactive_preview(\n        self, user_message, master_parameters, selected_components, limit\n    ):\n        \"\"\"Generate proactive preview for this state\"\"\"\n        if not self.proactive_display:\n            return None\n        # ... preview generation logic\n</code></pre> <p>Configuration Flags: - <code>mandatory</code> - Must select before finalize (only PowerSource is mandatory) - <code>proactive_display</code> - Show preview of next state after selection - <code>search_limit</code> - Max products to return (default: 10) - <code>preview_limit</code> - Max products for proactive preview (default: 5) - <code>multi_select</code> - Allow multiple selections (accessories only) - <code>allow_skip</code> - Can skip this state (all except PowerSource)</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#powersourcestateprocessor","title":"PowerSourceStateProcessor","text":"<p>File: <code>src/backend/app/services/processors/power_source.py</code></p> <p>State: S1 (power_source_selection)</p> <p>Characteristics: - \u2705 Mandatory: Cannot be skipped (must select before finalize) - \u2705 Single-select: Only one power source per configuration - \u2705 Proactive display: Shows Feeder preview after selection - \u2705 No dependencies: First component in flow</p> <p>Search Method (<code>power_source.py:28-94</code>):</p> <pre><code>@traceable(name=\"search_products_power_source\", run_type=\"retriever\")\nasync def search_products(self, user_message, master_parameters, selected_components, limit, offset):\n    \"\"\"Search for power sources based on user requirements\"\"\"\n\n    # Execute search via SearchOrchestrator\n    # Both Cypher and Lucene strategies will run\n    results = await self.search_orchestrator.search(\n        component_type=\"PowerSource\",\n        user_message=user_message,\n        master_parameters=master_parameters,\n        selected_components=selected_components,  # Empty for S1\n        limit=search_limit,\n        offset=offset\n    )\n    return results\n</code></pre> <p>Next State Logic (<code>power_source.py:96-153</code>):</p> <pre><code>def get_next_state(self, conversation_state, selection_made):\n    \"\"\"Determine next state after power source selection\"\"\"\n\n    if not selection_made:\n        # Error case: No selection made (shouldn't happen - power source is mandatory)\n        return \"power_source_selection\"\n\n    # Get applicability from response_json\n    applicability = conversation_state.response_json.applicability.model_dump()\n\n    # Check if Feeder is applicable\n    if applicability.get(\"Feeder\") in [\"mandatory\", \"optional\", \"Y\"]:\n        return \"feeder_selection\"\n\n    # Feeder not applicable, check Cooler\n    if applicability.get(\"Cooler\") in [\"mandatory\", \"optional\", \"Y\"]:\n        return \"cooler_selection\"\n\n    # Continue through all primary components...\n    # Eventually defaults to accessories or finalize\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#accessorystateprocessor","title":"AccessoryStateProcessor","text":"<p>File: <code>src/backend/app/services/processors/accessory.py</code></p> <p>States: S6a-S6h (all accessory states)</p> <p>Characteristics: - \u2705 Multi-select: Can select multiple products (configurable per state) - \u2705 Optional: Can be skipped (allow_skip=true) - \u2705 Proactive display: Shows compatible products automatically - \u2705 Completion keywords: \"done\", \"next\", \"skip\" to proceed</p> <p>Key Features:</p> <ol> <li>Multi-Select Completion Detection (<code>accessory.py:200-221</code>):</li> </ol> <pre><code>def _is_done_with_multi_select(self, conversation_state):\n    \"\"\"Check if user is done with multi-select\"\"\"\n\n    conversation_history = conversation_state.conversation_history\n    if not conversation_history:\n        return False\n\n    last_message = conversation_history[-1].get(\"user_message\", \"\").lower()\n\n    completion_keywords = [\n        \"done\", \"next\", \"skip\", \"finish\", \"finalize\",\n        \"proceed\", \"continue\", \"that's all\"\n    ]\n\n    return any(keyword in last_message for keyword in completion_keywords)\n</code></pre> <ol> <li>Conditional Accessory Logic (<code>accessory.py:245-308</code>):</li> </ol> <pre><code>def _is_conditional_accessory_state(self, state_name):\n    \"\"\"Check if a state is a conditional accessory state\"\"\"\n    conditional_states = [\n        \"feeder_conditional_accessories\",\n        \"remote_conditional_accessories\"\n    ]\n    return state_name in conditional_states\n\ndef _has_parent_accessory_selections(self, conditional_state, conversation_state):\n    \"\"\"Check if parent accessory category has any selections\"\"\"\n\n    # Map conditional states to their parent accessory fields\n    parent_mapping = {\n        \"feeder_conditional_accessories\": \"FeederAccessories\",\n        \"remote_conditional_accessories\": \"RemoteAccessories\"\n    }\n\n    parent_field = parent_mapping.get(conditional_state)\n    parent_accessories = getattr(response_json, parent_field, None)\n\n    # Check if parent has selections\n    if parent_accessories is None or parent_accessories == \"skipped\":\n        return False\n    if isinstance(parent_accessories, list) and len(parent_accessories) == 0:\n        return False\n\n    return True  # Parent has selections\n</code></pre> <ol> <li>Applicability-Based Auto-Skip (<code>accessory.py:163-181</code>):</li> </ol> <pre><code># Check if next accessory state is applicable for selected PowerSource\napplicability = response_json.applicability.model_dump()\n\ncomponent_key = self._get_component_api_key_from_state(self.next_accessory_state)\nif component_key:\n    component_status = applicability.get(component_key)\n    if component_status not in [\"mandatory\", \"optional\", \"Y\", None]:\n        # Auto-skip not_applicable accessories\n        logger.info(f\"\u23ed\ufe0f  Skipping {self.next_accessory_state} ({component_key} applicability: {component_status})\")\n        return self._get_next_applicable_accessory_state(self.next_accessory_state, conversation_state)\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#accessory-factory-pattern","title":"Accessory Factory Pattern","text":"<p>Factory Function: <code>create_accessory_processors()</code> (<code>accessory.py:459-536</code>)</p> <p>Purpose: Create all 9 accessory processors with proper sequencing (configuration-driven)</p> <p>Process:</p> <ol> <li>Load state sequence from <code>component_types.json</code>:</li> </ol> <pre><code>component_types = config_service.get_component_types()\nfull_state_sequence = component_types.get(\"state_sequence\", [])\n\n# Filter to get only accessory states (states after torch_selection)\ntorch_index = full_state_sequence.index(\"torch_selection\")\naccessory_states = full_state_sequence[torch_index + 1:]\n\n# Result: [\n#   \"powersource_accessories_selection\",\n#   \"feeder_accessories_selection\",\n#   \"feeder_conditional_accessories\",\n#   \"interconnector_accessories_selection\",\n#   \"remote_selection\",\n#   \"remote_accessories_selection\",\n#   \"remote_conditional_accessories\",\n#   \"connectivity_selection\",\n# ]\n</code></pre> <ol> <li>Build processors with proper next_state linkage:</li> </ol> <pre><code>for i, state_name in enumerate(accessory_states):\n    # Get component type from component_types.json\n    component_type = ...  # Lookup from config\n\n    # Get next state in sequence (or None if last)\n    next_state = accessory_states[i + 1] if i &lt; len(accessory_states) - 1 else None\n\n    # Get state config\n    state_config = state_config_dict.get(\"states\", {}).get(state_name, {})\n\n    # Create processor\n    processor = AccessoryStateProcessor(\n        state_name=state_name,\n        component_type=component_type,\n        state_config=state_config,\n        search_orchestrator=search_orchestrator,\n        next_accessory_state=next_state\n    )\n\n    processors[state_name] = processor\n</code></pre> <ol> <li>Result: Linked list of accessory processors:</li> </ol> <pre><code>powersource_accessories_selection \u2192 feeder_accessories_selection \u2192\nfeeder_conditional_accessories \u2192 interconnector_accessories_selection \u2192\nremote_selection \u2192 remote_accessories_selection \u2192\nremote_conditional_accessories \u2192 connectivity_selection \u2192 (None)\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#product-ranker","title":"Product Ranker","text":"<p>File: <code>src/backend/app/services/ranker/product_ranker.py</code></p> <p>The Product Ranker provides deterministic, explainable ranking for small result sets (&lt;100 products).</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#ranking-strategy","title":"Ranking Strategy","text":"<p>Algorithm: 3-Tier Tuple Sorting</p> <pre><code>def _score(self, p: Dict[str, Any], context: Optional[Dict[str, Any]] = None) -&gt; tuple:\n    name = (p.get(\"name\") or \"\").lower()\n    is_default = p.get(\"is_default\", False)\n    q = (context or {}).get(\"query\") or \"\"\n    q = q.lower().strip()\n\n    exact_hit = (1 if q and q in name else 0)\n\n    # Lower tuple sorts earlier; invert booleans\n    return (\n        0 if is_default else 1,  # Tier 1: Prefer defaults\n        0 if exact_hit else 1,   # Tier 2: Prefer exact name contains\n        name                     # Tier 3: Alphabetical\n    )\n</code></pre> <p>Sorting Priority:</p> <ol> <li>Tier 1: Default Products (<code>is_default=True</code>)</li> <li>Products flagged as recommended/default by ESAB</li> <li>Score: 0 (highest priority)</li> <li> <p>Use case: Promote most popular or recommended products</p> </li> <li> <p>Tier 2: Exact Match (query in product name)</p> </li> <li>Exact phrase match in product name</li> <li>Score: 0 if match, 1 if no match</li> <li> <p>Use case: \"Aristo 500ix\" query matches \"Aristo 500ix MIG Welder\"</p> </li> <li> <p>Tier 3: Alphabetical (stable sort)</p> </li> <li>Deterministic ordering by product name</li> <li>Use case: Consistent results across requests</li> </ol>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#usage","title":"Usage","text":"<pre><code>from app.services.ranker.product_ranker import ProductRanker\n\nranker = ProductRanker()\n\n# Example products\nproducts = [\n    {\"gin\": \"001\", \"name\": \"RobustFeed U6\", \"is_default\": False},\n    {\"gin\": \"002\", \"name\": \"Aristo 500ix\", \"is_default\": True},\n    {\"gin\": \"003\", \"name\": \"RobustFeed U4\", \"is_default\": False},\n]\n\n# Rank with context\ncontext = {\"query\": \"RobustFeed U6\"}\nranked = ranker.rank(products, context)\n\n# Result order:\n# 1. Aristo 500ix (is_default=True, tier 1)\n# 2. RobustFeed U6 (exact match, tier 2)\n# 3. RobustFeed U4 (alphabetical, tier 3)\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#integration-with-search","title":"Integration with Search","text":"<p>The ranker is used by SearchOrchestrator to provide final ordering after score consolidation:</p> <pre><code># After multi-strategy search and score consolidation\nranked_products = product_ranker.rank(\n    products=consolidated_products,\n    context={\"query\": user_message}\n)\n</code></pre> <p>When Ranker is Applied: - After all search strategies return results - After score consolidation (weighted average across strategies) - Before returning final results to orchestrator</p> <p>Benefits: - Deterministic: Same inputs \u2192 same outputs (no randomness) - Explainable: Clear 3-tier logic (default \u2192 exact match \u2192 alphabetical) - Fast: O(n log n) sorting (suitable for small result sets) - Extensible: Can add more tiers (e.g., bundle frequency, pricing tiers)</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#future-enhancements","title":"Future Enhancements","text":"<p>Possible extensions to ranking algorithm:</p> <ol> <li>Telemetry-Based: Rank by usage frequency or popularity</li> <li>Bundle Frequency: Prefer products often bought together</li> <li>Pricing Tiers: Rank by price (low to high or high to low)</li> <li>Recency: Prefer newer products (by release date)</li> <li>Stock Availability: Rank in-stock products higher</li> </ol> <p>Implementation Pattern:</p> <pre><code>def _score_with_telemetry(self, p, context):\n    usage_count = p.get(\"usage_count\", 0)\n\n    return (\n        0 if p.get(\"is_default\") else 1,      # Tier 1: Defaults\n        -usage_count,                           # Tier 2: Most used (negative for descending)\n        0 if context.get(\"query\") in p[\"name\"] else 1,  # Tier 3: Exact match\n        p[\"name\"]                               # Tier 4: Alphabetical\n    )\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#langgraph-integration-optional","title":"LangGraph Integration (Optional)","text":"<p>File: <code>src/backend/app/services/graph/configurator_graph.py</code></p> <p>Note: LangGraph integration is optional and not currently used in production. The main orchestrator (<code>StateByStateOrchestrator</code>) provides the active workflow.</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#overview_1","title":"Overview","text":"<p>LangGraph provides an alternative agent orchestration approach with:</p> <ul> <li>Redis Checkpointing: Hot session data persistence</li> <li>State Graph Workflow: Explicit node \u2192 edge \u2192 node flow</li> <li>LangSmith Integration: Built-in observability</li> <li>Multi-Agent Orchestration: Coordinated agent execution</li> </ul>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#4-node-workflow","title":"4-Node Workflow","text":"<pre><code>User Message\n    \u2193\n[extract_parameters] (Agent 1: LLM)\n    \u2193\n[search_products] (Agent 2: Neo4j)\n    \u2193\n[generate_response] (Agent 3: LLM)\n    \u2193\n[determine_next_state] (State machine logic)\n    \u2193\nEND\n</code></pre> <p>Graph Definition (<code>configurator_graph.py:71-89</code>):</p> <pre><code>def _build_graph(self) -&gt; StateGraph:\n    \"\"\"Build LangGraph workflow\"\"\"\n\n    workflow = StateGraph(ConfiguratorGraphState)\n\n    # Add nodes\n    workflow.add_node(\"extract_parameters\", self.extract_parameters_node)\n    workflow.add_node(\"search_products\", self.search_products_node)\n    workflow.add_node(\"generate_response\", self.generate_response_node)\n    workflow.add_node(\"determine_next_state\", self.determine_next_state_node)\n\n    # Define edges (sequential flow)\n    workflow.set_entry_point(\"extract_parameters\")\n    workflow.add_edge(\"extract_parameters\", \"search_products\")\n    workflow.add_edge(\"search_products\", \"generate_response\")\n    workflow.add_edge(\"generate_response\", \"determine_next_state\")\n    workflow.add_edge(\"determine_next_state\", END)\n\n    return workflow\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#node-implementations","title":"Node Implementations","text":""},{"location":"ORCHESTRATOR_ARCHITECTURE/#node-1-extract-parameters-agent-1","title":"Node 1: Extract Parameters (Agent 1)","text":"<pre><code>@traceable(name=\"extract_parameters\", run_type=\"llm\")\nasync def extract_parameters_node(self, state: ConfiguratorGraphState):\n    \"\"\"Extract parameters from user message using LLM\"\"\"\n\n    updated_master = await self.parameter_extractor.extract_parameters(\n        user_message=state[\"user_message\"],\n        current_state=state[\"current_state\"],\n        master_parameters=state[\"master_parameters\"]\n    )\n\n    # Log extraction for observability\n    extraction = LLMExtraction(\n        timestamp=datetime.utcnow().isoformat(),\n        user_message=state[\"user_message\"],\n        current_state=state[\"current_state\"],\n        extracted_parameters=updated_master,\n        model=\"gpt-4\",\n        tokens_used=0,\n        duration_ms=duration_ms,\n        success=True,\n        error=None\n    )\n\n    return {\n        \"master_parameters\": updated_master,\n        \"llm_extractions\": [extraction],\n        \"last_updated\": datetime.utcnow().isoformat()\n    }\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#node-2-search-products-agent-2","title":"Node 2: Search Products (Agent 2)","text":"<pre><code>@traceable(name=\"search_products\", run_type=\"retriever\")\nasync def search_products_node(self, state: ConfiguratorGraphState):\n    \"\"\"Search Neo4j for matching products\"\"\"\n\n    component = state[\"current_state\"].replace(\"_selection\", \"\")\n    component_params = state[\"master_parameters\"].get(component, {})\n\n    # Search Neo4j\n    products = await self.product_search.search_by_component(\n        component=component,\n        requirements=component_params\n    )\n\n    # Log query for observability\n    query = Neo4jQuery(\n        timestamp=datetime.utcnow().isoformat(),\n        query_type=\"product_search\",\n        component=component,\n        parameters=component_params,\n        results_count=len(products),\n        top_results=products[:3],\n        duration_ms=duration_ms\n    )\n\n    return {\n        \"neo4j_queries\": [query],\n        \"agent_actions\": [AgentAction(...)]\n    }\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#node-3-generate-response-agent-3","title":"Node 3: Generate Response (Agent 3)","text":"<pre><code>@traceable(name=\"generate_response\", run_type=\"llm\")\nasync def generate_response_node(self, state: ConfiguratorGraphState):\n    \"\"\"Generate conversational response\"\"\"\n\n    response_text = await self.message_generator.generate_message(\n        current_state=ConfiguratorState(state[\"current_state\"]),\n        master_parameters=state[\"master_parameters\"],\n        response_json=state[\"response_json\"]\n    )\n\n    return {\n        \"ai_response\": response_text,\n        \"agent_actions\": [AgentAction(...)]\n    }\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#node-4-determine-next-state","title":"Node 4: Determine Next State","text":"<pre><code>@traceable(name=\"determine_next_state\", run_type=\"chain\")\nasync def determine_next_state_node(self, state: ConfiguratorGraphState):\n    \"\"\"Determine next state based on applicability\"\"\"\n\n    # Simple progression (TODO: Implement full applicability logic)\n    state_order = [\n        \"power_source_selection\",\n        \"feeder_selection\",\n        \"cooler_selection\",\n        \"interconnector_selection\",\n        \"torch_selection\",\n        \"accessories_selection\",\n        \"finalize\"\n    ]\n\n    current_idx = state_order.index(state[\"current_state\"])\n    next_state = state_order[current_idx + 1] if current_idx &lt; len(state_order) - 1 else \"finalize\"\n\n    transition = StateTransition(\n        timestamp=datetime.utcnow().isoformat(),\n        from_state=state[\"current_state\"],\n        to_state=next_state,\n        reason=\"progression\",\n        applicability_check=None\n    )\n\n    return {\n        \"next_state\": next_state,\n        \"state_transitions\": [transition],\n        \"checkpoint_count\": state.get(\"checkpoint_count\", 0) + 1\n    }\n</code></pre>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#redis-checkpointing","title":"Redis Checkpointing","text":"<p>Purpose: Persist graph state between invocations</p> <p>Initialization:</p> <pre><code>from langgraph.checkpoint.redis import RedisSaver\n\nredis_checkpointer = RedisSaver(redis_client)\n\ngraph = ConfiguratorGraph(\n    parameter_extractor=parameter_extractor,\n    product_search=product_search,\n    message_generator=message_generator,\n    redis_checkpointer=redis_checkpointer\n)\n</code></pre> <p>Process Message with Checkpointing:</p> <pre><code>async def process_message(self, session_id, user_message, current_state):\n    \"\"\"Process message through LangGraph workflow\"\"\"\n\n    # Update state with new message\n    current_state[\"user_message\"] = user_message\n    current_state[\"messages\"].append({\n        \"role\": \"user\",\n        \"content\": user_message,\n        \"timestamp\": datetime.utcnow().isoformat()\n    })\n\n    # Create config for checkpointing\n    config = {\"configurable\": {\"thread_id\": session_id}}\n\n    # Invoke graph with checkpointing\n    result = await self.app.ainvoke(current_state, config)\n\n    # Checkpoint automatically saved by LangGraph\n    logger.info(f\"Checkpoint #{result.get('checkpoint_count', 0)} saved\")\n\n    return result\n</code></pre> <p>Benefits: - Session Persistence: State saved automatically after each node - Resume Capability: Resume from last checkpoint on reconnection - Crash Recovery: Recover state after server restart - Debugging: Inspect graph state at each checkpoint</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#why-not-used-in-production","title":"Why Not Used in Production?","text":"<p>The main orchestrator (<code>StateByStateOrchestrator</code>) is preferred because:</p> <ol> <li>Simpler: Direct function calls vs graph nodes</li> <li>More Flexible: Dynamic state transitions based on applicability</li> <li>Better Performance: No checkpointing overhead</li> <li>Easier Debugging: Standard Python async/await patterns</li> <li>Less Dependencies: No LangGraph or Redis checkpointing required</li> </ol> <p>LangGraph is retained for: - Future experimentation with multi-agent workflows - Alternative architecture research - Checkpointing capabilities if needed - LangSmith-native integration patterns</p>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#related-documentation","title":"Related Documentation","text":"<ul> <li>Agent 1: ParameterExtractor - LLM-based parameter extraction</li> <li>Agent 2: ProductSearch - Neo4j graph database search</li> <li>Agent 3: MessageGenerator - Template-based + LLM response generation</li> <li>State Flow Architecture - S1\u2192SN dynamic state machine</li> <li>Master Parameter JSON Architecture - Data models</li> </ul>"},{"location":"ORCHESTRATOR_ARCHITECTURE/#file-location","title":"File Location","text":"<p>Source: <code>src/backend/app/services/orchestrator/state_orchestrator.py</code></p> <p>Related Files: - <code>app/services/processors/registry.py</code> - StateProcessorRegistry - <code>app/services/processors/base.py</code> - BaseStateProcessor - <code>app/services/processors/powersource.py</code> - PowerSourceProcessor - <code>app/services/processors/single_selection.py</code> - SingleSelectionProcessor (Feeder, Cooler, etc.) - <code>app/services/processors/multi_selection.py</code> - MultiSelectionProcessor (Accessories) - <code>app/config/component_applicability.json</code> - Component Y/N/O rules - <code>app/config/state_config.json</code> - State processor configuration</p>"},{"location":"PROJECT_CLEANUP_SUMMARY/","title":"Project Cleanup Summary - November 2024","text":""},{"location":"PROJECT_CLEANUP_SUMMARY/#overview","title":"Overview","text":"<p>Completed comprehensive project cleanup addressing configuration consolidation and file organization as requested in multi-part user request (Nov 15, 2024).</p>"},{"location":"PROJECT_CLEANUP_SUMMARY/#completed-tasks","title":"Completed Tasks","text":""},{"location":"PROJECT_CLEANUP_SUMMARY/#task-1-configuration-consolidation","title":"\u2705 Task 1: Configuration Consolidation","text":"<p>Problem: <code>component_config.json</code> was in unusual location causing confusion - Main config: <code>/app/config/</code> (13 JSON files) - Service utilities: <code>/app/services/config/</code> - Unusual: <code>/app/services/search/components/component_config.json</code></p> <p>Solution: 1. Created <code>load_component_config()</code> in <code>app/config/schema_loader.py</code> 2. Updated <code>component_service.py</code> to use centralized loader 3. Moved <code>component_config.json</code> to <code>/app/config/</code> 4. Removed old file from unusual location</p> <p>Result: <pre><code>app/config/\n\u251c\u2500\u2500 component_config.json         \u2705 NOW HERE (consolidated)\n\u251c\u2500\u2500 master_parameter_schema.json\n\u251c\u2500\u2500 all other config files...\n\u2514\u2500\u2500 schema_loader.py              \u2705 NOW LOADS component_config.json\n\napp/services/config/              # Service utilities (appropriate)\n\u251c\u2500\u2500 config_validator.py\n\u251c\u2500\u2500 prompt_service.py\n\u2514\u2500\u2500 ...\n\napp/services/search/components/   # Search components only\n\u251c\u2500\u2500 component_service.py          \u2705 UPDATED to use loader\n\u2514\u2500\u2500 query_builder.py\n</code></pre></p> <p>Documentation: See <code>docs/CONFIG_CONSOLIDATION.md</code></p>"},{"location":"PROJECT_CLEANUP_SUMMARY/#task-2-move-archived-files-to-project-root","title":"\u2705 Task 2: Move Archived Files to Project Root","text":"<p>Problem: Archived files scattered in different locations within source tree - <code>/app/config/archived/</code> (unused JSON files) - <code>/app/archived_backups/</code> (refactoring backups)</p> <p>Solution: 1. Created <code>/archived/</code> directory at project root 2. Moved <code>/app/config/archived/</code> \u2192 <code>/archived/config_archived/</code> 3. Moved <code>/app/archived_backups/</code> \u2192 <code>/archived/refactoring_backups/</code> 4. Created comprehensive <code>archived/README.md</code> 5. Added <code>/archived/</code> to <code>.gitignore</code></p> <p>Result: <pre><code>Ayna_ESAB_Nov7/                   # Project root\n\u251c\u2500\u2500 archived/                     \u2705 NEW - All archived files here\n\u2502   \u251c\u2500\u2500 config_archived/          # Unused config files\n\u2502   \u2502   \u251c\u2500\u2500 legacy_json/\n\u2502   \u2502   \u2514\u2500\u2500 temp_backup/\n\u2502   \u251c\u2500\u2500 refactoring_backups/      # Phase 1-2 backup files\n\u2502   \u2502   \u251c\u2500\u2500 conversation.py.backup\n\u2502   \u2502   \u251c\u2500\u2500 product_search.py.backup\n\u2502   \u2502   \u251c\u2500\u2500 message_generator.py.backup\n\u2502   \u2502   \u2514\u2500\u2500 state_orchestrator.py.backup\n\u2502   \u2514\u2500\u2500 README.md                 # Comprehensive documentation\n\u2502\n\u251c\u2500\u2500 src/backend/app/config/       \u2705 CLEANED - Only active config files\n\u2502   \u251c\u2500\u2500 component_config.json\n\u2502   \u251c\u2500\u2500 master_parameter_schema.json\n\u2502   \u2514\u2500\u2500 ... (13 active config files)\n\u2502\n\u2514\u2500\u2500 .gitignore                    \u2705 UPDATED - Ignores /archived/\n</code></pre></p> <p>Benefits: - Cleaner source tree - All archived files in one location - Won't be committed to git - Easy to delete after 30 days</p>"},{"location":"PROJECT_CLEANUP_SUMMARY/#task-3-users-torch-dependencies-update","title":"\u2705 Task 3: User's Torch Dependencies Update","text":"<p>User already updated <code>component_config.json</code>: <pre><code>\"torch\": {\n  \"dependencies\": [\"feeder\", \"cooler\"],  // \u2705 Cooler added by user\n  \"description\": \"Welding torch selection (requires compatible feeder) and cooler\"\n}\n</code></pre></p> <p>Status: Already preserved in consolidated location</p>"},{"location":"PROJECT_CLEANUP_SUMMARY/#pending-task","title":"Pending Task","text":""},{"location":"PROJECT_CLEANUP_SUMMARY/#task-4-add-compatibility-to-lucenestrategy-search-query","title":"\u23f3 Task 4: Add Compatibility to LuceneStrategy Search Query","text":"<p>User Quote: \"Can we add this compatibility to the search query itself? Rather than manually validating.\"</p> <p>Current State: - LuceneStrategy returns all text matches without compatibility filtering - Compatibility validation happens in consolidation layer or not at all - CypherStrategy enforces compatibility DURING search (via Neo4j COMPATIBLE_WITH relationships)</p> <p>What Needs to Be Done: - Modify <code>ComponentSearchService.search_with_lucene()</code> to add Neo4j COMPATIBLE_WITH relationship filtering - Add compatibility WHERE clauses to Lucene Cypher queries - Ensure dependency chains are validated (power_source \u2192 feeder \u2192 torch \u2192 cooler)</p> <p>Implementation Approach: 1. Update <code>query_builder.py</code> to generate compatibility filters for Lucene queries 2. Add COMPATIBLE_WITH relationship matching to Lucene Cypher queries 3. Test with torch dependencies requiring both feeder AND cooler</p>"},{"location":"PROJECT_CLEANUP_SUMMARY/#files-modified","title":"Files Modified","text":""},{"location":"PROJECT_CLEANUP_SUMMARY/#configuration-consolidation","title":"Configuration Consolidation","text":"<ol> <li><code>/app/config/schema_loader.py</code> - Added <code>load_component_config()</code> function</li> <li><code>/app/services/search/components/component_service.py</code> - Updated to use loader</li> <li><code>/app/config/component_config.json</code> - Moved from <code>services/search/components/</code></li> </ol>"},{"location":"PROJECT_CLEANUP_SUMMARY/#archived-files-organization","title":"Archived Files Organization","text":"<ol> <li>Created <code>/archived/config_archived/</code> (moved from <code>/app/config/archived/</code>)</li> <li>Created <code>/archived/refactoring_backups/</code> (moved from <code>/app/archived_backups/</code>)</li> <li>Created <code>/archived/README.md</code> - Comprehensive documentation</li> <li>Updated <code>/.gitignore</code> - Added <code>/archived/</code> exclusion</li> </ol>"},{"location":"PROJECT_CLEANUP_SUMMARY/#documentation","title":"Documentation","text":"<ol> <li>Created <code>/docs/CONFIG_CONSOLIDATION.md</code> - Configuration consolidation details</li> <li>Created <code>/docs/PROJECT_CLEANUP_SUMMARY.md</code> - This file</li> </ol>"},{"location":"PROJECT_CLEANUP_SUMMARY/#project-structure-after-cleanup","title":"Project Structure (After Cleanup)","text":"<pre><code>Ayna_ESAB_Nov7/\n\u251c\u2500\u2500 archived/                              # \u2705 NEW - All archived files\n\u2502   \u251c\u2500\u2500 config_archived/\n\u2502   \u251c\u2500\u2500 refactoring_backups/\n\u2502   \u2514\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 docs/                                  # Documentation\n\u2502   \u251c\u2500\u2500 CONFIG_CONSOLIDATION.md           # \u2705 NEW\n\u2502   \u251c\u2500\u2500 PROJECT_CLEANUP_SUMMARY.md        # \u2705 NEW\n\u2502   \u2514\u2500\u2500 ... (other docs)\n\u2502\n\u251c\u2500\u2500 src/backend/app/\n\u2502   \u251c\u2500\u2500 config/                           # \u2705 CLEANED - 13 active config files\n\u2502   \u2502   \u251c\u2500\u2500 component_config.json         # \u2705 MOVED HERE\n\u2502   \u2502   \u251c\u2500\u2500 master_parameter_schema.json\n\u2502   \u2502   \u251c\u2500\u2500 schema_loader.py              # \u2705 UPDATED\n\u2502   \u2502   \u2514\u2500\u2500 ... (other active configs)\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u251c\u2500\u2500 config/                       # Service utilities (appropriate)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 config_validator.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 prompt_service.py\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u2514\u2500\u2500 search/\n\u2502   \u2502       \u2514\u2500\u2500 components/               # Search components only\n\u2502   \u2502           \u251c\u2500\u2500 component_service.py  # \u2705 UPDATED\n\u2502   \u2502           \u2514\u2500\u2500 query_builder.py\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 ... (other app directories)\n\u2502\n\u251c\u2500\u2500 .gitignore                            # \u2705 UPDATED - Ignores /archived/\n\u2514\u2500\u2500 ... (other project files)\n</code></pre>"},{"location":"PROJECT_CLEANUP_SUMMARY/#configuration-directory-clarity","title":"Configuration Directory Clarity","text":""},{"location":"PROJECT_CLEANUP_SUMMARY/#main-config-directory-appconfig","title":"Main Config Directory (<code>/app/config/</code>)","text":"<p>Purpose: All configuration JSON files + schema loader utility</p> <p>13 Active Configuration Files: 1. <code>component_config.json</code> - Component search configuration (13 component types) 2. <code>master_parameter_schema.json</code> - Dynamic MasterParameterJSON schema 3. <code>component_types.json</code> - State factory configuration 4. <code>component_applicability.json</code> - Y/N component rules per power source 5. <code>parameter_normalizations.json</code> - Query builder normalizations 6. <code>category_features_llm.json</code> - Neo4j feature reference 7. <code>product_names.json</code> - Product name lookup cache 8. <code>search_config.json</code> - Search strategy configuration 9. <code>state_config.json</code> - State definitions 10. <code>state_prompts.json</code> - State-specific prompts 11. <code>llm_config.json</code> - LLM settings (kept for future use) 12. <code>llm_prompts.json</code> - LLM prompts 13. <code>languages.json</code> - Language support</p> <p>1 Utility Module: - <code>schema_loader.py</code> - Centralized config loading with caching</p>"},{"location":"PROJECT_CLEANUP_SUMMARY/#service-config-directory-appservicesconfig","title":"Service Config Directory (<code>/app/services/config/</code>)","text":"<p>Purpose: Service utilities for configuration validation and management</p> <p>4 Service Utility Files: 1. <code>config_monitor.py</code> - Configuration monitoring 2. <code>config_validator.py</code> - Configuration validation 3. <code>configuration_service.py</code> - Configuration management service 4. <code>prompt_service.py</code> - Prompt template service</p> <p>Why Separate? These are service utilities, not configuration data files. Appropriate to keep separate.</p>"},{"location":"PROJECT_CLEANUP_SUMMARY/#search-components-directory-appservicessearchcomponents","title":"Search Components Directory (<code>/app/services/search/components/</code>)","text":"<p>Purpose: Search service components only (no config files)</p> <p>2 Component Files: 1. <code>component_service.py</code> - Generic search service (uses <code>load_component_config()</code>) 2. <code>query_builder.py</code> - Neo4j query builder (receives config as parameter)</p> <p>Previously Had: <code>component_config.json</code> (now moved to main config directory)</p>"},{"location":"PROJECT_CLEANUP_SUMMARY/#benefits-achieved","title":"Benefits Achieved","text":""},{"location":"PROJECT_CLEANUP_SUMMARY/#configuration-consolidation_1","title":"Configuration Consolidation","text":"<p>\u2705 All config JSON files in one location (<code>/app/config/</code>) \u2705 Centralized loading with caching (<code>schema_loader.py</code>) \u2705 Consistent error handling \u2705 Easier to discover and maintain \u2705 User's torch dependency update preserved</p>"},{"location":"PROJECT_CLEANUP_SUMMARY/#archived-files-organization_1","title":"Archived Files Organization","text":"<p>\u2705 Cleaner source tree (no archived files in <code>/app/</code>) \u2705 Single location for all archived files (<code>/archived/</code>) \u2705 Won't be committed to git (<code>.gitignore</code>) \u2705 Comprehensive documentation in <code>archived/README.md</code> \u2705 Easy to delete after validation period (30 days)</p>"},{"location":"PROJECT_CLEANUP_SUMMARY/#next-steps","title":"Next Steps","text":"<ol> <li>Test Configuration Consolidation</li> <li>Start server: <code>uvicorn app.main:app --reload</code></li> <li>Verify logs show: \"Loaded component config with 13 component types\"</li> <li> <p>Test component searches work correctly</p> </li> <li> <p>Implement LuceneStrategy Compatibility</p> </li> <li>Add compatibility filtering to Lucene search queries</li> <li>Test with torch dependencies (requires feeder AND cooler)</li> <li> <p>Ensure compatibility validation happens DURING search</p> </li> <li> <p>Integration Testing</p> </li> <li>Run full test suite after changes</li> <li>Test all 13 component types</li> <li> <p>Verify dependency chains work correctly</p> </li> <li> <p>Archive Cleanup (After 30 days)</p> </li> <li>Verify production stability</li> <li>Delete <code>/archived/</code> directory if no longer needed</li> <li>Or keep for historical reference (already gitignored)</li> </ol>"},{"location":"PROJECT_CLEANUP_SUMMARY/#documentation-references","title":"Documentation References","text":"<ul> <li>Configuration Consolidation: <code>docs/CONFIG_CONSOLIDATION.md</code></li> <li>Archived Files: <code>archived/README.md</code></li> <li>Project Cleanup: <code>docs/PROJECT_CLEANUP_SUMMARY.md</code> (this file)</li> </ul>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/","title":"Search Configuration Update Guide","text":""},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#purpose","title":"Purpose","text":"<p>This guide describes the new configuration sections to add to <code>search_config.json</code> for the pluggable search architecture.</p>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#required-changes","title":"Required Changes","text":""},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#1-add-strategy-configuration-section","title":"1. Add Strategy Configuration Section","text":"<p>Add this new section to <code>search_config.json</code>:</p> <pre><code>{\n  \"strategies\": {\n    \"cypher\": {\n      \"enabled\": true,\n      \"weight\": 0.4,\n      \"description\": \"Neo4j Cypher graph-based compatibility search\"\n    },\n    \"lucene\": {\n      \"enabled\": true,\n      \"weight\": 0.6,\n      \"description\": \"Lucene full-text relevance search\"\n    },\n    \"vector\": {\n      \"enabled\": false,\n      \"weight\": 0.5,\n      \"description\": \"Vector similarity search (future)\"\n    }\n  }\n}\n</code></pre>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#2-add-search-orchestration-section","title":"2. Add Search Orchestration Section","text":"<p>Add this new section:</p> <pre><code>{\n  \"orchestration\": {\n    \"execution_mode\": \"parallel\",\n    \"fallback_on_error\": true,\n    \"require_at_least_one_success\": true,\n    \"timeout_seconds\": 30,\n    \"description\": \"Controls how multiple search strategies are executed\"\n  }\n}\n</code></pre>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#3-add-result-consolidation-section","title":"3. Add Result Consolidation Section","text":"<p>Add this new section:</p> <pre><code>{\n  \"consolidation\": {\n    \"default_score_for_unscored\": 0.5,\n    \"score_normalization\": \"none\",\n    \"description\": \"Controls how results from multiple strategies are merged\",\n    \"notes\": {\n      \"score_normalization\": \"Options: 'none', 'min_max', 'z_score'\"\n    }\n  }\n}\n</code></pre>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#complete-updated-structure","title":"Complete Updated Structure","text":"<p>Here's how the updated <code>search_config.json</code> should look (abbreviated):</p> <pre><code>{\n  \"version\": \"2.1.0\",\n  \"description\": \"Search and product matching configuration with pluggable strategies\",\n  \"last_updated\": \"2025-01-XX\",\n\n  \"strategies\": {\n    \"cypher\": {\n      \"enabled\": true,\n      \"weight\": 0.4,\n      \"description\": \"Neo4j Cypher graph-based compatibility search\"\n    },\n    \"lucene\": {\n      \"enabled\": true,\n      \"weight\": 0.6,\n      \"description\": \"Lucene full-text relevance search\"\n    }\n  },\n\n  \"orchestration\": {\n    \"execution_mode\": \"parallel\",\n    \"fallback_on_error\": true,\n    \"require_at_least_one_success\": true,\n    \"timeout_seconds\": 30\n  },\n\n  \"consolidation\": {\n    \"default_score_for_unscored\": 0.5,\n    \"score_normalization\": \"none\"\n  },\n\n  \"fuzzy_matching\": {\n    ... existing configuration ...\n  },\n\n  \"search_limits\": {\n    ... existing configuration ...\n  },\n\n  \"lucene_search\": {\n    ... existing configuration ...\n  },\n\n  ... other existing sections ...\n}\n</code></pre>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#configuration-details","title":"Configuration Details","text":""},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#strategy-weights","title":"Strategy Weights","text":"<p>Strategy weights control how scores are combined when multiple strategies return the same product:</p> <ul> <li>Lucene weight: 0.6 - Higher weight because Lucene provides relevance scoring</li> <li>Cypher weight: 0.4 - Lower weight because Cypher uses priority-based ranking</li> </ul> <p>Formula: <code>consolidated_score = (lucene_score * 0.6 + cypher_score * 0.4) / (0.6 + 0.4)</code></p> <p>Configurable: Change weights based on your preference. Higher weight = more influence on final score.</p>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#execution-mode","title":"Execution Mode","text":"<p>parallel: Execute all strategies simultaneously (faster, default) sequential: Execute strategies one after another (slower, useful for debugging)</p>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#fallback-behavior","title":"Fallback Behavior","text":"<p>fallback_on_error: true - If one strategy fails, continue with others fallback_on_error: false - If any strategy fails, entire search fails</p>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#score-normalization","title":"Score Normalization","text":"<p>none (default): Use raw consolidated scores min_max: Normalize scores to [0, 1] range z_score: Normalize using statistical z-scores</p>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#migration-steps","title":"Migration Steps","text":"<ol> <li> <p>Backup: Copy current <code>search_config.json</code> to <code>search_config.json.backup</code></p> </li> <li> <p>Update: Add the three new sections (strategies, orchestration, consolidation)</p> </li> <li> <p>Verify: Ensure JSON is valid (use a JSON validator)</p> </li> <li> <p>Test: Start application and verify SearchOrchestrator loads configuration correctly</p> </li> <li> <p>Monitor: Check logs for strategy initialization messages</p> </li> </ol>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#default-values","title":"Default Values","text":"<p>If configuration sections are missing, the system uses these defaults:</p> <ul> <li><code>strategies.*.enabled</code>: <code>true</code></li> <li><code>strategies.*.weight</code>: <code>1.0</code></li> <li><code>orchestration.execution_mode</code>: <code>\"parallel\"</code></li> <li><code>orchestration.fallback_on_error</code>: <code>true</code></li> <li><code>orchestration.timeout_seconds</code>: <code>30</code></li> <li><code>consolidation.default_score_for_unscored</code>: <code>0.5</code></li> <li><code>consolidation.score_normalization</code>: <code>\"none\"</code></li> </ul>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#adjusting-strategy-weights","title":"Adjusting Strategy Weights","text":""},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#scenario-1-trust-cypher-more-compatibility-over-relevance","title":"Scenario 1: Trust Cypher More (Compatibility Over Relevance)","text":"<pre><code>{\n  \"strategies\": {\n    \"cypher\": {\"enabled\": true, \"weight\": 0.7},\n    \"lucene\": {\"enabled\": true, \"weight\": 0.3}\n  }\n}\n</code></pre>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#scenario-2-only-use-lucene-disable-cypher","title":"Scenario 2: Only Use Lucene (Disable Cypher)","text":"<pre><code>{\n  \"strategies\": {\n    \"cypher\": {\"enabled\": false, \"weight\": 0.4},\n    \"lucene\": {\"enabled\": true, \"weight\": 0.6}\n  }\n}\n</code></pre>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#scenario-3-equal-weighting","title":"Scenario 3: Equal Weighting","text":"<pre><code>{\n  \"strategies\": {\n    \"cypher\": {\"enabled\": true, \"weight\": 0.5},\n    \"lucene\": {\"enabled\": true, \"weight\": 0.5}\n  }\n}\n</code></pre>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#testing-configuration-changes","title":"Testing Configuration Changes","text":"<p>After updating configuration:</p> <pre><code># Restart application\nsystemctl restart esab-recommender.service\n\n# Check logs for strategy initialization\ntail -f /path/to/logs/esab-recommender.log | grep -i \"strategy\\|orchestrator\"\n\n# Expected log messages:\n# - \"CypherSearchStrategy initialized (weight: 0.4)\"\n# - \"LuceneSearchStrategy initialized (weight: 0.6)\"\n# - \"SearchOrchestrator initialized with 2 strategies (mode: parallel)\"\n# - \"ResultConsolidator initialized with weights: {'lucene': 0.6, 'cypher': 0.4}\"\n</code></pre>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#troubleshooting","title":"Troubleshooting","text":"<p>Issue: \"SearchOrchestrator initialized with 0 strategies\" Solution: Check that at least one strategy has <code>\"enabled\": true</code></p> <p>Issue: \"KeyError: 'strategies'\" Solution: Add the strategies section to search_config.json</p> <p>Issue: Products not consolidating correctly Solution: Check strategy weights sum to a reasonable total (typically 0.5-2.0)</p>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#version-history","title":"Version History","text":"<ul> <li>v2.1.0: Added pluggable search architecture with strategies, orchestration, consolidation</li> <li>v1.0: Original configuration with Lucene and fuzzy matching</li> </ul>"},{"location":"SEARCH_CONFIG_UPDATE_GUIDE/#see-also","title":"See Also","text":"<ul> <li><code>/docs/PRODUCT_SEARCH_SERVICE.md</code> - Product search architecture</li> <li><code>/docs/CORRECTED_STATE_FLOW_ARCHITECTURE.md</code> - State machine flow</li> <li><code>/src/backend/app/services/search/</code> - Search strategy implementations</li> </ul>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/","title":"Search Strategy Improvements - Implementation Log","text":"<p>Date: January 2025 Purpose: Enhanced Vector Search and LLM Strategy for improved semantic understanding and ranking accuracy Status: IN PROGRESS</p>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#implementation-summary","title":"Implementation Summary","text":""},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#completed-phase-1-vector-search-enhancement","title":"Completed: Phase 1 - Vector Search Enhancement","text":""},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#11-vector-search-configuration-completed","title":"1.1 Vector Search Configuration (\u2705 COMPLETED)","text":"<p>File: <code>src/backend/app/config/search_config.json</code></p> <p>Changes: - Enabled vector search: <code>enabled: true</code> - Increased weight: <code>0.5 \u2192 0.6</code> (higher influence for semantic understanding) - Lowered min_score threshold: <code>0.6 \u2192 0.4</code> (better recall, more permissive matching) - Updated description to reflect enhancements</p> <p>Rationale: - Higher weight (0.6) prioritizes semantic understanding over simple keyword matching - Lower min_score (0.4) reduces false negatives, allowing more semantically similar products to pass through - Weight increase balanced against Lucene (0.6) for optimal semantic + keyword matching</p>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#12-context-enrichment-completed","title":"1.2 Context Enrichment (\u2705 COMPLETED)","text":"<p>File: <code>src/backend/app/services/search/strategies/vector_strategy.py</code></p> <p>Changes: 1. Added <code>_enrich_query_context()</code> method (lines 66-110):    - Combines user message with extracted parameters from <code>master_parameters</code>    - Adds technical requirements (cooling_type, current_output, etc.) to embedding context    - Includes component type for categorical awareness    - Format: <code>\"user message | param1: value1 | param2: value2 | Component type: Feeder\"</code></p> <ol> <li>Modified <code>search()</code> method (lines 137-150):</li> <li>Calls <code>_enrich_query_context()</code> before generating embeddings</li> <li>Passes enriched context to OpenAI API instead of raw user message</li> <li>Logs enriched context for debugging</li> </ol> <p>Expected Impact: - 30-40% improvement in semantic matching by including extracted features - Better understanding of user intent through structured parameters - More accurate product ranking based on technical requirements</p> <p>Example: <pre><code># BEFORE:\ninput=\"I need a feeder\"\n\n# AFTER:\ninput=\"I need a feeder | cooling_type: water-cooled | current_output: 500A | Component type: Feeder\"\n</code></pre></p>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#13-specification-aware-filtering-completed","title":"1.3 Specification-Aware Filtering (\u2705 COMPLETED)","text":"<p>File: <code>src/backend/app/services/search/strategies/vector_strategy.py</code></p> <p>Changes: 1. Added <code>_filter_by_specifications()</code> method (lines 112-236):    - Post-filters vector search results based on parameter matching    - Uses RapidFuzz for fuzzy string matching (80% similarity threshold per parameter)    - Keeps products matching \u226570% of specified parameters    - Smart field mapping: <code>cooling_type \u2192 cooling</code>, <code>current_output \u2192 current_range</code>    - Substring matching for partial matches (e.g., \"water\" in \"water-cooled\")    - Comprehensive debug logging for transparency</p> <ol> <li>Modified <code>search()</code> method (lines 196-204):</li> <li>Added filtering call after vector search</li> <li>Only applies when master_parameters contains component specifications</li> <li>Logs before/after product counts</li> </ol> <p>Expected Impact: - 25-35% reduction in false positives by removing semantically similar but specification-incompatible products - Better precision without sacrificing recall (already improved via lower min_score) - Clear audit trail via debug logging showing which parameters matched</p> <p>Example: <pre><code># User query: \"I need a water-cooled feeder for 500A\"\n# master_parameters = {\"feeder\": {\"cooling_type\": \"water-cooled\", \"current_output\": \"500A\"}}\n\n# BEFORE (vector search only):\n# Results: All feeders semantically similar to query (including air-cooled, 300A, etc.)\n\n# AFTER (with specification filtering):\n# Results: Only water-cooled feeders with current output near 500A\n# Products matching \u226570% of requirements (2/2 or 1/2 parameters)\n</code></pre></p>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#pending-implementation","title":"Pending Implementation","text":""},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#phase-2-llm-strategy-enhancement","title":"Phase 2: LLM Strategy Enhancement","text":"<p>Status: PENDING Files: - <code>src/backend/app/config/search_config.json</code> (already enabled, weight increased) - <code>src/backend/app/services/search/strategies/llm_strategy.py</code></p> <p>Planned Changes: 1. Enhanced Re-ranking Context:    - Add user requirements from <code>master_parameters</code> to LLM prompt    - Include selected components for compatibility context    - Expected impact: 40-50% improvement in ranking accuracy</p> <ol> <li>Improved Scoring Rubric:</li> <li>More detailed scoring guidelines (95-100, 85-94, 70-84, etc.)</li> <li>Critical factors: exact match, spec alignment, compatibility, material, features</li> <li>Expected impact: More consistent and accurate scoring</li> </ol>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#phase-3-cross-strategy-improvements","title":"Phase 3: Cross-Strategy Improvements","text":"<p>Status: PENDING File: <code>src/backend/app/services/search/consolidator.py</code></p> <p>Planned Changes: 1. Score Normalization:    - Add min-max normalization per strategy before weighted average    - Ensures fair contribution from all strategies    - Reduces score inflation</p> <ol> <li>Exact Match Boosting:</li> <li>Reduce from 100x \u2192 10x multiplier</li> <li>Add cap at max_score = 1.0</li> <li>More balanced scoring across strategies</li> </ol>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#phase-4-monitoring-configuration","title":"Phase 4: Monitoring &amp; Configuration","text":"<p>Status: PENDING</p> <p>Planned Changes: 1. Strategy Performance Logging (orchestrator.py) 2. Updated Strategy Weights (search_config.json) 3. Comprehensive Test Scenarios (test_enhanced_search.py)</p>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#technical-architecture","title":"Technical Architecture","text":""},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#vector-search-flow-enhanced","title":"Vector Search Flow (ENHANCED)","text":"<pre><code>User Message \u2192 Parameter Extraction (LLM)\n    \u2193\nExtract Features (cooling_type, current_output, etc.)\n    \u2193\nEnrich Query Context (\u2705 NEW)\n    \"user message | param1: value1 | param2: value2 | Component: Type\"\n    \u2193\nGenerate OpenAI Embedding (text-embedding-3-large, 3072 dims)\n    \u2193\nNeo4j Vector Index Search (min_score=0.4)  \u2190 Lowered threshold\n    \u2193\nPost-Filter by Specifications (PENDING - Phase 1.3)\n    \u2193\nReturn Ranked Results (weight=0.6)  \u2190 Increased weight\n</code></pre>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#expected-overall-impact","title":"Expected Overall Impact","text":"Metric Current Expected Improvement Vector Search Accuracy N/A (disabled) 75-80% NEW LLM Re-ranking Accuracy N/A (disabled) 80-85% NEW Combined Accuracy ~65% 85-90% +20-25% Semantic Understanding ~45% 75-80% +30-35% Exact Match Detection ~95% ~95% 0% (already good)"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#configuration-reference","title":"Configuration Reference","text":""},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#current-strategy-weights-search_configjson","title":"Current Strategy Weights (search_config.json)","text":"<pre><code>{\n  \"cypher\": {\"enabled\": true, \"weight\": 0.4, \"min_score\": 0.1},\n  \"lucene\": {\"enabled\": true, \"weight\": 0.6, \"min_score\": 0.3},\n  \"vector\": {\"enabled\": true, \"weight\": 0.6, \"min_score\": 0.4},  // \u2705 ENHANCED\n  \"llm\": {\"enabled\": true, \"weight\": 0.5}                         // \u2705 ENHANCED\n}\n</code></pre> <p>Rationale: - Vector (0.6): Highest weight for semantic understanding with context enrichment - Lucene (0.6): Equal weight for keyword relevance (tied with vector) - LLM (0.5): High weight for intelligent re-ranking with user context - Cypher (0.4): Lower weight as compatibility is binary (compatible or not)</p>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#testing-strategy","title":"Testing Strategy","text":""},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#test-scenarios-pending-phase-5","title":"Test Scenarios (PENDING - Phase 5)","text":"<ol> <li>Semantic Similarity: \"500A MIG welder for aluminum\" \u2192 Should prioritize aluminum-capable welders</li> <li>Context-Aware: PowerSource selected \u2192 Feeder search should prioritize compatible feeders</li> <li>Competitor Equivalent: \"Miller XMT 350\" \u2192 Should find ESAB equivalent</li> <li>Specification Range: \"400-600A\" \u2192 Should match 500A products</li> <li>LLM Re-ranking: Products meeting ALL requirements \u2192 Should rank higher than partial matches</li> </ol>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#next-steps","title":"Next Steps","text":"<ol> <li>\u2705 Phase 1.1 completed - Vector search configured</li> <li>\u2705 Phase 1.2 completed - Context enrichment added</li> <li>Phase 1.3 (NEXT) - Add specification-aware filtering</li> <li>Phase 2 - Enhance LLM strategy with user context</li> <li>Phase 3 - Implement score normalization</li> <li>Phase 4 - Add performance logging</li> <li>Phase 5 - Create test scenarios and validate</li> </ol>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#developer-notes","title":"Developer Notes","text":""},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#how-to-test-context-enrichment","title":"How to Test Context Enrichment","text":"<pre><code>cd src/backend\n\n# Run server with debug logging\nuvicorn app.main:app --host 0.0.0.0 --port 8000 --reload --log-level DEBUG\n\n# Monitor logs for enriched context\ntail -f backend.log | grep \"Enriched query context\"\n\n# Test query\ncurl -X POST http://localhost:8000/api/v1/configurator/message \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"message\": \"I need a water-cooled feeder for 500A\", \"language\": \"en\"}'\n</code></pre>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#expected-log-output","title":"Expected Log Output","text":"<pre><code>2025-01-XX XX:XX:XX.XXX [DEBUG] Enriched query context: I need a water-cooled feeder for 500A | cooling_type: water-cooled | current_output: 500A | Component type: Feeder\n</code></pre>"},{"location":"SEARCH_IMPROVEMENTS_IMPLEMENTATION/#references","title":"References","text":"<ul> <li>Implementation Plan: docs/SEARCH_IMPROVEMENTS_PLAN.md (if exists)</li> <li>Vector Strategy: app/services/search/strategies/vector_strategy.py</li> <li>LLM Strategy: app/services/search/strategies/llm_strategy.py</li> <li>Search Config: app/config/search_config.json</li> <li>Consolidator: app/services/search/consolidator.py</li> </ul> <p>Last Updated: January 2025 Implementation Status: 25% Complete (3 of 12 phases)</p> <p>Phase 1 Vector Search (COMPLETED): - \u2705 Phase 1.1: Configuration adjustments - \u2705 Phase 1.2: Context enrichment - \u2705 Phase 1.3: Specification filtering</p> <p>Phases Remaining: 9 phases (Phase 2-5)</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/","title":"Search Strategies and Scoring Architecture","text":"<p>File: Multiple search-related modules in <code>src/backend/app/services/search/</code></p> <p>The ESAB Configurator implements a sophisticated multi-strategy search system that combines graph-based compatibility search with full-text relevance matching to provide accurate product recommendations.</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Architecture Overview</li> <li>Search Orchestrator</li> <li>Search Strategies</li> <li>Query Building System</li> <li>Normalization Systems</li> <li>Result Consolidation</li> <li>Scoring Algorithms</li> <li>Performance Optimization</li> <li>Configuration</li> <li>Code Examples</li> </ol>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#architecture-overview","title":"Architecture Overview","text":""},{"location":"SEARCH_STRATEGIES_AND_SCORING/#multi-strategy-search-pattern","title":"Multi-Strategy Search Pattern","text":"<p>The configurator uses multiple complementary search strategies that are orchestrated in parallel or sequentially to provide comprehensive product search results.</p> <p>Available Strategies: - CypherSearchStrategy - Graph-based compatibility search using Neo4j relationships - LuceneSearchStrategy - Full-text search with relevance ranking using Neo4j Lucene indexes - VectorSearchStrategy - Semantic similarity search using OpenAI embeddings (text-embedding-3-large) - LLMSearchStrategy - Retrieve-then-rerank using LLM evaluation (GPT-4o-mini)</p> <p>Architecture Pattern: Strategy + Orchestrator Pattern</p> <pre><code>User Query\n    \u2193\nSearchOrchestrator\n    \u251c\u2500\u2192 CypherSearchStrategy (Graph compatibility)\n    \u251c\u2500\u2192 LuceneSearchStrategy (Full-text relevance)\n    \u251c\u2500\u2192 VectorSearchStrategy (Semantic similarity)\n    \u2514\u2500\u2192 LLMSearchStrategy (LLM re-ranking)\n    \u2193\nResultConsolidator\n    \u251c\u2500\u2192 Deduplicate by GIN\n    \u251c\u2500\u2192 Merge weighted scores\n    \u251c\u2500\u2192 Apply exact match boosting (100x)\n    \u2514\u2500\u2192 Filter by score threshold\n    \u2193\nRanked Product List\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#key-benefits","title":"Key Benefits","text":"<ol> <li>Comprehensive Coverage - Combines relationship-based and text-based search</li> <li>Fault Tolerance - Continues if individual strategies fail (fallback_on_error=true)</li> <li>Weighted Ranking - Configurable strategy weights for optimal results</li> <li>Context Awareness - Different strategies for proactive vs user-intent modes</li> <li>Exact Match Prioritization - 100x score boost for exact product name matches</li> </ol>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#search-orchestrator","title":"Search Orchestrator","text":"<p>File: <code>src/backend/app/services/search/orchestrator.py</code> (571 lines)</p> <p>The SearchOrchestrator coordinates multiple search strategies and consolidates their results.</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#core-responsibilities","title":"Core Responsibilities","text":"<pre><code>class SearchOrchestrator:\n    \"\"\"\n    Orchestrates multiple search strategies and consolidates results.\n\n    Configuration:\n    - execution_mode: \"parallel\" or \"sequential\"\n    - timeout: Strategy timeout in seconds (default: 30)\n    - fallback_on_error: Continue if strategy fails (default: True)\n\n    Features:\n    - Parallel or sequential strategy execution\n    - Context-based strategy selection\n    - Result consolidation with scoring\n    - Zero-results handling\n    - Performance monitoring\n    \"\"\"\n\n    def __init__(\n        self,\n        strategies: List[SearchStrategy],\n        consolidator: ResultConsolidator,\n        execution_mode: str = \"parallel\",\n        timeout: int = 30,\n        fallback_on_error: bool = True\n    ):\n        self.strategies = strategies\n        self.consolidator = consolidator\n        self.execution_mode = execution_mode\n        self.timeout = timeout\n        self.fallback_on_error = fallback_on_error\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#context-based-strategy-selection","title":"Context-Based Strategy Selection","text":"<p>The orchestrator automatically selects strategies based on the search context:</p> <p>Proactive Display Mode (Fast compatibility): <pre><code># Triggered by command keywords: skip, done, next, finalize, yes, no, \"\"\n# Use case: User navigating states without specific product requirements\n# Strategy: Cypher only (fast graph traversal)\n\ncommand_keywords = [\"skip\", \"done\", \"next\", \"finalize\", \"yes\", \"no\", \"\"]\nis_proactive_display = user_message.lower().strip() in command_keywords\n\nif is_proactive_display:\n    context_strategies = [\"cypher\"]  # Fast compatibility only\n</code></pre></p> <p>User Intent Mode (Semantic matching): <pre><code># Triggered by: User provides product specifications\n# Use case: \"I need a 500A MIG welder for aluminum\"\n# Strategy: Cypher + Lucene (graph + full-text)\n\nelse:\n    context_strategies = [\"cypher\", \"lucene\"]  # Full search\n</code></pre></p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#parallel-execution","title":"Parallel Execution","text":"<p>Performance: ~40-60% faster than sequential for 2+ strategies</p> <pre><code>async def _execute_parallel(\n    self,\n    strategies: List[SearchStrategy],\n    component_type: str,\n    user_message: str,\n    master_parameters: Dict[str, Any],\n    selected_components: Dict[str, Any],\n    limit: int,\n    offset: int\n) -&gt; List[Optional[StrategySearchResult]]:\n    \"\"\"\n    Execute multiple strategies concurrently using asyncio.gather().\n\n    Benefits:\n    - Maximum performance (parallel I/O)\n    - Timeouts per strategy (prevents hanging)\n    - Exception isolation (one failure doesn't block others)\n\n    Returns:\n        List of results or None for failed strategies\n    \"\"\"\n    tasks = []\n    for strategy in strategies:\n        # Wrap each strategy call with timeout protection\n        task = asyncio.wait_for(\n            strategy.search(\n                component_type=component_type,\n                user_message=user_message,\n                master_parameters=master_parameters,\n                selected_components=selected_components,\n                limit=limit,\n                offset=offset\n            ),\n            timeout=self.timeout  # 30 seconds default\n        )\n        tasks.append(task)\n\n    # Execute all tasks concurrently\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n\n    # Handle exceptions gracefully\n    processed_results = []\n    for i, result in enumerate(results):\n        if isinstance(result, Exception):\n            logger.error(\n                f\"\u274c Strategy {strategies[i].get_name()} failed: {result}\"\n            )\n            if self.fallback_on_error:\n                processed_results.append(None)  # Skip failed strategy\n            else:\n                raise result  # Propagate error\n        else:\n            processed_results.append(result)\n\n    return processed_results\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#sequential-execution","title":"Sequential Execution","text":"<p>Use Case: Resource-constrained environments or ordered execution requirements</p> <pre><code>async def _execute_sequential(\n    self,\n    strategies: List[SearchStrategy],\n    component_type: str,\n    user_message: str,\n    master_parameters: Dict[str, Any],\n    selected_components: Dict[str, Any],\n    limit: int,\n    offset: int\n) -&gt; List[Optional[StrategySearchResult]]:\n    \"\"\"\n    Execute strategies one at a time in order.\n\n    Benefits:\n    - Lower memory usage\n    - Predictable resource consumption\n    - Early exit on first success (optional)\n\n    Returns:\n        List of results or None for failed strategies\n    \"\"\"\n    results = []\n\n    for strategy in strategies:\n        try:\n            result = await asyncio.wait_for(\n                strategy.search(\n                    component_type=component_type,\n                    user_message=user_message,\n                    master_parameters=master_parameters,\n                    selected_components=selected_components,\n                    limit=limit,\n                    offset=offset\n                ),\n                timeout=self.timeout\n            )\n            results.append(result)\n\n        except Exception as e:\n            logger.error(f\"\u274c Strategy {strategy.get_name()} failed: {e}\")\n            if self.fallback_on_error:\n                results.append(None)\n            else:\n                raise\n\n    return results\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#main-search-method","title":"Main Search Method","text":"<pre><code>async def search(\n    self,\n    component_type: str,\n    user_message: str,\n    master_parameters: Dict[str, Any],\n    selected_components: Dict[str, Any],\n    limit: int = 10,\n    offset: int = 0\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Execute multi-strategy search and consolidate results.\n\n    Flow:\n    1. Detect proactive vs user-intent mode\n    2. Select context-appropriate strategies\n    3. Execute strategies (parallel or sequential)\n    4. Consolidate results with scoring\n    5. Apply pagination\n    6. Generate consolidation report\n\n    Returns:\n        Dict with products, scores, metadata, report\n    \"\"\"\n    logger.info(\n        f\"\ud83d\udd0d SearchOrchestrator.search() | Component: {component_type} | \"\n        f\"Mode: {self.execution_mode} | Message: '{user_message[:50]}...'\"\n    )\n\n    # Step 1: Context-based strategy selection\n    command_keywords = [\"skip\", \"done\", \"next\", \"finalize\", \"yes\", \"no\", \"\"]\n    is_proactive_display = user_message.lower().strip() in command_keywords\n\n    if is_proactive_display:\n        context_strategies = [\"cypher\"]\n        logger.info(\"\ud83c\udfaf PROACTIVE MODE: Using Cypher only (fast compatibility)\")\n    else:\n        context_strategies = [\"cypher\", \"lucene\"]\n        logger.info(\"\ud83c\udfaf USER INTENT MODE: Using Cypher + Lucene (full search)\")\n\n    # Step 2: Filter enabled strategies matching context\n    enabled_strategies = [\n        s for s in self.strategies\n        if s.config.get(\"enabled\", True) and s.get_name() in context_strategies\n    ]\n\n    if not enabled_strategies:\n        logger.warning(\"\u26a0\ufe0f No enabled strategies found\")\n        return {\n            \"products\": [],\n            \"scores\": {},\n            \"metadata\": {\"error\": \"No strategies available\"},\n            \"consolidation_report\": {}\n        }\n\n    # Step 3: Execute strategies\n    if self.execution_mode == \"parallel\":\n        strategy_results = await self._execute_parallel(\n            enabled_strategies, component_type, user_message,\n            master_parameters, selected_components, limit, offset\n        )\n    else:\n        strategy_results = await self._execute_sequential(\n            enabled_strategies, component_type, user_message,\n            master_parameters, selected_components, limit, offset\n        )\n\n    # Step 4: Filter successful results\n    successful_results = [r for r in strategy_results if r is not None]\n\n    if not successful_results:\n        logger.warning(\"\u26a0\ufe0f All strategies returned no results\")\n        return {\n            \"products\": [],\n            \"scores\": {},\n            \"metadata\": {\"all_strategies_failed\": True},\n            \"consolidation_report\": {}\n        }\n\n    # Step 5: Consolidate results\n    consolidated = self.consolidator.consolidate(\n        strategy_results=[(r.strategy_name, r.products, r.scores)\n                         for r in successful_results],\n        master_parameters=master_parameters,\n        component_type=component_type\n    )\n\n    # Step 6: Apply pagination\n    paginated = consolidated[offset : offset + limit]\n\n    # Step 7: Generate consolidation report\n    report = self.consolidator.generate_consolidation_report(\n        strategy_results=[(r.strategy_name, r.products, r.scores)\n                         for r in successful_results],\n        consolidated_results=consolidated\n    )\n\n    logger.info(\n        f\"\u2705 Search complete | Total: {len(consolidated)} | \"\n        f\"Returned: {len(paginated)} | Strategies: {len(successful_results)}\"\n    )\n\n    return {\n        \"products\": [\n            {\n                \"gin\": r.gin,\n                \"name\": r.name,\n                \"category\": r.category,\n                \"description\": r.description,\n                \"specifications\": r.specifications,\n                \"score\": r.consolidated_score\n            }\n            for r in paginated\n        ],\n        \"scores\": {r.gin: r.consolidated_score for r in paginated},\n        \"metadata\": {\n            \"total_results\": len(consolidated),\n            \"returned_results\": len(paginated),\n            \"strategies_used\": [s.get_name() for s in enabled_strategies],\n            \"execution_mode\": self.execution_mode\n        },\n        \"consolidation_report\": report\n    }\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#search-strategies","title":"Search Strategies","text":""},{"location":"SEARCH_STRATEGIES_AND_SCORING/#base-strategy-interface","title":"Base Strategy Interface","text":"<p>File: <code>src/backend/app/services/search/strategies/base.py</code> (124 lines)</p> <p>All search strategies implement the abstract <code>SearchStrategy</code> interface:</p> <pre><code>class SearchStrategy(ABC):\n    \"\"\"\n    Abstract base class for all search strategies.\n\n    Implementations must provide:\n    - search(): Execute product search with scoring\n    - validate_compatibility(): Check product compatibility\n    - get_name(): Return strategy identifier\n    \"\"\"\n\n    def __init__(self, config: Dict[str, Any]):\n        \"\"\"\n        Initialize strategy with configuration.\n\n        Args:\n            config: Strategy configuration dict\n                - enabled: bool (default: True)\n                - weight: float (default: 1.0)\n                - custom strategy parameters\n        \"\"\"\n        self.config = config\n        self.enabled = config.get(\"enabled\", True)\n        self.weight = config.get(\"weight\", 1.0)\n\n    @abstractmethod\n    async def search(\n        self,\n        component_type: str,\n        user_message: str,\n        master_parameters: Dict[str, Any],\n        selected_components: Dict[str, Any],\n        limit: int = 10,\n        offset: int = 0\n    ) -&gt; StrategySearchResult:\n        \"\"\"\n        Execute search and return results with scores.\n\n        Returns:\n            StrategySearchResult with products, scores, metadata\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def validate_compatibility(\n        self,\n        product_gin: str,\n        selected_components: Dict[str, Any]\n    ) -&gt; bool:\n        \"\"\"\n        Validate if product is compatible with selected components.\n\n        Returns:\n            True if compatible, False otherwise\n        \"\"\"\n        pass\n\n    def get_name(self) -&gt; str:\n        \"\"\"Return strategy identifier (e.g., 'cypher', 'lucene')\"\"\"\n        return self.__class__.__name__.replace(\"SearchStrategy\", \"\").lower()\n</code></pre> <p>StrategySearchResult Model:</p> <pre><code>class StrategySearchResult(BaseModel):\n    \"\"\"\n    Standardized search result from a strategy.\n\n    Attributes:\n        products: List of product dictionaries with GIN, name, category, etc.\n        scores: Optional dict mapping GIN to relevance score (0.0-1.0)\n        metadata: Additional search metadata (method, timing, etc.)\n        strategy_name: Name of strategy that produced results\n    \"\"\"\n    products: List[Dict[str, Any]] = Field(default_factory=list)\n    scores: Optional[Dict[str, float]] = None  # GIN -&gt; score mapping\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    strategy_name: str\n\n    class Config:\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#cyphersearchstrategy","title":"CypherSearchStrategy","text":"<p>File: <code>src/backend/app/services/search/strategies/cypher_strategy.py</code> (224 lines)</p> <p>Graph-based compatibility search using Neo4j COMPATIBLE_WITH relationships.</p> <p>Core Algorithm: Priority-to-Score Conversion</p> <pre><code>class CypherSearchStrategy(SearchStrategy):\n    \"\"\"\n    Neo4j Cypher-based search strategy.\n\n    Features:\n    - Uses COMPATIBLE_WITH relationships for filtering\n    - Converts relationship priority to confidence scores\n    - Fast compatibility validation\n    - Deterministic ranking based on graph priorities\n\n    Scoring: Normalized Linear (priority \u2192 score)\n    Formula: score = max(min_score, 1.0 - (priority - 1) / (max_priority - 1))\n    \"\"\"\n\n    def __init__(self, config: Dict[str, Any], product_search):\n        super().__init__(config)\n        self.product_search = product_search\n\n        # Priority-to-score configuration\n        self.max_priority = config.get(\"max_priority\", 20)\n        self.min_score = config.get(\"min_score\", 0.1)\n        self.default_priority = config.get(\"default_priority\", 1)\n\n        logger.info(\n            f\"\u2705 CypherSearchStrategy initialized | \"\n            f\"max_priority={self.max_priority} | min_score={self.min_score}\"\n        )\n</code></pre> <p>Search Implementation:</p> <pre><code>async def search(\n    self,\n    component_type: str,\n    user_message: str,\n    master_parameters: Dict[str, Any],\n    selected_components: Dict[str, Any],\n    limit: int = 10,\n    offset: int = 0\n) -&gt; StrategySearchResult:\n    \"\"\"\n    Execute Cypher-based graph search.\n\n    Flow:\n    1. Delegate to ComponentSearchService\n    2. Convert relationship priorities to scores\n    3. Return standardized results\n    \"\"\"\n    logger.info(\n        f\"\ud83d\udd0d CypherSearchStrategy.search() | Component: {component_type}\"\n    )\n\n    # Convert component_type to component_key (PowerSource \u2192 power_source)\n    component_key = self._to_component_key(component_type)\n\n    # Step 1: Delegate to ComponentSearchService\n    search_results = await self.product_search.component_service.search(\n        component_type=component_key,\n        master_parameters=master_parameters,\n        selected_components=selected_components,\n        limit=limit,\n        offset=offset\n    )\n\n    # Step 2: Convert priority to confidence score\n    products = []\n    scores = {}\n\n    for product in search_results.products:\n        # Convert priority to normalized score (0.1 - 1.0)\n        score = self._priority_to_score(product.priority)\n        scores[product.gin] = score\n\n        products.append({\n            \"gin\": product.gin,\n            \"name\": product.name,\n            \"category\": product.category,\n            \"description\": product.description,\n            \"specifications\": product.specifications or {}\n        })\n\n    logger.info(\n        f\"\u2705 CypherSearchStrategy complete | Products: {len(products)} | \"\n        f\"Score range: {min(scores.values()):.2f}-{max(scores.values()):.2f}\"\n    )\n\n    return StrategySearchResult(\n        products=products,\n        scores=scores,\n        metadata={\n            \"search_method\": \"cypher\",\n            \"total_results\": len(products),\n            \"scoring\": {\n                \"method\": \"priority_normalized_linear\",\n                \"max_priority\": self.max_priority,\n                \"min_score\": self.min_score\n            }\n        },\n        strategy_name=\"cypher\"\n    )\n</code></pre> <p>Priority-to-Score Conversion Algorithm:</p> <pre><code>def _priority_to_score(self, priority: Optional[int]) -&gt; float:\n    \"\"\"\n    Convert Neo4j relationship priority to normalized confidence score.\n\n    Algorithm: Normalized Linear Scoring\n\n    Formula:\n        score = max(min_score, 1.0 - (priority - 1) / (max_priority - 1))\n\n    Configuration:\n        max_priority = 20 (default)\n        min_score = 0.1 (default)\n        default_priority = 1 (for PowerSource without relationships)\n\n    Score Mapping Examples:\n        priority=1  \u2192 score=1.00 (perfect match, highest priority)\n        priority=2  \u2192 score=0.95 (excellent match)\n        priority=5  \u2192 score=0.79 (very good match)\n        priority=10 \u2192 score=0.53 (moderate match)\n        priority=15 \u2192 score=0.26 (low match)\n        priority=20 \u2192 score=0.10 (minimum match)\n        priority&gt;20 \u2192 score=0.10 (capped at minimum)\n        priority=None \u2192 score=1.00 (PowerSource, no relationships)\n\n    Rationale:\n        - Lower priority = Better match (Neo4j convention)\n        - Linear normalization maintains relative ordering\n        - Min score prevents zero scores (ensures all results rankable)\n        - Capping prevents negative scores for outliers\n\n    Args:\n        priority: Priority from COMPATIBLE_WITH relationship (lower = better)\n\n    Returns:\n        Confidence score between min_score (0.1) and 1.0\n    \"\"\"\n    if priority is None:\n        # PowerSource has no priority (first component in workflow)\n        priority = self.default_priority  # 1\n\n    # Cap priority at max to prevent negative scores\n    if priority &gt; self.max_priority:\n        logger.warning(\n            f\"\u26a0\ufe0f Priority {priority} exceeds max {self.max_priority}, \"\n            f\"capping to min_score {self.min_score}\"\n        )\n        return self.min_score\n\n    # Normalized Linear Scoring\n    # score = 1.0 - (priority - 1) / (max_priority - 1)\n    #\n    # Example calculation for priority=10, max_priority=20:\n    # score = 1.0 - (10 - 1) / (20 - 1)\n    #       = 1.0 - 9 / 19\n    #       = 1.0 - 0.474\n    #       = 0.526\n    normalized_score = 1.0 - (priority - 1) / (self.max_priority - 1)\n\n    # Ensure score doesn't go below min_score\n    final_score = max(self.min_score, normalized_score)\n\n    return final_score\n</code></pre> <p>Compatibility Validation:</p> <pre><code>async def validate_compatibility(\n    self,\n    product_gin: str,\n    selected_components: Dict[str, Any]\n) -&gt; bool:\n    \"\"\"\n    Validate product compatibility using graph relationships.\n\n    Checks:\n    - Product exists in Neo4j\n    - COMPATIBLE_WITH relationships exist to all selected components\n\n    Returns:\n        True if compatible, False otherwise\n    \"\"\"\n    try:\n        # Use Neo4j compatibility check query\n        query = \"\"\"\n        MATCH (product:Product {gin: $product_gin})\n        MATCH (selected:Product)\n        WHERE selected.gin IN $selected_gins\n        MATCH (product)-[:COMPATIBLE_WITH]-&gt;(selected)\n        WITH product, count(DISTINCT selected) as compatible_count\n        WHERE compatible_count = $required_count\n        RETURN product.gin as gin\n        \"\"\"\n\n        selected_gins = [\n            comp.get(\"gin\") for comp in selected_components.values()\n            if comp and comp.get(\"gin\")\n        ]\n\n        if not selected_gins:\n            return True  # No compatibility requirements\n\n        result = await self.product_search.neo4j_driver.execute_query(\n            query,\n            product_gin=product_gin,\n            selected_gins=selected_gins,\n            required_count=len(selected_gins)\n        )\n\n        return len(result.records) &gt; 0\n\n    except Exception as e:\n        logger.error(f\"\u274c Compatibility validation failed: {e}\")\n        return False\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#lucenesearchstrategy","title":"LuceneSearchStrategy","text":"<p>File: <code>src/backend/app/services/search/strategies/lucene_strategy.py</code> (277 lines)</p> <p>Full-text search with relevance scoring using Neo4j Lucene indexes.</p> <pre><code>class LuceneSearchStrategy(SearchStrategy):\n    \"\"\"\n    Lucene full-text search strategy.\n\n    Features:\n    - Uses Neo4j full-text indexes (productIndex)\n    - Relevance-based ranking\n    - Text normalization (units, measurements)\n    - Stop word removal\n    - UNION queries for better recall\n\n    Scoring: Lucene Relevance (0.0-1.0)\n    - Native Neo4j Lucene scores\n    - Extracted from product specifications or name\n    \"\"\"\n\n    def __init__(self, config: Dict[str, Any], product_search):\n        super().__init__(config)\n        self.product_search = product_search\n        self.min_score = config.get(\"min_score\", 0.0)\n\n        logger.info(\n            f\"\u2705 LuceneSearchStrategy initialized | min_score={self.min_score}\"\n        )\n</code></pre> <p>Search Implementation:</p> <pre><code>async def search(\n    self,\n    component_type: str,\n    user_message: str,\n    master_parameters: Dict[str, Any],\n    selected_components: Dict[str, Any],\n    limit: int = 10,\n    offset: int = 0\n) -&gt; StrategySearchResult:\n    \"\"\"\n    Execute Lucene full-text search.\n\n    Flow:\n    1. Validate user_message is present\n    2. Delegate to ComponentSearchService.search_with_lucene()\n    3. Extract Lucene scores from products\n    4. Return standardized results\n\n    Note: Requires user_message for text matching\n    \"\"\"\n    if not user_message or not user_message.strip():\n        logger.warning(\"\u26a0\ufe0f LuceneSearchStrategy requires user_message\")\n        return StrategySearchResult(\n            products=[],\n            scores={},\n            metadata={\"error\": \"No user message provided\"},\n            strategy_name=\"lucene\"\n        )\n\n    logger.info(\n        f\"\ud83d\udd0d LuceneSearchStrategy.search() | Component: {component_type} | \"\n        f\"Message: '{user_message[:50]}...'\"\n    )\n\n    # Convert component_type to component_key\n    component_key = self._to_component_key(component_type)\n\n    # Step 1: Delegate to ComponentSearchService\n    search_results = await self.product_search.component_service.search_with_lucene(\n        component_type=component_key,\n        user_message=user_message,\n        selected_components=selected_components,\n        limit=limit,\n        offset=offset\n    )\n\n    # Step 2: Extract Lucene scores from products\n    products = []\n    scores = {}\n\n    for product in search_results.products:\n        # Try to extract Lucene score from product\n        score = self._extract_lucene_score(product)\n\n        products.append({\n            \"gin\": product.gin,\n            \"name\": product.name,\n            \"category\": product.category,\n            \"description\": product.description,\n            \"specifications\": product.specifications or {}\n        })\n\n        if score is not None:\n            scores[product.gin] = score\n\n    # If no scores extracted, use default scoring\n    if not scores and products:\n        logger.warning(\n            \"\u26a0\ufe0f No Lucene scores extracted, using default score 1.0\"\n        )\n        scores = {p[\"gin\"]: 1.0 for p in products}\n\n    logger.info(\n        f\"\u2705 LuceneSearchStrategy complete | Products: {len(products)} | \"\n        f\"Scores: {len(scores)}\"\n    )\n\n    return StrategySearchResult(\n        products=products,\n        scores=scores if scores else None,\n        metadata={\n            \"search_method\": \"lucene\",\n            \"total_results\": len(products),\n            \"user_message\": user_message[:100]\n        },\n        strategy_name=\"lucene\"\n    )\n</code></pre> <p>Lucene Score Extraction:</p> <pre><code>def _extract_lucene_score(self, product) -&gt; Optional[float]:\n    \"\"\"\n    Extract Lucene relevance score from product.\n\n    Score Location Options:\n    1. In specifications dict: {\"lucene_score\": 0.85}\n    2. Appended to name: \"Product Name (Score: 11.5)\"\n\n    Score Range: 0.0 - unbounded (typically 0.1 - 20.0)\n\n    Args:\n        product: ProductResult object\n\n    Returns:\n        Lucene score or None if not found\n    \"\"\"\n    try:\n        # Option 1: Check specifications dict\n        if hasattr(product, \"specifications\") and product.specifications:\n            if \"lucene_score\" in product.specifications:\n                score = float(product.specifications[\"lucene_score\"])\n                logger.debug(\n                    f\"\ud83d\udcca Extracted Lucene score from specifications | \"\n                    f\"GIN: {product.gin} | Score: {score:.4f}\"\n                )\n                return score\n\n        # Option 2: Check name for appended score\n        if hasattr(product, \"name\") and product.name:\n            import re\n            # Match pattern: \"Product Name (Score: 11.5)\"\n            match = re.search(r'\\(Score: (\\d+\\.\\d+)\\)', product.name)\n            if match:\n                score = float(match.group(1))\n                logger.debug(\n                    f\"\ud83d\udcca Extracted Lucene score from name | \"\n                    f\"GIN: {product.gin} | Score: {score:.4f}\"\n                )\n                return score\n\n        # No score found\n        logger.debug(f\"\u26a0\ufe0f No Lucene score found for GIN: {product.gin}\")\n        return None\n\n    except Exception as e:\n        logger.warning(\n            f\"\u26a0\ufe0f Could not extract Lucene score for GIN: {product.gin} | \"\n            f\"Error: {e}\"\n        )\n        return None\n</code></pre> <p>Compatibility Validation:</p> <pre><code>async def validate_compatibility(\n    self,\n    product_gin: str,\n    selected_components: Dict[str, Any]\n) -&gt; bool:\n    \"\"\"\n    Validate product compatibility.\n\n    Note: Lucene search delegates to Cypher for compatibility filtering,\n          so this method uses the same graph validation logic.\n    \"\"\"\n    # Delegate to Cypher compatibility check\n    return await self.product_search.component_service.validate_compatibility(\n        product_gin=product_gin,\n        selected_components=selected_components\n    )\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#vectorsearchstrategy-semantic-similarity-search","title":"VectorSearchStrategy - Semantic Similarity Search","text":"<p>File: <code>src/backend/app/services/search/strategies/vector_strategy.py</code> (283 lines)</p> <p>Semantic similarity search using OpenAI embeddings and Neo4j vector index. Enables intent-based product matching even when exact keywords don't match.</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#overview","title":"Overview","text":"<p>Purpose: Find products semantically similar to user's natural language query using high-dimensional vector representations.</p> <p>Technology Stack: - OpenAI text-embedding-3-large: 3072-dimensional embeddings - Neo4j Vector Index: <code>embeddingIndex</code> for similarity search - Cosine Similarity: Distance metric for ranking results</p> <p>Configuration: <pre><code>{\n    \"enabled\": true,\n    \"weight\": 0.6,                              # Consolidation weight\n    \"min_score\": 0.6,                           # Minimum similarity threshold\n    \"embedding_model\": \"text-embedding-3-large\", # OpenAI model\n    \"embedding_dims\": 3072                       # Embedding dimensions\n}\n</code></pre></p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#implementation","title":"Implementation","text":"<p>Class Structure:</p> <pre><code>class VectorSearchStrategy(SearchStrategy):\n    \"\"\"\n    Vector-based search strategy using OpenAI embeddings and Neo4j vector index.\n\n    Uses semantic similarity to find products that match the user's intent,\n    even if exact keywords don't match.\n\n    Architecture:\n    1. Generate embedding for user query using OpenAI text-embedding-3-large (3072 dims)\n    2. Search Neo4j vector index for semantically similar products\n    3. Return ranked results by similarity score\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Dict[str, Any],\n        neo4j_product_search,\n        openai_client: Optional[AsyncOpenAI] = None\n    ):\n        super().__init__(config)\n\n        self.neo4j_search = neo4j_product_search\n        self.min_score = config.get(\"min_score\", 0.6)\n        self.embedding_model = config.get(\"embedding_model\", \"text-embedding-3-large\")\n        self.embedding_dims = config.get(\"embedding_dims\", 3072)\n\n        # Initialize OpenAI client\n        if openai_client:\n            self.openai_client = openai_client\n        else:\n            from openai import AsyncOpenAI\n            import os\n            self.openai_client = AsyncOpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#search-flow","title":"Search Flow","text":"<p>Step 1: Generate Embedding</p> <pre><code>async def search(\n    self,\n    component_type: str,\n    user_message: str,\n    master_parameters: Dict[str, Any],\n    selected_components: Dict[str, Any],\n    limit: int = 10,\n    offset: int = 0\n) -&gt; StrategySearchResult:\n    \"\"\"\n    Execute vector search using OpenAI embeddings and Neo4j vector index.\n\n    Args:\n        component_type: Component to search for\n        user_message: User's natural language query\n        master_parameters: Extracted parameters (not used in vector search)\n        selected_components: Previously selected components\n        limit: Number of results to return\n        offset: Pagination offset\n\n    Returns:\n        StrategySearchResult with similarity-ranked products\n    \"\"\"\n    logger.info(f\"Vector search for {component_type}: '{user_message}'\")\n\n    # Step 1: Generate embedding for user query\n    logger.debug(f\"Generating embedding using {self.embedding_model} ({self.embedding_dims} dims)\")\n    try:\n        response = await self.openai_client.embeddings.create(\n            model=self.embedding_model,\n            input=user_message,\n            dimensions=self.embedding_dims\n        )\n        embedding = response.data[0].embedding\n        logger.debug(f\"Generated embedding vector of length {len(embedding)}\")\n    except Exception as e:\n        logger.error(f\"Failed to generate embedding: {e}\")\n        return StrategySearchResult(\n            products=[],\n            scores={},\n            metadata={\"strategy\": \"vector\", \"error\": str(e)},\n            strategy_name=\"vector\"\n        )\n</code></pre> <p>Step 2: Search Neo4j Vector Index</p> <pre><code>    # Step 2: Search Neo4j vector index\n    neo4j_category = self._map_component_to_neo4j_category(component_type)\n    logger.debug(f\"Searching vector index for category: {neo4j_category}\")\n\n    try:\n        # Get driver from centralized manager (supports auto-reconnection)\n        driver = await neo4j_manager.get_driver()\n        async with driver.session() as session:\n            result = await session.run(\"\"\"\n                CALL db.index.vector.queryNodes('embeddingIndex', $limit, $vector)\n                YIELD node, score\n                MATCH (p:Product)-[:HAS_EMBEDDING]-&gt;(node)\n                WHERE p.category = $category AND score &gt;= $min_score\n                RETURN\n                    p.gin as gin,\n                    p.item_name as name,\n                    p.category as category,\n                    p.description_catalogue as description,\n                    p as specifications,\n                    score\n                ORDER BY score DESC\n            \"\"\", vector=embedding, limit=limit + offset,\n                 category=neo4j_category, min_score=self.min_score)\n\n            records = await result.data()\n\n    except Exception as e:\n        logger.error(f\"Neo4j vector search failed: {e}\")\n        return StrategySearchResult(\n            products=[],\n            scores={},\n            metadata={\"strategy\": \"vector\", \"error\": str(e)},\n            strategy_name=\"vector\"\n        )\n</code></pre> <p>Step 3: Process Results</p> <pre><code>    # Step 3: Convert results to product dictionaries\n    products = []\n    scores_dict = {}\n\n    for i, record in enumerate(records[offset:offset + limit], 1):\n        # Extract full product node for specifications (includes attribute_ruleset)\n        specs = record.get(\"specifications\", {})\n\n        # Clean Neo4j types (convert Neo4j types to Python types)\n        if hasattr(specs, \"__dict__\"):\n            specs = dict(specs)\n\n        if specs:\n            specs = self._clean_neo4j_types(specs)\n\n        # Add vector similarity score to specifications\n        if not specs:\n            specs = {}\n        specs[\"vector_similarity\"] = record[\"score\"]\n\n        product = {\n            \"gin\": record[\"gin\"],\n            \"name\": record[\"name\"],\n            \"category\": record[\"category\"],\n            \"description\": record.get(\"description\", \"\"),\n            \"specifications\": specs\n        }\n        products.append(product)\n        scores_dict[record[\"gin\"]] = record[\"score\"]\n\n    logger.info(f\"Vector search returned {len(products)} products (similarity &gt;= {self.min_score})\")\n\n    return StrategySearchResult(\n        products=products,\n        scores=scores_dict,\n        metadata={\n            \"strategy\": \"vector\",\n            \"embedding_model\": self.embedding_model,\n            \"embedding_dims\": self.embedding_dims,\n            \"min_score\": self.min_score,\n            \"total_found\": len(records)\n        },\n        strategy_name=\"vector\"\n    )\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#scoring-mechanism","title":"Scoring Mechanism","text":"<p>Similarity Score Range: 0.0 to 1.0 (cosine similarity)</p> <p>Threshold: Minimum 0.6 similarity (configurable via <code>min_score</code>)</p> <p>Score Interpretation: - 0.9 - 1.0: Near-perfect semantic match (extremely relevant) - 0.8 - 0.9: High semantic similarity (very relevant) - 0.7 - 0.8: Good semantic match (relevant) - 0.6 - 0.7: Moderate semantic similarity (potentially relevant) - &lt; 0.6: Low similarity (filtered out)</p> <p>Example Scores: <pre><code>{\n    \"0446200880\": 0.87,  # Aristo 500ix (high similarity)\n    \"0460520880\": 0.76,  # RobustFeed U6 (good similarity)\n    \"0369203880\": 0.65   # Cool 50 (moderate similarity)\n}\n</code></pre></p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#neo4j-type-cleaning","title":"Neo4j Type Cleaning","text":"<p>Purpose: Convert Neo4j-specific types to JSON-serializable Python types.</p> <pre><code>def _clean_neo4j_types(self, obj: Any) -&gt; Any:\n    \"\"\"\n    Convert Neo4j-specific types to JSON-serializable types.\n\n    Args:\n        obj: Object to clean (can be dict, list, or primitive)\n\n    Returns:\n        Cleaned object with Neo4j types converted to standard Python types\n    \"\"\"\n    from neo4j.time import DateTime, Date, Time\n\n    if isinstance(obj, (DateTime, Date, Time)):\n        return obj.isoformat()\n    elif isinstance(obj, dict):\n        return {k: self._clean_neo4j_types(v) for k, v in obj.items()}\n    elif isinstance(obj, list):\n        return [self._clean_neo4j_types(item) for item in obj]\n    else:\n        return obj\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#component-mapping","title":"Component Mapping","text":"<p>Map Configurator Components to Neo4j Categories:</p> <pre><code>def _map_component_to_neo4j_category(self, component_type: str) -&gt; str:\n    \"\"\"\n    Map component type to Neo4j Product category label.\n\n    Args:\n        component_type: Component type from configurator\n\n    Returns:\n        Neo4j category string\n    \"\"\"\n    mapping = {\n        \"power_source\": \"Powersource\",\n        \"feeder\": \"Feeder\",\n        \"cooler\": \"Cooler\",\n        \"interconnector\": \"Interconnector\",\n        \"torch\": \"Torch\",\n        \"accessory\": \"Accessory\"\n    }\n    return mapping.get(component_type.lower(), \"Powersource\")\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#compatibility-validation","title":"Compatibility Validation","text":"<p>Delegates to Neo4j Product Search:</p> <pre><code>async def validate_compatibility(\n    self,\n    product_gin: str,\n    selected_components: Dict[str, Any],\n    component_type: str\n) -&gt; bool:\n    \"\"\"\n    Validate product compatibility using Neo4j graph relationships.\n\n    Delegates to the Neo4j product search service for compatibility validation.\n\n    Args:\n        product_gin: Product GIN to validate\n        selected_components: Already selected components\n        component_type: Type of component\n\n    Returns:\n        True if compatible\n    \"\"\"\n    # Delegate to Neo4j search for compatibility validation\n    # (Vector search doesn't have compatibility logic itself)\n    return await self.neo4j_search.validate_compatibility(\n        product_gin=product_gin,\n        selected_components=selected_components,\n        component_type=component_type\n    )\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#use-cases","title":"Use Cases","text":"<p>When Vector Search Excels:</p> <ol> <li>Fuzzy Product Names: \"aristo five hundred\" \u2192 Aristo 500ix</li> <li>Synonyms: \"wire feeder\" \u2192 \"feeder unit\", \"cooling unit\" \u2192 \"cooler\"</li> <li>Paraphrasing: \"500 amp MIG welder\" \u2192 \"500A GMAW power source\"</li> <li>Intent Matching: \"need to weld aluminum\" \u2192 aluminum-capable welders</li> <li>Cross-Language: \"schwei\u00dfger\u00e4t\" (German for welder) \u2192 welding equipment</li> </ol> <p>Example Query: <pre><code>User: \"I need a high-current welder for heavy industrial work\"\n\nVector Search Finds:\n- Aristo 500ix (0.89 similarity) - \"500A industrial MIG/TIG welder\"\n- Warrior 500i (0.87 similarity) - \"500A heavy-duty multi-process\"\n- Aristo 400ix (0.74 similarity) - \"400A industrial welder\"\n</code></pre></p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#performance-characteristics","title":"Performance Characteristics","text":"<p>Embedding Generation: - API call latency: ~200-500ms - Token cost: ~1/8000 of cost per input token - Embedding size: 3072 floats (12KB)</p> <p>Vector Index Search: - Query time: ~50-150ms (depends on index size) - Scales well with product count (logarithmic) - Memory efficient (approximate nearest neighbor)</p> <p>Total Latency: ~250-650ms per search</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#llmsearchstrategy-retrieve-then-rerank","title":"LLMSearchStrategy - Retrieve-Then-Rerank","text":"<p>File: <code>src/backend/app/services/search/strategies/llm_strategy.py</code> (444 lines)</p> <p>Intelligent product matching using retrieve-then-rerank pattern with GPT-4o-mini for evaluation and ranking.</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#overview_1","title":"Overview","text":"<p>Purpose: Use LLM to intelligently evaluate and rank products against user intent, including competitor equivalents matching.</p> <p>Architecture Pattern: Retrieve-Then-Rerank</p> <ol> <li>Retrieve: Get candidate products using Lucene, Vector, or both</li> <li>Deduplicate: Remove duplicate products by GIN (for combined mode)</li> <li>Rerank: LLM evaluates each candidate against user query</li> <li>Score: Return top products with LLM relevance scores (0-100)</li> </ol> <p>Technology Stack: - OpenAI GPT-4o-mini: Fast, cost-effective LLM for ranking - Temperature: 0.1 (low for consistent ranking) - Response Format: JSON (structured output)</p> <p>Configuration: <pre><code>{\n    \"enabled\": true,\n    \"weight\": 0.3,                          # Consolidation weight\n    \"retrieval_limit\": 10,                  # Candidates per retrieval method\n    \"retrieval_method\": \"combined\",         # \"lucene\", \"vector\", or \"combined\"\n    \"model\": \"gpt-4o-mini\",                 # OpenAI model\n    \"temperature\": 0.1,                     # Low for consistency\n    \"top_n\": 5                              # Return top 5 products\n}\n</code></pre></p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#implementation_1","title":"Implementation","text":"<p>Class Structure:</p> <pre><code>class LLMSearchStrategy(SearchStrategy):\n    \"\"\"\n    LLM-based search strategy that re-ranks results from multiple retrieval methods.\n\n    Architecture:\n    1. Retrieve: Use Lucene, Vector, or both for initial candidates\n    2. Deduplicate: Remove duplicate products by GIN (for combined mode)\n    3. Rerank: LLM evaluates each product against user intent\n    4. Score: Returns top products with LLM relevance scores (0-100)\n\n    Config:\n        retrieval_limit: Number of candidates per method (default: 10)\n        retrieval_method: \"lucene\", \"vector\", or \"combined\" (default: \"combined\")\n        model: OpenAI model to use (default: \"gpt-4o-mini\")\n        weight: Strategy weight for consolidation (default: 0.3)\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Dict[str, Any],\n        neo4j_product_search,\n        openai_client: Optional[AsyncOpenAI] = None\n    ):\n        super().__init__(config)\n\n        self.neo4j_search = neo4j_product_search\n        self.openai_client = openai_client or AsyncOpenAI(\n            api_key=os.getenv(\"OPENAI_API_KEY\")\n        )\n\n        # Configuration\n        self.retrieval_limit = config.get(\"retrieval_limit\", 10)\n        self.retrieval_method = config.get(\"retrieval_method\", \"combined\")\n        self.model = config.get(\"model\", \"gpt-4o-mini\")\n        self.temperature = config.get(\"temperature\", 0.1)\n        self.top_n = config.get(\"top_n\", 5)\n\n        # Initialize retrieval strategies\n        self.lucene_strategy = LuceneSearchStrategy(\n            config={\"enabled\": True, \"weight\": 0.4},\n            neo4j_product_search=neo4j_product_search\n        )\n        self.vector_strategy = VectorSearchStrategy(\n            config={\"enabled\": True, \"weight\": 0.6, \"min_score\": 0.6},\n            neo4j_product_search=neo4j_product_search,\n            openai_client=openai_client\n        )\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#retrieval-methods","title":"Retrieval Methods","text":"<p>Three Retrieval Strategies:</p> <pre><code>async def search(\n    self,\n    component_type: str,\n    user_message: str,\n    master_parameters: Dict[str, Any],\n    selected_components: Dict[str, Any],\n    limit: int = 10,\n    offset: int = 0\n) -&gt; StrategySearchResult:\n    \"\"\"\n    Execute LLM-based search using retrieve-then-rerank pattern.\n\n    Retrieval Methods:\n    - lucene: Full-text search only\n    - vector: Semantic search only\n    - combined: Both methods with deduplication (default)\n    \"\"\"\n    logger.info(f\"LLM search for {component_type} using {self.retrieval_method} retrieval\")\n\n    all_candidates = []\n\n    if self.retrieval_method == \"lucene\":\n        # Lucene-only retrieval\n        lucene_result = await self.lucene_strategy.search(\n            component_type=component_type,\n            user_message=user_message,\n            master_parameters=master_parameters,\n            selected_components=selected_components,\n            limit=self.retrieval_limit,\n            offset=0\n        )\n        all_candidates = lucene_result.products\n        logger.info(f\"Retrieved {len(all_candidates)} candidates from Lucene\")\n\n    elif self.retrieval_method == \"vector\":\n        # Vector-only retrieval\n        vector_result = await self.vector_strategy.search(\n            component_type=component_type,\n            user_message=user_message,\n            master_parameters=master_parameters,\n            selected_components=selected_components,\n            limit=self.retrieval_limit,\n            offset=0\n        )\n        all_candidates = vector_result.products\n        logger.info(f\"Retrieved {len(all_candidates)} candidates from Vector\")\n\n    elif self.retrieval_method == \"combined\":\n        # Combined retrieval with deduplication\n        logger.info(f\"Running combined retrieval (Lucene + Vector)\")\n\n        # Parallel retrieval\n        lucene_result, vector_result = await asyncio.gather(\n            self.lucene_strategy.search(\n                component_type=component_type,\n                user_message=user_message,\n                master_parameters=master_parameters,\n                selected_components=selected_components,\n                limit=self.retrieval_limit,\n                offset=0\n            ),\n            self.vector_strategy.search(\n                component_type=component_type,\n                user_message=user_message,\n                master_parameters=master_parameters,\n                selected_components=selected_components,\n                limit=self.retrieval_limit,\n                offset=0\n            )\n        )\n\n        # Deduplicate by GIN\n        seen_gins = set()\n        for product in lucene_result.products + vector_result.products:\n            gin = product.get(\"gin\")\n            if gin and gin not in seen_gins:\n                all_candidates.append(product)\n                seen_gins.add(gin)\n\n        logger.info(\n            f\"Combined retrieval: {len(lucene_result.products)} from Lucene, \"\n            f\"{len(vector_result.products)} from Vector, \"\n            f\"{len(all_candidates)} unique candidates after deduplication\"\n        )\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#llm-re-ranking","title":"LLM Re-ranking","text":"<p>Prompt Building:</p> <pre><code>def _build_reranking_prompt(\n    self,\n    user_message: str,\n    component_type: str,\n    candidates: List[Dict[str, Any]]\n) -&gt; str:\n    \"\"\"\n    Build LLM prompt for re-ranking candidates.\n\n    Includes full product information:\n    - GIN (unique identifier)\n    - Product name\n    - Technical attributes (attribute_ruleset)\n    - Competitor equivalents (competitor_brand_product_pairs) - CRITICAL\n    - Description\n    \"\"\"\n    products_text = []\n    for i, product in enumerate(candidates, 1):\n        specs = product.get('specifications', {})\n\n        # Extract key information\n        competitor_pairs = specs.get('competitor_brand_product_pairs', [])\n        attributes = specs.get('attribute_ruleset', '')\n        description = product.get('description', '')\n\n        product_info = [\n            f\"{i}. GIN: {product.get('gin')}\",\n            f\"   Name: {product.get('name')}\",\n            f\"   Technical Attributes: {attributes}\",\n            f\"   Competitor Equivalents: {competitor_pairs}\",  # Key for matching\n            f\"   Description: {description}\"\n        ]\n        products_text.append('\\n'.join(product_info))\n\n    prompt = f\"\"\"User is looking for: {user_message}\n\nComponent Type: {component_type}\n\nAvailable Products:\n{chr(10).join(products_text)}\n\nEvaluate each product and provide:\n1. Relevance score (0-100)\n2. Brief reasoning (1-2 sentences)\n\nReturn JSON format:\n{{\n    \"products\": [\n        {{\"gin\": \"...\", \"score\": 90, \"reasoning\": \"...\"}},\n        ...\n    ]\n}}\"\"\"\n\n    return prompt\n</code></pre> <p>LLM Evaluation with Competitor Matching:</p> <pre><code>async def _rerank_with_llm(\n    self,\n    user_message: str,\n    component_type: str,\n    candidates: List[Dict[str, Any]],\n    limit: int\n) -&gt; Tuple[List[Dict[str, Any]], Dict[str, float]]:\n    \"\"\"\n    Use LLM to evaluate and rank candidates.\n\n    Scoring Guidelines:\n    - 90-100: Perfect match (exact competitor equivalent OR perfect spec match)\n    - 70-89: Good match with minor gaps\n    - 50-69: Partial match\n    - 30-49: Weak match\n    - 0-29: Poor match\n\n    IMPORTANT: Products with matching competitor equivalents should score 90-100.\n    \"\"\"\n    prompt = self._build_reranking_prompt(user_message, component_type, candidates)\n\n    try:\n        response = await self.openai_client.chat.completions.create(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"system\",\n                    \"content\": \"\"\"You are an expert welding equipment specialist.\n\nFor each product, provide:\n1. A relevance score (0-100) where:\n   - 90-100: Perfect match (exact competitor equivalent OR perfect spec match)\n   - 70-89: Good match with minor gaps\n   - 50-69: Partial match\n   - 30-49: Weak match\n   - 0-29: Poor match\n\n2. Brief reasoning (1-2 sentences)\n\nIMPORTANT: When user asks for \"equivalent of [Brand:Model]\":\n- Prioritize products with that Brand:Model in \"Competitor Equivalents\" field\n- Products with matching competitor equivalents should score 90-100\n- This is the PRIMARY matching criterion\n\nReturn valid JSON with this structure:\n{\n    \"products\": [\n        {\"gin\": \"...\", \"score\": 90, \"reasoning\": \"...\"},\n        ...\n    ]\n}\"\"\"\n                },\n                {\"role\": \"user\", \"content\": prompt}\n            ],\n            temperature=self.temperature,  # 0.1 for consistency\n            response_format={\"type\": \"json_object\"}  # Enforce JSON response\n        )\n\n        # Parse JSON response\n        result = json.loads(response.choices[0].message.content)\n        evaluations = result.get(\"products\", [])\n\n        # Create GIN \u2192 score mapping\n        scores_dict = {\n            eval_item[\"gin\"]: float(eval_item[\"score\"]) / 100.0  # Normalize 0-100 to 0-1\n            for eval_item in evaluations\n        }\n\n        # Sort candidates by LLM score\n        ranked_candidates = []\n        for candidate in candidates:\n            gin = candidate.get(\"gin\")\n            if gin in scores_dict:\n                score = scores_dict[gin]\n\n                # Find reasoning from evaluations\n                reasoning = next(\n                    (e.get(\"reasoning\", \"\") for e in evaluations if e[\"gin\"] == gin),\n                    \"\"\n                )\n\n                # Add LLM metadata to specifications\n                if \"specifications\" not in candidate:\n                    candidate[\"specifications\"] = {}\n                candidate[\"specifications\"][\"llm_score\"] = score * 100  # Original 0-100\n                candidate[\"specifications\"][\"llm_reasoning\"] = reasoning\n\n                ranked_candidates.append((candidate, score))\n\n        # Sort by score descending\n        ranked_candidates.sort(key=lambda x: x[1], reverse=True)\n\n        # Return top N products\n        top_products = [p for p, _ in ranked_candidates[:limit]]\n\n        logger.info(f\"LLM re-ranking complete: {len(top_products)} products ranked\")\n\n        return top_products, scores_dict\n\n    except Exception as e:\n        logger.error(f\"LLM re-ranking failed: {e}\")\n        # Fallback: return candidates as-is\n        return candidates[:limit], {}\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#scoring-mechanism_1","title":"Scoring Mechanism","text":"<p>LLM Score Range: 0 to 100 (normalized to 0.0-1.0 for consolidation)</p> <p>Score Interpretation: - 90-100: Perfect match (competitor equivalent or perfect specs) - 70-89: Good match with minor gaps - 50-69: Partial match (some requirements met) - 30-49: Weak match (minimal alignment) - 0-29: Poor match (little relevance)</p> <p>Competitor Equivalents Matching:</p> <p>When user asks: \"I need an equivalent of Miller Dynasty 280\"</p> <p>LLM prioritizes products with <code>competitor_brand_product_pairs</code> containing <code>\"Miller:Dynasty 280\"</code>:</p> <pre><code>Product 1 (GIN: 0446200880):\n  Name: Aristo 500ix\n  Competitor Equivalents: [\"Miller:Dynasty 280\", \"Lincoln:Invertec 400\"]\n  LLM Score: 95 (exact competitor equivalent match)\n  LLM Reasoning: \"Perfect equivalent - listed as direct competitor to Miller Dynasty 280\"\n\nProduct 2 (GIN: 0460520880):\n  Name: Warrior 500i\n  Competitor Equivalents: [\"Miller:Dynasty 350\"]\n  LLM Score: 78 (similar model but not exact)\n  LLM Reasoning: \"Good alternative - similar specs to Dynasty series but not exact equivalent\"\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#compatibility-validation_1","title":"Compatibility Validation","text":"<p>Delegates to Retrieval Strategies:</p> <pre><code>async def validate_compatibility(\n    self,\n    product_gin: str,\n    selected_components: Dict[str, Any],\n    component_type: str\n) -&gt; bool:\n    \"\"\"\n    Validate product compatibility.\n\n    Delegates to underlying retrieval strategy (Lucene or Vector) for validation.\n    \"\"\"\n    # Use Lucene strategy for compatibility validation (delegates to Cypher)\n    return await self.lucene_strategy.validate_compatibility(\n        product_gin=product_gin,\n        selected_components=selected_components,\n        component_type=component_type\n    )\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#use-cases_1","title":"Use Cases","text":"<p>When LLM Search Excels:</p> <ol> <li>Competitor Equivalents: \"equivalent of Miller Dynasty 280\" \u2192 exact matches</li> <li>Complex Requirements: \"industrial welder for stainless steel up to 10mm thick\"</li> <li>Contextual Matching: \"affordable solution for small shop\" \u2192 price-conscious options</li> <li>Feature Prioritization: \"need portability over power\" \u2192 portable units ranked higher</li> <li>Application-Based: \"automotive body repair welding\" \u2192 automotive-specific features</li> </ol> <p>Example Query with Reasoning: <pre><code>User: \"I need a reliable welder similar to Miller Dynasty 280 for TIG welding\"\n\nLLM Re-ranking Results:\n1. Aristo 500ix (Score: 95/100)\n   Reasoning: \"Perfect equivalent - listed as direct competitor to Miller Dynasty 280.\n               Excellent TIG capabilities with advanced pulse control.\"\n\n2. Warrior 500i (Score: 82/100)\n   Reasoning: \"Strong alternative with similar TIG performance. Slightly different\n               feature set but comparable reliability and power output.\"\n\n3. Aristo 400ix (Score: 68/100)\n   Reasoning: \"Lower power variant of Dynasty equivalent. Good TIG performance\n               but may be underpowered for some applications.\"\n</code></pre></p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#performance-characteristics_1","title":"Performance Characteristics","text":"<p>Retrieval Phase: - Lucene: ~100-200ms - Vector: ~250-650ms - Combined: ~250-650ms (parallel execution)</p> <p>LLM Re-ranking Phase: - API call latency: ~1-3 seconds (depends on candidate count) - Token cost: ~500-2000 tokens per request - Model: gpt-4o-mini (fast and cost-effective)</p> <p>Total Latency: ~1.5-4 seconds per search</p> <p>Cost Optimization: - Use <code>retrieval_limit</code> to control candidate count - Reduce <code>top_n</code> to return fewer products - Consider caching for repeated queries</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#query-building-system","title":"Query Building System","text":"<p>File: <code>src/backend/app/services/search/components/query_builder.py</code> (1015 lines)</p> <p>Centralizes all Neo4j Cypher query construction with comprehensive normalization.</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#core-responsibilities_1","title":"Core Responsibilities","text":"<pre><code>class Neo4jQueryBuilder:\n    \"\"\"\n    Builds Neo4j Cypher queries for component searches.\n\n    Features:\n    - Base MATCH clauses with Neo4j labels\n    - Compatibility filters (single-select and multi-select)\n    - Search term filters (product name, features)\n    - Lucene full-text queries with UNION\n    - Parameter normalization (measurements, units)\n    - Search text normalization (12 rules)\n    - Stop word removal (23 common words)\n    - Lucene special character escaping\n    - Pagination (SKIP/LIMIT)\n    - Priority ordering\n    \"\"\"\n\n    def __init__(self, component_config: Dict[str, Any]):\n        \"\"\"\n        Initialize query builder with component configuration.\n\n        Args:\n            component_config: Component types configuration from JSON\n        \"\"\"\n        self.component_config = component_config\n\n        # Load parameter_normalizations.json\n        normalizations_path = (\n            Path(__file__).parent.parent.parent /\n            \"config\" / \"parameter_normalizations.json\"\n        )\n\n        with open(normalizations_path, \"r\") as f:\n            normalizations_data = json.load(f)\n            self.normalizations = normalizations_data.get(\"normalizations\", {})\n            self.component_parameter_mapping = normalizations_data.get(\n                \"component_parameter_mapping\", {}\n            )\n\n        logger.info(\n            f\"\u2705 Neo4jQueryBuilder initialized | \"\n            f\"Normalizations loaded: {len(self.normalizations)} types\"\n        )\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#base-query-building","title":"Base Query Building","text":"<pre><code>def build_base_query(\n    self,\n    component_type: str,\n    node_alias: str = \"p\"\n) -&gt; Tuple[str, Dict]:\n    \"\"\"\n    Build base MATCH clause for component type.\n\n    Example Output:\n        query: \"MATCH (ps:PowerSource)\\nWHERE ps.category = $category\"\n        params: {\"category\": \"PowerSource\"}\n\n    Args:\n        component_type: Component key (power_source, feeder, cooler, etc.)\n        node_alias: Node variable name (default: \"p\")\n\n    Returns:\n        Tuple of (query_string, parameters_dict)\n    \"\"\"\n    config = self.component_config.get(component_type)\n    if not config:\n        raise ValueError(f\"Unknown component type: {component_type}\")\n\n    neo4j_label = config[\"neo4j_label\"]  # e.g., \"PowerSource\", \"Feeder\"\n    category = config[\"category\"]  # e.g., \"PowerSource\", \"Wire Feeders\"\n\n    # Build MATCH clause\n    query = f\"MATCH ({node_alias}:{neo4j_label})\"\n    params = {}\n\n    # Add category filter if specified\n    if category:\n        query += f\"\\nWHERE {node_alias}.category = $category\"\n        params[\"category\"] = category\n\n    logger.debug(\n        f\"\ud83d\udd27 Built base query | Component: {component_type} | \"\n        f\"Label: {neo4j_label} | Category: {category}\"\n    )\n\n    return query, params\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#compatibility-filters","title":"Compatibility Filters","text":"<p>Single-Select Components (PowerSource, Feeder, Cooler, etc.):</p> <pre><code># Example: Feeder search with selected PowerSource\n#\n# MATCH (target:Feeder)\n# WHERE target.category = $category\n# MATCH (po_dep:PowerSource {gin: $power_source_gin})\n# MATCH (target)-[r1:COMPATIBLE_WITH]-&gt;(po_dep)\n</code></pre> <p>Multi-Select Components (Accessories):</p> <pre><code># Example: Accessories search with 3 selected accessories\n#\n# MATCH (target:Product)\n# WHERE target.category = $category\n# MATCH (fe_dep:Product)\n# WHERE fe_dep.gin IN [$feeder_accessories_gin_0, $feeder_accessories_gin_1, $feeder_accessories_gin_2]\n# MATCH (target)-[r1:COMPATIBLE_WITH]-&gt;(fe_dep)\n</code></pre> <p>Implementation:</p> <pre><code>def add_compatibility_filters(\n    self,\n    query: str,\n    params: Dict,\n    component_type: str,\n    selected_components: Dict,\n    node_alias: str = \"target\",\n    collect_parent_gins: bool = False\n) -&gt; Tuple[str, Dict, Optional[str]]:\n    \"\"\"\n    Add COMPATIBLE_WITH relationship filters for selected components.\n\n    Handles:\n    - Single-select: Core components (PowerSource, Feeder, Cooler, etc.)\n    - Multi-select: Accessories (can have multiple selected)\n\n    Args:\n        query: Base query string\n        params: Query parameters dict\n        component_type: Component key\n        selected_components: Dict of selected components from ResponseJSON\n        node_alias: Target node variable name\n        collect_parent_gins: Whether to collect parent GINs for scoring\n\n    Returns:\n        Tuple of (updated_query, updated_params, parent_alias)\n    \"\"\"\n    config = self.component_config.get(component_type)\n    dependencies = config.get(\"dependencies\", [])\n\n    if not dependencies:\n        logger.debug(\n            f\"\ud83d\udd27 No dependencies for {component_type}, skipping compatibility filters\"\n        )\n        return query, params, None\n\n    compatibility_clauses = []\n    rel_counter = 1\n    parent_alias = None\n\n    for dep in dependencies:\n        # Map dependency to ResponseJSON key\n        # e.g., \"power_source\" \u2192 \"PowerSource\"\n        response_key = self._to_response_key(dep)\n        selected = selected_components.get(response_key)\n\n        if not selected:\n            logger.debug(f\"\u23ed\ufe0f Skipping dependency {dep}, not selected\")\n            continue\n\n        dep_config = self.component_config.get(dep)\n        dep_label = dep_config[\"neo4j_label\"]\n        dep_alias = f\"{dep[:2]}_dep\"\n\n        # Check if multi-select (list of components)\n        if isinstance(selected, list):\n            # Multi-select: Accessories\n            gins = [item.get(\"gin\") for item in selected if item.get(\"gin\")]\n\n            if not gins:\n                continue\n\n            # Build parameter names for each GIN\n            param_names = []\n            for idx, gin in enumerate(gins):\n                param_name = f\"{dep}_gin_{idx}\"\n                params[param_name] = gin\n                param_names.append(f\"${param_name}\")\n\n            # Add MATCH clauses\n            compatibility_clauses.append(f\"MATCH ({dep_alias}:{dep_label})\")\n            compatibility_clauses.append(\n                f\"WHERE {dep_alias}.gin IN [{', '.join(param_names)}]\"\n            )\n            compatibility_clauses.append(\n                f\"MATCH ({node_alias})-[r{rel_counter}:COMPATIBLE_WITH]-&gt;({dep_alias})\"\n            )\n\n            logger.debug(\n                f\"\ud83d\udd17 Added multi-select compatibility | Dependency: {dep} | \"\n                f\"Count: {len(gins)}\"\n            )\n\n        else:\n            # Single-select: Core component\n            gin = selected.get(\"gin\")\n\n            if not gin:\n                continue\n\n            param_name = f\"{dep}_gin\"\n            params[param_name] = gin\n\n            # Add MATCH clauses\n            compatibility_clauses.append(\n                f\"MATCH ({dep_alias}:{dep_label} {{gin: ${param_name}}})\"\n            )\n            compatibility_clauses.append(\n                f\"MATCH ({node_alias})-[r{rel_counter}:COMPATIBLE_WITH]-&gt;({dep_alias})\"\n            )\n\n            if collect_parent_gins and parent_alias is None:\n                parent_alias = dep_alias\n\n            logger.debug(\n                f\"\ud83d\udd17 Added single-select compatibility | Dependency: {dep} | \"\n                f\"GIN: {gin}\"\n            )\n\n        rel_counter += 1\n\n    # Combine all clauses\n    if compatibility_clauses:\n        query = \"\\n\".join([query] + compatibility_clauses)\n\n    return query, params, parent_alias\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#search-term-filters","title":"Search Term Filters","text":"<p>Dynamic WHERE Clause Generation:</p> <pre><code>def add_search_term_filters(\n    self,\n    query: str,\n    params: Dict,\n    search_terms_dict: Dict,\n    node_alias: str\n) -&gt; Tuple[str, Dict]:\n    \"\"\"\n    Add dynamic WHERE/AND filters for product_name and feature_terms.\n\n    Filters:\n    - product_name: Match on item_name using space-insensitive CONTAINS\n    - feature_terms: Match on clean_description or attribute_ruleset\n\n    Example Output:\n        WHERE (\n            replace(toLower(p.item_name), ' ', '') CONTAINS replace(toLower($product_name_filter), ' ', '')\n            OR (toLower(p.clean_description) CONTAINS toLower($feature_0)\n                OR toLower(p.attribute_ruleset) CONTAINS toLower($feature_0))\n            OR (toLower(p.clean_description) CONTAINS toLower($feature_1)\n                OR toLower(p.attribute_ruleset) CONTAINS toLower($feature_1))\n        )\n\n    Args:\n        query: Base query string\n        params: Query parameters dict\n        search_terms_dict: Dict with \"product_name\" and \"feature_terms\"\n        node_alias: Target node variable name\n\n    Returns:\n        Tuple of (updated_query, updated_params)\n    \"\"\"\n    product_name = search_terms_dict.get(\"product_name\")\n    feature_terms = search_terms_dict.get(\"feature_terms\", [])\n\n    conditions = []\n\n    # Product name filter (space-insensitive)\n    if product_name:\n        conditions.append(\n            f\"replace(toLower({node_alias}.item_name), ' ', '') CONTAINS \"\n            f\"replace(toLower($product_name_filter), ' ', '')\"\n        )\n        params[\"product_name_filter\"] = product_name\n\n        logger.debug(f\"\ud83d\udd0d Added product name filter: '{product_name}'\")\n\n    # Feature term filters\n    if feature_terms:\n        for idx, term in enumerate(feature_terms):\n            param_name = f\"feature_{idx}\"\n            conditions.append(\n                f\"(toLower({node_alias}.clean_description) CONTAINS toLower(${param_name}) \"\n                f\"OR toLower({node_alias}.attribute_ruleset) CONTAINS toLower(${param_name}))\"\n            )\n            params[param_name] = term\n\n            logger.debug(f\"\ud83d\udd0d Added feature term filter [{idx}]: '{term}'\")\n\n    # Combine conditions with OR\n    if conditions:\n        where_clause = \"\\nWHERE (\" + \" OR \".join(conditions) + \")\"\n        query += where_clause\n\n    return query, params\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#lucene-query-building","title":"Lucene Query Building","text":"<p>UNION Queries for Better Recall:</p> <pre><code>def build_lucene_query(\n    self,\n    component_type: str,\n    user_message: str,\n    node_alias: str = \"p\"\n) -&gt; Tuple[str, Dict]:\n    \"\"\"\n    Build Lucene full-text search query with UNION for better recall.\n\n    Strategy:\n    1. Remove stop words from user message\n    2. Normalize text (units: 500 Amps \u2192 500 A)\n    3. Escape Lucene special characters\n    4. Build UNION query if normalized != stopwords-removed\n\n    UNION Benefits:\n    - Query 1 (normalized): Better precision with standardized units\n    - Query 2 (stopwords-removed): Better recall with original text\n\n    Example Input:\n        \"I need a 500 Amps MIG welder\"\n\n    Example Processing:\n        Stopwords removed: \"500 Amps MIG welder\"\n        Normalized: \"500 A MIG welder\"\n\n    Example Output Query:\n        CALL {\n            CALL db.index.fulltext.queryNodes('productIndex', '500 A MIG welder')\n            YIELD node AS p, score\n            WHERE p:PowerSource AND p.category = $category\n            RETURN p, score\n            UNION\n            CALL db.index.fulltext.queryNodes('productIndex', '500 Amps MIG welder')\n            YIELD node AS p, score\n            WHERE p:PowerSource AND p.category = $category\n            RETURN p, score\n        }\n\n    Args:\n        component_type: Component key\n        user_message: User's search text\n        node_alias: Node variable name\n\n    Returns:\n        Tuple of (query_string, parameters_dict)\n    \"\"\"\n    config = self.component_config.get(component_type)\n    neo4j_label = config[\"neo4j_label\"]\n    category = config[\"category\"]\n\n    # Step 1: Remove stop words\n    stopwords_removed = self._remove_stopwords(user_message)\n\n    # Step 2: Normalize text (units, measurements)\n    normalized_text = self._normalize_search_text(stopwords_removed)\n\n    # Step 3: Escape Lucene special characters\n    escaped_normalized = self._escape_lucene_special_chars(normalized_text)\n    escaped_stopwords = self._escape_lucene_special_chars(stopwords_removed)\n\n    logger.debug(\n        f\"\ud83d\udcdd Lucene query preprocessing:\\n\"\n        f\"  Original: '{user_message}'\\n\"\n        f\"  Stopwords removed: '{stopwords_removed}'\\n\"\n        f\"  Normalized: '{normalized_text}'\\n\"\n        f\"  Escaped normalized: '{escaped_normalized}'\\n\"\n        f\"  Escaped stopwords: '{escaped_stopwords}'\"\n    )\n\n    # Step 4: Build UNION query if different\n    if normalized_text != stopwords_removed:\n        # UNION: Normalized + Stopwords-removed for better recall\n        query = f\"\"\"\n        CALL {{\n            CALL db.index.fulltext.queryNodes('productIndex', $normalized_text)\n            YIELD node AS {node_alias}, score\n            WHERE {node_alias}:{neo4j_label} AND {node_alias}.category = $category\n            RETURN {node_alias}, score\n            UNION\n            CALL db.index.fulltext.queryNodes('productIndex', $stopwords_text)\n            YIELD node AS {node_alias}, score\n            WHERE {node_alias}:{neo4j_label} AND {node_alias}.category = $category\n            RETURN {node_alias}, score\n        }}\n        \"\"\"\n\n        params = {\n            \"normalized_text\": escaped_normalized,\n            \"stopwords_text\": escaped_stopwords,\n            \"category\": category\n        }\n\n        logger.debug(\n            f\"\ud83d\udd0d Built UNION Lucene query | \"\n            f\"Normalized: '{escaped_normalized}' | \"\n            f\"Stopwords: '{escaped_stopwords}'\"\n        )\n\n    else:\n        # Single query (no difference between normalized and stopwords-removed)\n        query = f\"\"\"\n        CALL db.index.fulltext.queryNodes('productIndex', $search_text)\n        YIELD node AS {node_alias}, score\n        WHERE {node_alias}:{neo4j_label} AND {node_alias}.category = $category\n        \"\"\"\n\n        params = {\n            \"search_text\": escaped_stopwords,\n            \"category\": category\n        }\n\n        logger.debug(\n            f\"\ud83d\udd0d Built single Lucene query | Text: '{escaped_stopwords}'\"\n        )\n\n    return query, params\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#pagination-and-ordering","title":"Pagination and Ordering","text":"<pre><code>def add_pagination(\n    self,\n    query: str,\n    limit: int = 10,\n    offset: int = 0\n) -&gt; str:\n    \"\"\"\n    Add SKIP/LIMIT pagination to query.\n\n    Args:\n        query: Base query string\n        limit: Maximum results to return\n        offset: Number of results to skip\n\n    Returns:\n        Query with pagination clauses\n    \"\"\"\n    query += f\"\\nSKIP {offset}\\nLIMIT {limit}\"\n\n    logger.debug(f\"\ud83d\udcc4 Added pagination | SKIP {offset} | LIMIT {limit}\")\n\n    return query\n\ndef add_ordering(\n    self,\n    query: str,\n    node_alias: str = \"p\",\n    parent_alias: Optional[str] = None\n) -&gt; str:\n    \"\"\"\n    Add ORDER BY clause for deterministic ranking.\n\n    Priority Ordering:\n    1. Relationship priority (lower = better)\n    2. Alphabetical by item_name\n\n    Args:\n        query: Base query string\n        node_alias: Target node variable name\n        parent_alias: Parent node for MIN(priority) aggregation\n\n    Returns:\n        Query with ORDER BY clause\n    \"\"\"\n    if parent_alias:\n        # With relationships: Order by MIN(priority), then alphabetical\n        query += f\"\\nWITH {node_alias}, MIN(r1.priority) as min_priority\"\n        query += f\"\\nORDER BY min_priority ASC, {node_alias}.item_name ASC\"\n\n        logger.debug(\n            f\"\ud83d\udcca Added priority ordering | Parent: {parent_alias}\"\n        )\n    else:\n        # Without relationships: Order alphabetically only\n        query += f\"\\nORDER BY {node_alias}.item_name ASC\"\n\n        logger.debug(\"\ud83d\udcca Added alphabetical ordering\")\n\n    return query\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#normalization-systems","title":"Normalization Systems","text":""},{"location":"SEARCH_STRATEGIES_AND_SCORING/#parameter-normalization","title":"Parameter Normalization","text":"<p>Purpose: Map user input variations to canonical search terms</p> <p>Configuration: <code>app/config/parameter_normalizations.json</code></p> <p>Example Mappings:</p> <pre><code>{\n  \"normalizations\": {\n    \"cable_length_meters\": {\n      \"mappings\": {\n        \"2m\": [\"2m\", \"2 m\", \"2.0m\", \"2 meter\", \"2 meters\", \"2-m\"],\n        \"5m\": [\"5m\", \"5 m\", \"5.0m\", \"5 meter\", \"5 meters\", \"5-m\"],\n        \"10m\": [\"10m\", \"10 m\", \"10.0m\", \"10 meter\", \"10 meters\", \"10-m\"]\n      }\n    },\n    \"current_output_amps\": {\n      \"mappings\": {\n        \"300A\": [\"300A\", \"300 A\", \"300amp\", \"300 ampere\", \"300 amps\"],\n        \"400A\": [\"400A\", \"400 A\", \"400amp\", \"400 ampere\", \"400 amps\"],\n        \"500A\": [\"500A\", \"500 A\", \"500amp\", \"500 ampere\", \"500 amps\"]\n      }\n    },\n    \"voltage\": {\n      \"mappings\": {\n        \"230V\": [\"230V\", \"230 V\", \"230volt\", \"230 volts\", \"230-V\"],\n        \"400V\": [\"400V\", \"400 V\", \"400volt\", \"400 volts\", \"400-V\"],\n        \"480V\": [\"480V\", \"480 V\", \"480volt\", \"480 volts\", \"480-V\"]\n      }\n    }\n  },\n  \"component_parameter_mapping\": {\n    \"power_source\": [\"current_output_amps\", \"voltage\", \"duty_cycle_percent\"],\n    \"feeder\": [\"wire_diameter_mm\", \"cable_length_meters\"],\n    \"cooler\": [\"cooling_capacity\", \"voltage\"],\n    \"interconnector\": [\"cable_length_meters\", \"cross_section_mm2\"],\n    \"torch\": [\"amperage_rating\", \"cable_length_meters\"]\n  }\n}\n</code></pre> <p>Implementation:</p> <pre><code>def _normalize_parameter_value(\n    self,\n    value: str,\n    component_type: str\n) -&gt; List[str]:\n    \"\"\"\n    Normalize parameter values using JSON mappings.\n\n    Returns all variants for a canonical value to match user input variations.\n\n    Examples:\n        &gt;&gt;&gt; _normalize_parameter_value(\"5m\", \"interconnector\")\n        [\"5m\", \"5 m\", \"5.0m\", \"5 meter\", \"5 meters\", \"5-m\"]\n\n        &gt;&gt;&gt; _normalize_parameter_value(\"500A\", \"power_source\")\n        [\"500A\", \"500 A\", \"500amp\", \"500 ampere\", \"500 amps\", \"500-A\"]\n\n        &gt;&gt;&gt; _normalize_parameter_value(\"0.8mm\", \"feeder\")\n        [\"0.8mm\", \"0.8 mm\", \"0.8millimeter\", \"0.8 millimeters\"]\n\n    Args:\n        value: Input parameter value to normalize\n        component_type: Component key (determines applicable normalizations)\n\n    Returns:\n        List of all variant strings for matching\n    \"\"\"\n    if not self.normalizations:\n        return [value.strip()]\n\n    value_normalized = value.strip().lower()\n\n    # Get applicable normalization types for this component\n    applicable_params = self.component_parameter_mapping.get(\n        component_type, []\n    )\n\n    # Check each normalization type\n    for param_type in applicable_params:\n        if param_type not in self.normalizations:\n            continue\n\n        mappings = self.normalizations[param_type].get(\"mappings\", {})\n\n        # Check if value matches any variant\n        for canonical_value, variants in mappings.items():\n            for variant in variants:\n                if variant.lower() == value_normalized:\n                    # Found match - return all variants\n                    logger.debug(\n                        f\"\u2705 Normalized '{value}' \u2192 {len(variants)} variants | \"\n                        f\"Type: {param_type}\"\n                    )\n                    return variants\n\n    # No mapping found - apply fallback normalization\n    return self._fallback_normalization(value)\n\ndef _fallback_normalization(self, value: str) -&gt; List[str]:\n    \"\"\"\n    Fallback normalization when no JSON mapping exists.\n\n    Generates common variations:\n    - Original value\n    - Lowercase\n    - With spaces between number and unit\n    - Without spaces\n\n    Examples:\n        &gt;&gt;&gt; _fallback_normalization(\"500A\")\n        [\"500A\", \"500a\", \"500 A\", \"500 a\"]\n\n        &gt;&gt;&gt; _fallback_normalization(\"MIG welder\")\n        [\"MIG welder\", \"mig welder\"]\n\n    Args:\n        value: Input value\n\n    Returns:\n        List of normalized variants\n    \"\"\"\n    variants = [value.strip()]\n\n    # Add lowercase\n    variants.append(value.strip().lower())\n\n    # Add variations with/without spaces for number+unit patterns\n    import re\n\n    # Pattern: number followed by letters (e.g., \"500A\")\n    match = re.match(r'^(\\d+)([A-Za-z]+)$', value.strip())\n    if match:\n        num, unit = match.groups()\n        # Add spaced version\n        variants.append(f\"{num} {unit}\")\n        variants.append(f\"{num} {unit.lower()}\")\n\n    # Remove duplicates while preserving order\n    seen = set()\n    unique_variants = []\n    for v in variants:\n        if v not in seen:\n            seen.add(v)\n            unique_variants.append(v)\n\n    logger.debug(\n        f\"\ud83d\udd04 Fallback normalization: '{value}' \u2192 {len(unique_variants)} variants\"\n    )\n\n    return unique_variants\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#search-text-normalization","title":"Search Text Normalization","text":"<p>Purpose: Standardize measurement units in user queries for consistent matching</p> <p>12 Normalization Rules:</p> <pre><code>def _normalize_search_text(self, text: str) -&gt; str:\n    \"\"\"\n    Normalize measurement units in search text.\n\n    Normalization Rules:\n    1. Add space between numbers and units: \"500A\" \u2192 \"500 A\"\n    2. Amperage: \"500 Amps/Ampere/Amp\u00e8res\" \u2192 \"500 A\"\n    3. Voltage: \"380 Volts/Voltios\" \u2192 \"380 V\"\n    4. Power (Watts): \"500 Watts\" \u2192 \"500 W\"\n    5. Power (Kilowatts): \"4 kilowatts\" \u2192 \"4 kW\"\n    6. Length (meters): \"15 meters/metres\" \u2192 \"15 m\"\n    7. Length (millimeters): \"30 millimeters\" \u2192 \"30 mm\"\n    8. Pressure: \"5 Bar/BAR\" \u2192 \"5 bar\"\n    9. Flow rate: \"7 l/min\" \u2192 \"7 l/minute\"\n    10. Phase: \"3ph\" \u2192 \"3 phase\"\n    11. Hertz: \"50Hz\" \u2192 \"50 Hz\", \"60 Hertz\" \u2192 \"60 Hz\"\n    12. Percentage: \"60%\" \u2192 \"60 %\"\n\n    Examples:\n        &gt;&gt;&gt; _normalize_search_text(\"500 Amps MIG welder\")\n        \"500 A MIG welder\"\n\n        &gt;&gt;&gt; _normalize_search_text(\"380 Volts 30mm wire\")\n        \"380 V 30 mm wire\"\n\n        &gt;&gt;&gt; _normalize_search_text(\"I need a 15meters cable\")\n        \"15 m cable\"\n\n    Args:\n        text: User search text\n\n    Returns:\n        Normalized text with standardized units\n    \"\"\"\n    normalized = text\n\n    # Rule 1: Add space between numbers and units\n    # \"500A\" \u2192 \"500 A\", \"30mm\" \u2192 \"30 mm\"\n    normalized = re.sub(r'(\\d+)([A-Za-z]+)', r'\\1 \\2', normalized)\n\n    # Rule 2: Amperage normalization\n    # \"500 Amps\" / \"500 Ampere\" / \"500 Amp\u00e8res\" \u2192 \"500 A\"\n    normalized = re.sub(\n        r'(\\d+)\\s*(Amps?|Amperes?|Amp\u00e8res?)\\b',\n        r'\\1 A',\n        normalized,\n        flags=re.IGNORECASE\n    )\n\n    # Rule 3: Voltage normalization\n    # \"380 Volts\" / \"380 Voltios\" \u2192 \"380 V\"\n    normalized = re.sub(\n        r'(\\d+)\\s*(Volts?|Voltios?)\\b',\n        r'\\1 V',\n        normalized,\n        flags=re.IGNORECASE\n    )\n\n    # Rule 4: Power (Watts) normalization\n    # \"500 Watts\" \u2192 \"500 W\"\n    normalized = re.sub(\n        r'(\\d+)\\s*Watts?\\b',\n        r'\\1 W',\n        normalized,\n        flags=re.IGNORECASE\n    )\n\n    # Rule 5: Power (Kilowatts) normalization\n    # \"4 kilowatts\" \u2192 \"4 kW\"\n    normalized = re.sub(\n        r'(\\d+)\\s*kilowatts?\\b',\n        r'\\1 kW',\n        normalized,\n        flags=re.IGNORECASE\n    )\n\n    # Rule 6: Length (meters) normalization\n    # \"15 meters\" / \"15 metres\" \u2192 \"15 m\"\n    normalized = re.sub(\n        r'(\\d+)\\s*(meters?|metres?)\\b',\n        r'\\1 m',\n        normalized,\n        flags=re.IGNORECASE\n    )\n\n    # Rule 7: Length (millimeters) normalization\n    # \"30 millimeters\" \u2192 \"30 mm\"\n    normalized = re.sub(\n        r'(\\d+)\\s*millimeters?\\b',\n        r'\\1 mm',\n        normalized,\n        flags=re.IGNORECASE\n    )\n\n    # Rule 8: Pressure normalization\n    # \"5 Bar\" / \"5 BAR\" \u2192 \"5 bar\"\n    normalized = re.sub(\n        r'(\\d+)\\s*BAR\\b',\n        r'\\1 bar',\n        normalized,\n        flags=re.IGNORECASE\n    )\n\n    # Rule 9: Flow rate normalization\n    # \"7 l/min\" \u2192 \"7 l/minute\"\n    normalized = re.sub(\n        r'(\\d+)\\s*l/min\\b',\n        r'\\1 l/minute',\n        normalized,\n        flags=re.IGNORECASE\n    )\n\n    # Rule 10: Phase normalization\n    # \"3ph\" \u2192 \"3 phase\"\n    normalized = re.sub(\n        r'(\\d+)ph\\b',\n        r'\\1 phase',\n        normalized,\n        flags=re.IGNORECASE\n    )\n\n    # Rule 11: Hertz normalization\n    # \"50Hz\" \u2192 \"50 Hz\", \"60 Hertz\" \u2192 \"60 Hz\"\n    normalized = re.sub(\n        r'(\\d+)\\s*(Hz|Hertz)\\b',\n        r'\\1 Hz',\n        normalized,\n        flags=re.IGNORECASE\n    )\n\n    # Rule 12: Percentage normalization\n    # \"60%\" \u2192 \"60 %\"\n    normalized = re.sub(\n        r'(\\d+)%',\n        r'\\1 %',\n        normalized\n    )\n\n    # Clean up extra spaces\n    normalized = re.sub(r'\\s+', ' ', normalized).strip()\n\n    logger.debug(\n        f\"\ud83d\udcdd Search text normalization:\\n\"\n        f\"  Original: '{text}'\\n\"\n        f\"  Normalized: '{normalized}'\"\n    )\n\n    return normalized\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#stop-word-removal","title":"Stop Word Removal","text":"<p>Purpose: Remove common words that don't contribute to search relevance</p> <p>Stop Words List (23 words): <pre><code>STOP_WORDS = {\n    'i', 'need', 'want', 'looking', 'for', 'a', 'an', 'the', 'is', 'am',\n    'are', 'do', 'does', 'can', 'could', 'would', 'should', 'my', 'me',\n    'we', 'our', 'us', 'show', 'find', 'get', 'give', 'have', 'has', 'had',\n    'with', 'without', 'please', 'thanks', 'thank', 'you', 'like', 'this', 'that'\n}\n</code></pre></p> <p>Implementation:</p> <pre><code>def _remove_stopwords(self, text: str) -&gt; str:\n    \"\"\"\n    Remove stop words from search text.\n\n    Benefits:\n    - Focuses Lucene on meaningful keywords\n    - Reduces noise in full-text matching\n    - Improves precision for technical queries\n\n    Examples:\n        &gt;&gt;&gt; _remove_stopwords(\"I need a 500A MIG welder\")\n        \"500A MIG welder\"\n\n        &gt;&gt;&gt; _remove_stopwords(\"Can you show me feeders for aluminum\")\n        \"feeders aluminum\"\n\n        &gt;&gt;&gt; _remove_stopwords(\"I want to find a machine for welding\")\n        \"machine welding\"\n\n    Args:\n        text: User search text\n\n    Returns:\n        Text with stop words removed\n    \"\"\"\n    # Lowercase and clean whitespace\n    clean = text.lower().strip()\n    clean = re.sub(r'\\s+', ' ', clean)\n\n    # Split into words\n    words = clean.split()\n\n    # Filter out stop words and very short words\n    keywords = [\n        word for word in words\n        if word not in STOP_WORDS and len(word) &gt; 1\n    ]\n\n    # Fallback: If all words were stop words, keep words with length &gt; 1\n    if not keywords and words:\n        keywords = [word for word in words if len(word) &gt; 1]\n\n    result = ' '.join(keywords)\n\n    logger.debug(\n        f\"\ud83e\uddf9 Stop word removal:\\n\"\n        f\"  Original: '{text}'\\n\"\n        f\"  Cleaned: '{result}'\\n\"\n        f\"  Removed: {len(words) - len(keywords)} words\"\n    )\n\n    return result\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#lucene-special-character-escaping","title":"Lucene Special Character Escaping","text":"<p>Purpose: Prevent Lucene query parser errors from special characters</p> <p>Special Characters: <pre><code>LUCENE_SPECIAL_CHARS = r'[\\+\\-\\!\\(\\)\\{\\}\\[\\]\\^\\\"\\~\\*\\?\\:\\\\/]'\n</code></pre></p> <p>Implementation:</p> <pre><code>def _escape_lucene_special_chars(self, text: str) -&gt; str:\n    \"\"\"\n    Escape Lucene query parser special characters.\n\n    Special Characters (14):\n    + - ! ( ) { } [ ] ^ \" ~ * ? : \\ /\n\n    Examples:\n        &gt;&gt;&gt; _escape_lucene_special_chars(\"500A+30mm\")\n        \"500A\\\\+30mm\"\n\n        &gt;&gt;&gt; _escape_lucene_special_chars(\"MIG/MAG welder\")\n        \"MIG\\\\/MAG welder\"\n\n        &gt;&gt;&gt; _escape_lucene_special_chars(\"Test (2024)\")\n        \"Test \\\\(2024\\\\)\"\n\n    Args:\n        text: Search text to escape\n\n    Returns:\n        Escaped text safe for Lucene queries\n    \"\"\"\n    import re\n\n    # Escape each special character with backslash\n    escaped = re.sub(\n        LUCENE_SPECIAL_CHARS,\n        lambda match: '\\\\' + match.group(0),\n        text\n    )\n\n    if escaped != text:\n        logger.debug(\n            f\"\ud83d\udd12 Escaped Lucene special chars:\\n\"\n            f\"  Original: '{text}'\\n\"\n            f\"  Escaped: '{escaped}'\"\n        )\n\n    return escaped\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#result-consolidation","title":"Result Consolidation","text":"<p>File: <code>src/backend/app/services/search/consolidator.py</code> (504 lines)</p> <p>The ResultConsolidator merges and ranks results from multiple search strategies.</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#core-algorithm","title":"Core Algorithm","text":"<pre><code>class ResultConsolidator:\n    \"\"\"\n    Consolidates search results from multiple strategies.\n\n    Algorithm:\n    1. Deduplicate products by GIN (first occurrence wins for product data)\n    2. Merge scores using weighted average\n    3. Apply exact match boosting (100x multiplier)\n    4. Append scores to product names (optional)\n    5. Sort by consolidated score (descending)\n    6. Apply component-specific score threshold filtering\n\n    Configuration:\n    - strategy_weights: Weight per strategy (default: all 1.0)\n    - default_score: Fallback score when missing (default: 0.5)\n    - append_score_to_name: Show scores in product names (default: True)\n    - exact_match_boost: Multiplier for exact matches (default: 100.0)\n    \"\"\"\n\n    def __init__(\n        self,\n        strategy_weights: Optional[Dict[str, float]] = None,\n        default_score: float = 0.5,\n        append_score_to_name: bool = True,\n        exact_match_boost: float = 100.0\n    ):\n        self.strategy_weights = strategy_weights or {\n            \"cypher\": 1.0,\n            \"lucene\": 1.0,\n            \"vector\": 1.0\n        }\n        self.default_score = default_score\n        self.append_score_to_name = append_score_to_name\n        self.exact_match_boost = exact_match_boost\n\n        logger.info(\n            f\"\u2705 ResultConsolidator initialized | \"\n            f\"Weights: {self.strategy_weights} | \"\n            f\"Exact match boost: {exact_match_boost}x\"\n        )\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#main-consolidation-method","title":"Main Consolidation Method","text":"<pre><code>def consolidate(\n    self,\n    strategy_results: List[tuple[str, List[Dict], Optional[Dict[str, float]]]],\n    master_parameters: Optional[Dict[str, Any]] = None,\n    component_type: Optional[str] = None\n) -&gt; List[ConsolidatedResult]:\n    \"\"\"\n    Consolidate results from multiple strategies with optional boosting.\n\n    Steps:\n    1. Deduplicate products by GIN\n    2. Track which strategies found each product\n    3. Collect scores from all strategies\n    4. Calculate weighted average score\n    5. Apply exact match boosting (if enabled)\n    6. Append scores to product names (if enabled)\n    7. Sort by consolidated score (descending)\n    8. Apply score threshold filtering (if component specified)\n\n    Args:\n        strategy_results: List of (strategy_name, products, scores) tuples\n        master_parameters: User parameters for exact match boosting\n        component_type: Component key for threshold filtering\n\n    Returns:\n        Sorted list of ConsolidatedResult objects\n    \"\"\"\n    logger.info(\n        f\"\ud83d\udd04 Consolidating results from {len(strategy_results)} strategies\"\n    )\n\n    # Step 1: Deduplicate by GIN\n    products_by_gin: Dict[str, ConsolidatedResult] = {}\n\n    for strategy_name, products, scores in strategy_results:\n        logger.debug(\n            f\"\ud83d\udcca Processing strategy: {strategy_name} | \"\n            f\"Products: {len(products)} | \"\n            f\"Has scores: {scores is not None}\"\n        )\n\n        for product in products:\n            gin = product.get(\"gin\")\n\n            if not gin:\n                logger.warning(f\"\u26a0\ufe0f Product missing GIN, skipping\")\n                continue\n\n            # First occurrence: Store product data\n            if gin not in products_by_gin:\n                products_by_gin[gin] = ConsolidatedResult(\n                    gin=gin,\n                    name=product.get(\"name\", \"Unknown\"),\n                    category=product.get(\"category\", \"\"),\n                    description=product.get(\"description\", \"\"),\n                    specifications=product.get(\"specifications\", {}),\n                    found_by_strategies=[],\n                    strategy_scores={},\n                    consolidated_score=0.0\n                )\n\n            # Step 2: Track which strategies found this product\n            products_by_gin[gin].found_by_strategies.append(strategy_name)\n\n            # Step 3: Collect scores from this strategy\n            if scores and gin in scores:\n                strategy_score = scores[gin]\n            else:\n                strategy_score = self.default_score\n                logger.debug(\n                    f\"\u26a0\ufe0f No score for GIN {gin} from {strategy_name}, \"\n                    f\"using default {self.default_score}\"\n                )\n\n            products_by_gin[gin].strategy_scores[strategy_name] = strategy_score\n\n    logger.info(\n        f\"\u2705 Deduplicated {len(products_by_gin)} unique products\"\n    )\n\n    # Step 4: Calculate weighted average scores\n    for gin, result in products_by_gin.items():\n        result.consolidated_score = self._calculate_weighted_score(\n            result.strategy_scores\n        )\n\n    # Step 5: Apply exact match boosting (100x)\n    if master_parameters and component_type:\n        self._apply_exact_match_boosting(\n            products_by_gin, master_parameters, component_type\n        )\n\n    # Step 6: Append scores to product names\n    if self.append_score_to_name:\n        self._append_scores_to_names(products_by_gin)\n\n    # Step 7: Sort by consolidated score (descending)\n    sorted_results = sorted(\n        products_by_gin.values(),\n        key=lambda x: x.consolidated_score,\n        reverse=True\n    )\n\n    # Step 8: Apply score threshold filtering\n    if component_type:\n        sorted_results = self._apply_score_threshold(\n            sorted_results, component_type\n        )\n\n    logger.info(\n        f\"\u2705 Consolidation complete | Total: {len(sorted_results)} | \"\n        f\"Score range: {sorted_results[0].consolidated_score:.2f} - \"\n        f\"{sorted_results[-1].consolidated_score:.2f}\"\n    )\n\n    return sorted_results\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#weighted-score-calculation","title":"Weighted Score Calculation","text":"<pre><code>def _calculate_weighted_score(\n    self,\n    strategy_scores: Dict[str, float]\n) -&gt; float:\n    \"\"\"\n    Calculate weighted average score from multiple strategies.\n\n    Formula:\n        weighted_score = (\u03a3 score_i \u00d7 weight_i) / (\u03a3 weight_i)\n\n    Example:\n        strategy_scores = {\"cypher\": 0.8, \"lucene\": 0.6}\n        strategy_weights = {\"cypher\": 0.4, \"lucene\": 0.6}\n\n        weighted_sum = (0.8 \u00d7 0.4) + (0.6 \u00d7 0.6) = 0.32 + 0.36 = 0.68\n        total_weight = 0.4 + 0.6 = 1.0\n        final_score = 0.68 / 1.0 = 0.68\n\n    Args:\n        strategy_scores: Dict mapping strategy name to score\n\n    Returns:\n        Weighted average score\n    \"\"\"\n    if not strategy_scores:\n        return self.default_score\n\n    weighted_sum = 0.0\n    total_weight = 0.0\n\n    for strategy_name, score in strategy_scores.items():\n        weight = self.strategy_weights.get(strategy_name, 1.0)\n        weighted_sum += score * weight\n        total_weight += weight\n\n    if total_weight == 0:\n        return self.default_score\n\n    final_score = weighted_sum / total_weight\n\n    logger.debug(\n        f\"\ud83d\udcca Weighted score calculation | \"\n        f\"Strategies: {list(strategy_scores.keys())} | \"\n        f\"Weighted sum: {weighted_sum:.4f} | \"\n        f\"Total weight: {total_weight:.4f} | \"\n        f\"Final: {final_score:.4f}\"\n    )\n\n    return final_score\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#exact-match-boosting","title":"Exact Match Boosting","text":"<p>Purpose: Prioritize products that exactly match the user's specified product name</p> <pre><code>def _apply_exact_match_boosting(\n    self,\n    products_by_gin: Dict[str, ConsolidatedResult],\n    master_parameters: Dict[str, Any],\n    component_type: str\n):\n    \"\"\"\n    Apply 100x score boosting for exact product name matches.\n\n    Matching Strategy:\n    - Extract product_name from master_parameters for component\n    - Compare with result names using space-insensitive matching\n    - Boost score by exact_match_boost multiplier (default 100.0)\n\n    Example:\n        User searches for: \"Aristo 500ix\"\n        Product name: \"Aristo 500ix MIG Power Source\"\n\n        Space-insensitive match:\n        \"aristo500ix\" in \"aristo500ixmigpowersource\" \u2713\n\n        Original score: 0.65\n        Boosted score: 0.65 \u00d7 100.0 = 65.0\n\n    Args:\n        products_by_gin: Dict of consolidated results\n        master_parameters: User parameters with product names\n        component_type: Component key for parameter extraction\n    \"\"\"\n    # Map component_type to master_parameters key\n    component_key_map = {\n        \"PowerSource\": \"power_source\",\n        \"Feeder\": \"feeder\",\n        \"Cooler\": \"cooler\",\n        \"Interconnector\": \"interconnector\",\n        \"Torch\": \"torch\",\n        \"Accessories\": \"accessories\"\n    }\n\n    component_key = component_key_map.get(component_type)\n    if not component_key:\n        logger.debug(f\"\u23ed\ufe0f No component key mapping for {component_type}\")\n        return\n\n    # Extract product_name from parameters\n    component_params = master_parameters.get(component_key, {})\n    product_name = component_params.get(\"product_name\", \"\").strip().lower()\n\n    if not product_name:\n        logger.debug(f\"\u23ed\ufe0f No product_name in master_parameters for {component_type}\")\n        return\n\n    logger.info(\n        f\"\ud83c\udfaf Applying exact match boosting | \"\n        f\"Component: {component_type} | \"\n        f\"Target: '{product_name}' | \"\n        f\"Boost: {self.exact_match_boost}x\"\n    )\n\n    # Check each product for exact match\n    boosted_count = 0\n\n    for gin, result in products_by_gin.items():\n        result_name = result.name.strip().lower()\n\n        # Space-insensitive matching\n        result_name_no_spaces = result_name.replace(' ', '')\n        product_name_no_spaces = product_name.replace(' ', '')\n\n        # Check if exact match\n        is_exact_match = (\n            result_name_no_spaces == product_name_no_spaces or\n            product_name_no_spaces in result_name_no_spaces\n        )\n\n        if is_exact_match:\n            original_score = result.consolidated_score\n            result.consolidated_score = original_score * self.exact_match_boost\n            boosted_count += 1\n\n            logger.info(\n                f\"\u2728 BOOSTED: '{result.name}' (GIN: {gin})\\n\"\n                f\"   Matched: '{product_name}'\\n\"\n                f\"   Score: {original_score:.4f} \u2192 {result.consolidated_score:.4f} \"\n                f\"({self.exact_match_boost}x)\"\n            )\n\n    if boosted_count &gt; 0:\n        logger.info(\n            f\"\u2705 Exact match boosting complete | Boosted: {boosted_count} products\"\n        )\n    else:\n        logger.info(\n            f\"\u2139\ufe0f No exact matches found for '{product_name}'\"\n        )\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#score-threshold-filtering","title":"Score Threshold Filtering","text":"<p>Purpose: Filter out low-scoring products that are significantly worse than top results</p> <pre><code>def _apply_score_threshold(\n    self,\n    results: List[ConsolidatedResult],\n    component_type: str\n) -&gt; List[ConsolidatedResult]:\n    \"\"\"\n    Filter products by score threshold percentage.\n\n    Algorithm:\n    1. Get component-specific threshold from config (default: 25%)\n    2. Calculate minimum score: top_score \u00d7 (1 - threshold/100)\n    3. Keep only products with score &gt;= minimum\n\n    Example:\n        Top score: 10.0\n        Threshold: 25%\n        Min score: 10.0 \u00d7 (1 - 0.25) = 10.0 \u00d7 0.75 = 7.5\n\n        Keep products with score &gt;= 7.5 (within 25% of top)\n\n    Configuration:\n        component_types.json \u2192 lucene_score_threshold_percent\n\n    Args:\n        results: Sorted list of consolidated results\n        component_type: Component key for config lookup\n\n    Returns:\n        Filtered list of results\n    \"\"\"\n    if not results:\n        return results\n\n    # Load component config\n    component_key_map = {\n        \"PowerSource\": \"power_source\",\n        \"Feeder\": \"feeder\",\n        \"Cooler\": \"cooler\",\n        \"Interconnector\": \"interconnector\",\n        \"Torch\": \"torch\",\n        \"Accessories\": \"accessories\"\n    }\n\n    component_key = component_key_map.get(component_type)\n    if not component_key:\n        logger.debug(f\"\u23ed\ufe0f No threshold filtering for {component_type}\")\n        return results\n\n    # Get threshold from config\n    component_config = load_component_config().get(component_key, {})\n    threshold_percent = component_config.get(\n        \"lucene_score_threshold_percent\", 25\n    )\n\n    # Calculate minimum score\n    top_score = results[0].consolidated_score\n    min_score = top_score * (1 - threshold_percent / 100.0)\n\n    # Filter results\n    filtered_results = [\n        r for r in results\n        if r.consolidated_score &gt;= min_score\n    ]\n\n    filtered_count = len(results) - len(filtered_results)\n\n    logger.info(\n        f\"\ud83d\udd0d THRESHOLD FILTERING:\\n\"\n        f\"   Component: {component_type}\\n\"\n        f\"   Top score: {top_score:.2f}\\n\"\n        f\"   Threshold: {threshold_percent}%\\n\"\n        f\"   Min score: {min_score:.2f}\\n\"\n        f\"   Filtered out: {filtered_count} products\\n\"\n        f\"   Kept: {len(filtered_results)}/{len(results)} products\"\n    )\n\n    return filtered_results\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#score-appending-to-names","title":"Score Appending to Names","text":"<pre><code>def _append_scores_to_names(\n    self,\n    products_by_gin: Dict[str, ConsolidatedResult]\n):\n    \"\"\"\n    Append consolidated scores to product names.\n\n    Format: \"Product Name (Score: 11.5)\"\n\n    Purpose:\n    - Transparency for users and debugging\n    - Easy score extraction by downstream code\n    - Visual ranking validation\n\n    Args:\n        products_by_gin: Dict of consolidated results (modified in-place)\n    \"\"\"\n    for gin, result in products_by_gin.items():\n        # Check if score already appended (avoid duplicates)\n        if \"(Score:\" not in result.name:\n            result.name = f\"{result.name} (Score: {result.consolidated_score:.1f})\"\n\n            logger.debug(\n                f\"\ud83d\udcdd Appended score to name | \"\n                f\"GIN: {gin} | \"\n                f\"Name: '{result.name}'\"\n            )\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#consolidation-report","title":"Consolidation Report","text":"<pre><code>def generate_consolidation_report(\n    self,\n    strategy_results: List[tuple[str, List[Dict], Optional[Dict[str, float]]]],\n    consolidated_results: List[ConsolidatedResult]\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Generate consolidation summary report.\n\n    Includes:\n    - Total unique products\n    - Products per strategy\n    - Strategy coverage (% of results found by each)\n    - Score statistics (min, max, mean)\n    - Multi-strategy products (found by 2+ strategies)\n\n    Returns:\n        Dict with consolidation metrics\n    \"\"\"\n    report = {\n        \"total_unique_products\": len(consolidated_results),\n        \"strategies\": {},\n        \"score_statistics\": {},\n        \"multi_strategy_products\": 0\n    }\n\n    # Strategy coverage\n    for strategy_name, products, scores in strategy_results:\n        report[\"strategies\"][strategy_name] = {\n            \"product_count\": len(products),\n            \"has_scores\": scores is not None,\n            \"coverage_percent\": (\n                len(products) / len(consolidated_results) * 100\n                if consolidated_results else 0\n            )\n        }\n\n    # Score statistics\n    if consolidated_results:\n        scores = [r.consolidated_score for r in consolidated_results]\n        report[\"score_statistics\"] = {\n            \"min\": min(scores),\n            \"max\": max(scores),\n            \"mean\": sum(scores) / len(scores)\n        }\n\n        # Multi-strategy products\n        report[\"multi_strategy_products\"] = sum(\n            1 for r in consolidated_results\n            if len(r.found_by_strategies) &gt; 1\n        )\n\n    logger.info(\n        f\"\ud83d\udcca CONSOLIDATION REPORT:\\n\"\n        f\"   Unique products: {report['total_unique_products']}\\n\"\n        f\"   Multi-strategy: {report['multi_strategy_products']}\\n\"\n        f\"   Score range: {report['score_statistics'].get('min', 0):.2f} - \"\n        f\"{report['score_statistics'].get('max', 0):.2f}\"\n    )\n\n    return report\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#scoring-algorithms","title":"Scoring Algorithms","text":""},{"location":"SEARCH_STRATEGIES_AND_SCORING/#summary-table","title":"Summary Table","text":"Strategy Algorithm Formula Range Notes Cypher Priority-to-Score (Normalized Linear) <code>score = 1.0 - (priority - 1) / (max_priority - 1)</code> 0.1 - 1.0 Lower priority = Better match Lucene Relevance Score Native Neo4j Lucene scoring 0.0 - \u221e Typically 0.1 - 20.0 Vector Cosine Similarity OpenAI embeddings (text-embedding-3-large) 0.6 - 1.0 Min threshold 0.6, semantic matching LLM GPT-4o-mini Re-ranking Retrieve-then-rerank with reasoning 0.0 - 1.0 Normalized from 0-100, includes competitor matching Consolidation Weighted Average <code>(\u03a3 score_i \u00d7 weight_i) / (\u03a3 weight_i)</code> 0.0 - \u221e Configurable strategy weights Exact Match Boosting Multiplier <code>score \u00d7 100.0</code> 0.0 - \u221e Space-insensitive name matching Threshold Percentage Filter <code>keep if score &gt;= top_score \u00d7 (1 - threshold%)</code> - Component-specific (default 25%)"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#detailed-scoring-examples","title":"Detailed Scoring Examples","text":"<p>Example 1: Cypher Priority-to-Score</p> <pre><code>Configuration:\n- max_priority = 20\n- min_score = 0.1\n\nPriority Mappings:\n- priority=1  \u2192 score=1.00 (perfect, highest priority)\n- priority=2  \u2192 score=0.95\n- priority=5  \u2192 score=0.79\n- priority=10 \u2192 score=0.53\n- priority=15 \u2192 score=0.26\n- priority=20 \u2192 score=0.10 (minimum)\n- priority&gt;20 \u2192 score=0.10 (capped)\n</code></pre> <p>Example 2: Consolidation with Weighted Average</p> <pre><code>Strategy Results:\n- Cypher: score=0.80, weight=0.4\n- Lucene: score=0.60, weight=0.6\n\nCalculation:\nweighted_sum = (0.80 \u00d7 0.4) + (0.60 \u00d7 0.6) = 0.32 + 0.36 = 0.68\ntotal_weight = 0.4 + 0.6 = 1.0\nfinal_score = 0.68 / 1.0 = 0.68\n</code></pre> <p>Example 3: Exact Match Boosting</p> <pre><code>User searches for: \"Aristo 500ix\"\nProduct name: \"Aristo 500ix MIG Power Source\"\n\nSpace-insensitive match: \"aristo500ix\" in \"aristo500ixmigpowersource\" \u2713\n\nOriginal consolidated score: 0.65\nBoosted score: 0.65 \u00d7 100.0 = 65.0\n\nResult: Product jumps to top of results\n</code></pre> <p>Example 4: Threshold Filtering</p> <pre><code>Results after consolidation:\n1. Product A: score=10.0\n2. Product B: score=9.5\n3. Product C: score=8.0\n4. Product D: score=7.0\n5. Product E: score=6.0\n\nThreshold: 25%\nMin score: 10.0 \u00d7 (1 - 0.25) = 7.5\n\nFiltered results:\n1. Product A: 10.0 \u2713 (kept)\n2. Product B: 9.5 \u2713 (kept)\n3. Product C: 8.0 \u2713 (kept)\n4. Product D: 7.0 \u2717 (filtered out, below 7.5)\n5. Product E: 6.0 \u2717 (filtered out, below 7.5)\n\nFinal: 3 products (60% of original)\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#performance-optimization","title":"Performance Optimization","text":""},{"location":"SEARCH_STRATEGIES_AND_SCORING/#parallel-strategy-execution","title":"Parallel Strategy Execution","text":"<p>Performance Gain: 40-60% faster than sequential</p> <p>Implementation: <pre><code># Execute strategies concurrently\ntasks = [strategy.search(...) for strategy in strategies]\nresults = await asyncio.gather(*tasks, return_exceptions=True)\n</code></pre></p> <p>Benefits: - Maximum I/O throughput (concurrent Neo4j queries) - Timeout protection per strategy (30s default) - Exception isolation (one failure doesn't block others)</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#timeout-protection","title":"Timeout Protection","text":"<p>Default: 30 seconds per strategy</p> <pre><code>result = await asyncio.wait_for(\n    strategy.search(...),\n    timeout=30  # seconds\n)\n</code></pre> <p>Benefits: - Prevents hanging on slow queries - Graceful degradation on timeout - Configurable per-strategy</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#graceful-fallback","title":"Graceful Fallback","text":"<p>Configuration: <code>fallback_on_error=True</code> (default)</p> <pre><code>if isinstance(result, Exception):\n    logger.error(f\"Strategy {strategy} failed: {result}\")\n    if self.fallback_on_error:\n        results.append(None)  # Skip failed strategy\n    else:\n        raise result  # Propagate error\n</code></pre> <p>Benefits: - Partial results better than no results - Single strategy failure doesn't block search - Useful for experimental strategies</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#context-based-strategy-selection_1","title":"Context-Based Strategy Selection","text":"<p>Proactive Display Mode: - Trigger: Command keywords (skip, done, next, finalize, yes, no, \"\") - Strategy: Cypher only (fast graph traversal) - Performance: ~50-100ms typical query time - Use Case: User navigating states without specific requirements</p> <p>User Intent Mode: - Trigger: User provides product specifications - Strategy: Cypher + Lucene (graph + full-text) - Performance: ~150-300ms typical query time - Use Case: \"I need a 500A MIG welder for aluminum\"</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#query-optimization","title":"Query Optimization","text":"<p>Indexed Properties: - <code>gin</code> (Primary key) - <code>category</code> (Filtering) - <code>item_name</code> (Sorting)</p> <p>Lucene Full-Text Index: - Index name: <code>productIndex</code> - Indexed properties: <code>item_name</code>, <code>clean_description</code>, <code>attribute_ruleset</code> - Typical query time: ~50-150ms</p> <p>Query Patterns: <pre><code>-- Fast: Use indexed gin lookup\nMATCH (ps:PowerSource {gin: $gin})\n\n-- Fast: Use indexed category filter\nMATCH (p:Product)\nWHERE p.category = $category\n\n-- Optimized: MIN(priority) aggregation for compatibility\nMATCH (target)-[r:COMPATIBLE_WITH]-&gt;(dep)\nWITH target, MIN(r.priority) as min_priority\nORDER BY min_priority ASC\n</code></pre></p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#pagination","title":"Pagination","text":"<p>Implementation: SKIP/LIMIT clauses</p> <pre><code>-- Efficient pagination\nORDER BY min_priority ASC, p.item_name ASC\nSKIP 0\nLIMIT 10\n</code></pre> <p>Benefits: - Reduces data transfer for large result sets - Faster response times - Consistent user experience</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#configuration","title":"Configuration","text":""},{"location":"SEARCH_STRATEGIES_AND_SCORING/#search_configjson","title":"search_config.json","text":"<p>Location: <code>app/config/search_config.json</code></p> <pre><code>{\n  \"strategies\": {\n    \"cypher\": {\n      \"enabled\": true,\n      \"weight\": 0.4,\n      \"max_priority\": 20,\n      \"min_score\": 0.1,\n      \"default_priority\": 1\n    },\n    \"lucene\": {\n      \"enabled\": true,\n      \"weight\": 0.6,\n      \"min_score\": 0.0\n    },\n    \"vector\": {\n      \"enabled\": false,\n      \"weight\": 0.5,\n      \"model\": \"text-embedding-ada-002\"\n    }\n  },\n  \"orchestrator\": {\n    \"execution_mode\": \"parallel\",\n    \"timeout\": 30,\n    \"fallback_on_error\": true\n  },\n  \"consolidator\": {\n    \"default_score\": 0.5,\n    \"append_score_to_name\": true,\n    \"exact_match_boost\": 100.0\n  }\n}\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#component_typesjson","title":"component_types.json","text":"<p>Location: <code>app/config/component_types.json</code></p> <pre><code>{\n  \"power_source\": {\n    \"neo4j_label\": \"PowerSource\",\n    \"category\": \"PowerSource\",\n    \"lucene_score_threshold_percent\": 25,\n    \"dependencies\": []\n  },\n  \"feeder\": {\n    \"neo4j_label\": \"Feeder\",\n    \"category\": \"Wire Feeders\",\n    \"lucene_score_threshold_percent\": 25,\n    \"dependencies\": [\"power_source\"]\n  },\n  \"cooler\": {\n    \"neo4j_label\": \"Cooler\",\n    \"category\": \"Coolers\",\n    \"lucene_score_threshold_percent\": 30,\n    \"dependencies\": [\"power_source\"]\n  }\n}\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#parameter_normalizationsjson","title":"parameter_normalizations.json","text":"<p>Location: <code>app/config/parameter_normalizations.json</code></p> <p>See \"Normalization Systems \u2192 Parameter Normalization\" section above for complete structure.</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#code-examples","title":"Code Examples","text":""},{"location":"SEARCH_STRATEGIES_AND_SCORING/#example-1-basic-search-with-cypherstrategy-only","title":"Example 1: Basic Search with CypherStrategy Only","text":"<pre><code>from app.services.search.orchestrator import SearchOrchestrator\nfrom app.services.search.strategies.cypher_strategy import CypherSearchStrategy\nfrom app.services.search.consolidator import ResultConsolidator\n\n# Initialize components\ncypher_strategy = CypherSearchStrategy(\n    config={\"enabled\": True, \"weight\": 1.0, \"max_priority\": 20},\n    product_search=product_search_service\n)\n\nconsolidator = ResultConsolidator(\n    strategy_weights={\"cypher\": 1.0},\n    exact_match_boost=100.0\n)\n\norchestrator = SearchOrchestrator(\n    strategies=[cypher_strategy],\n    consolidator=consolidator,\n    execution_mode=\"parallel\"\n)\n\n# Execute search\nresult = await orchestrator.search(\n    component_type=\"power_source\",\n    user_message=\"skip\",  # Proactive mode - Cypher only\n    master_parameters={},\n    selected_components={},\n    limit=10,\n    offset=0\n)\n\n# Access results\nproducts = result[\"products\"]\nscores = result[\"scores\"]\nmetadata = result[\"metadata\"]\nreport = result[\"consolidation_report\"]\n\nprint(f\"Found {len(products)} products\")\nprint(f\"Top product: {products[0]['name']} (score: {products[0]['score']:.2f})\")\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#example-2-multi-strategy-search-with-lucene","title":"Example 2: Multi-Strategy Search with Lucene","text":"<pre><code># Initialize both strategies\ncypher_strategy = CypherSearchStrategy(\n    config={\"enabled\": True, \"weight\": 0.4},\n    product_search=product_search_service\n)\n\nlucene_strategy = LuceneSearchStrategy(\n    config={\"enabled\": True, \"weight\": 0.6},\n    product_search=product_search_service\n)\n\nconsolidator = ResultConsolidator(\n    strategy_weights={\"cypher\": 0.4, \"lucene\": 0.6},\n    exact_match_boost=100.0\n)\n\norchestrator = SearchOrchestrator(\n    strategies=[cypher_strategy, lucene_strategy],\n    consolidator=consolidator,\n    execution_mode=\"parallel\",\n    timeout=30\n)\n\n# Execute search with user intent\nresult = await orchestrator.search(\n    component_type=\"power_source\",\n    user_message=\"I need a 500A MIG welder for aluminum\",\n    master_parameters={\n        \"power_source\": {\n            \"product_name\": \"Aristo 500ix\",\n            \"current_output\": \"500 A\",\n            \"process\": \"MIG\"\n        }\n    },\n    selected_components={},\n    limit=10\n)\n\n# Check consolidation report\nprint(f\"Strategies used: {result['metadata']['strategies_used']}\")\nprint(f\"Total results: {result['metadata']['total_results']}\")\nprint(f\"Multi-strategy products: {result['consolidation_report']['multi_strategy_products']}\")\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#example-3-compatibility-search-with-selected-components","title":"Example 3: Compatibility Search with Selected Components","text":"<pre><code># Search for feeders compatible with selected PowerSource\nresult = await orchestrator.search(\n    component_type=\"feeder\",\n    user_message=\"water-cooled feeder\",\n    master_parameters={\n        \"feeder\": {\n            \"cooling_type\": \"Water-cooled\"\n        }\n    },\n    selected_components={\n        \"PowerSource\": {\n            \"gin\": \"0446200880\",\n            \"name\": \"Aristo 500ix\",\n            \"category\": \"PowerSource\"\n        }\n    },\n    limit=10\n)\n\n# Results are automatically filtered by compatibility\nprint(f\"Compatible feeders: {len(result['products'])}\")\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#example-4-exact-match-boosting","title":"Example 4: Exact Match Boosting","text":"<pre><code># Search with exact product name match\nresult = await orchestrator.search(\n    component_type=\"power_source\",\n    user_message=\"Aristo 500ix\",\n    master_parameters={\n        \"power_source\": {\n            \"product_name\": \"Aristo 500ix\"  # Exact match target\n        }\n    },\n    selected_components={},\n    limit=10\n)\n\n# Check if exact match was boosted\ntop_product = result['products'][0]\nprint(f\"Top product: {top_product['name']}\")\nprint(f\"Score: {top_product['score']:.2f}\")\n\n# Score should be ~100x higher for exact match\n# Example: 0.65 \u2192 65.0\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#example-5-threshold-filtering","title":"Example 5: Threshold Filtering","text":"<pre><code># Search with component-specific threshold\nresult = await orchestrator.search(\n    component_type=\"cooler\",  # Coolers have 30% threshold\n    user_message=\"high capacity cooler\",\n    master_parameters={},\n    selected_components={\n        \"PowerSource\": {\"gin\": \"0446200880\", \"name\": \"Aristo 500ix\"}\n    },\n    limit=10\n)\n\n# Check consolidation report for filtering stats\nreport = result['consolidation_report']\nprint(f\"Total before filtering: {report['total_unique_products']}\")\nprint(f\"Score range: {report['score_statistics']['min']:.2f} - \"\n      f\"{report['score_statistics']['max']:.2f}\")\n</code></pre>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#related-documentation","title":"Related Documentation","text":"<ul> <li>Agent 2: ProductSearch - Neo4j product search service integration</li> <li>Orchestrator Architecture - StateByStateOrchestrator coordination</li> <li>Master Parameter JSON Architecture - Data models and schema</li> <li>API Documentation - REST API endpoints and flows</li> </ul>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#file-locations","title":"File Locations","text":"<p>Search Orchestration: - <code>src/backend/app/services/search/orchestrator.py</code> - Multi-strategy orchestrator - <code>src/backend/app/services/search/consolidator.py</code> - Result consolidation - <code>src/backend/app/services/search/strategies/base.py</code> - Abstract strategy interface</p> <p>Search Strategies: - <code>src/backend/app/services/search/strategies/cypher_strategy.py</code> - Graph-based search - <code>src/backend/app/services/search/strategies/lucene_strategy.py</code> - Full-text search - <code>src/backend/app/services/search/strategies/vector_strategy.py</code> - Semantic search (future)</p> <p>Query Building: - <code>src/backend/app/services/search/components/query_builder.py</code> - Cypher query construction - <code>src/backend/app/services/search/components/component_search.py</code> - Component-specific search</p> <p>Configuration: - <code>src/backend/app/config/search_config.json</code> - Search strategy configuration - <code>src/backend/app/config/component_types.json</code> - Component definitions - <code>src/backend/app/config/parameter_normalizations.json</code> - Normalization mappings</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#performance-metrics","title":"Performance Metrics","text":"<p>Typical Query Times: - Proactive mode (Cypher only): 50-100ms - User intent mode (Cypher + Lucene): 150-300ms - With exact match boosting: +10-20ms overhead - Parallel vs sequential: 40-60% faster in parallel</p> <p>Score Ranges: - Cypher: 0.1 - 1.0 (normalized) - Lucene: 0.1 - 20.0 (typical) - Consolidated: 0.0 - \u221e (depends on strategies) - After boosting: 0.0 - \u221e (exact matches ~100x)</p> <p>Filtering Impact: - Threshold filtering: Typically removes 10-40% of results - Compatibility filtering: Variable (depends on selected components) - Score threshold: Component-specific (25-30% default)</p>"},{"location":"SEARCH_STRATEGIES_AND_SCORING/#summary","title":"Summary","text":"<p>The ESAB Configurator's search system provides comprehensive, accurate product recommendations through:</p> <ol> <li>Multi-Strategy Architecture - Combines graph compatibility (Cypher) with full-text relevance (Lucene)</li> <li>Intelligent Orchestration - Context-aware strategy selection and parallel/sequential execution</li> <li>Advanced Query Building - Modular Cypher construction with comprehensive normalization</li> <li>Sophisticated Scoring - Priority-to-score conversion, weighted consolidation, exact match boosting</li> <li>Result Consolidation - Deduplication, score merging, threshold filtering</li> <li>Performance Optimization - Parallel execution, timeout protection, graceful fallback</li> </ol> <p>This architecture ensures users receive the most relevant products while maintaining fast response times and high reliability.</p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/","title":"Threshold Filtering Analysis - PowerSource Search Results","text":""},{"location":"THRESHOLD_FILTERING_ANALYSIS/#executive-summary","title":"Executive Summary","text":"<p>Issue: User questioned why only ONE PowerSource result (\"Warrior 400i CC/CV 380-415V\" with Score: 223.0) is displayed when the threshold is 80%.</p> <p>Root Cause: The 80% threshold is very aggressive and filters out most products. The naming is counter-intuitive: \"80% threshold\" actually means \"keep only products scoring above 20% of the top score\".</p> <p>Discovery: Neo4j Lucene search returns 6 PowerSource products, but threshold filtering reduces this to 1-4 products depending on score distribution.</p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#1-configuration","title":"1. Configuration","text":""},{"location":"THRESHOLD_FILTERING_ANALYSIS/#threshold-setting","title":"Threshold Setting","text":"<p>File: <code>src/backend/app/config/component_types.json</code> Path: <code>component_types.power_source.lucene_score_threshold_percent</code> Value: <code>80</code></p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#threshold-formula","title":"Threshold Formula","text":"<pre><code># consolidator.py lines 390-392\nmin_score = top_score * (1 - threshold_percent / 100.0)\n# If threshold_percent = 80:\n# min_score = top_score * (1 - 80/100) = top_score * 0.20\n</code></pre> <p>Counter-Intuitive Naming: - \u274c \"80% threshold\" suggests keeping products within 80% of top score - \u2705 Actually means: filter out products scoring below 20% of top score</p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#alternative-naming-interpretation","title":"Alternative Naming Interpretation","text":"<ul> <li><code>threshold_percent=80</code> \u2192 Strictness Level 80% \u2192 Keeps only top 20%</li> <li><code>threshold_percent=20</code> \u2192 Strictness Level 20% \u2192 Keeps top 80%</li> <li><code>threshold_percent=0</code> \u2192 No filtering \u2192 Keeps 100%</li> </ul>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#2-actual-search-results-from-neo4j","title":"2. Actual Search Results from Neo4j","text":""},{"location":"THRESHOLD_FILTERING_ANALYSIS/#search-example-1-030605","title":"Search Example 1 (03:06:05)","text":"<p>Query: User searched for Warrior/similar products</p> <p>PRE-THRESHOLD Results (6 products returned from Neo4j Lucene): <pre><code>1. Renegade ES 300i (CE) with cables (GIN: 0445250880) | Lucene: 13.75 | Consolidated: 13.75\n2. Renegade ES300i (GIN: 0445100880)                   | Lucene: 13.69 | Consolidated: 13.69\n3. Aristo 500ix CE, (380-460V) (GIN: 0446200880)       | Lucene: 10.11 | Consolidated: 10.11\n4. Aristo Mig U5000iw, WC CE (GIN: 0445400883)         | Lucene:  4.78 | Consolidated:  4.78\n5. Warrior 400i CC/CV 380 - 415V (GIN: 0465350884)     | Lucene:  2.52 | Consolidated:  2.52 \u274c\n6. Warrior 500i CC/CV 380 - 415V (GIN: 0465350883)     | Lucene:  2.46 | Consolidated:  2.46 \u274c\n</code></pre></p> <p>Threshold Filtering: - Top Score: 13.75 - Threshold: 80% - Minimum Score: 13.75 * 0.20 = 2.75 - Result: Kept 4/6 products (filtered out #5 and #6)</p> <p>FILTERED OUT (2 products below 2.75): <pre><code>\u274c Warrior 400i CC/CV 380 - 415V (GIN: 0465350884) | Score: 2.52 (&lt; 2.75)\n\u274c Warrior 500i CC/CV 380 - 415V (GIN: 0465350883) | Score: 2.46 (&lt; 2.75)\n</code></pre></p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#search-example-2-030636","title":"Search Example 2 (03:06:36)","text":"<p>Query: Different user search</p> <p>PRE-THRESHOLD Results (6 products): <pre><code>1. Aristo Mig U5000iw, WC CE (GIN: 0445400883)      | Lucene: 15.03 | Consolidated: 15.03\n2. Aristo 500ix CE, (380-460V) (GIN: 0446200880)    | Lucene:  4.37 | Consolidated:  4.37\n3. Renegade ES 300i (CE) with cables (GIN: 0445250880) | Lucene:  3.11 | Consolidated:  3.11\n4. Renegade ES300i (GIN: 0445100880)                | Lucene:  2.99 | Consolidated:  2.99 \u274c\n5. Warrior 400i CC/CV 380 - 415V (GIN: 0465350884)  | Lucene:  2.42 | Consolidated:  2.42 \u274c\n6. Warrior 500i CC/CV 380 - 415V (GIN: 0465350883)  | Lucene:  2.40 | Consolidated:  2.40 \u274c\n</code></pre></p> <p>Threshold Filtering: - Top Score: 15.03 - Threshold: 80% - Minimum Score: 15.03 * 0.20 = 3.01 - Result: Kept 3/6 products (filtered out #4, #5, #6)</p> <p>FILTERED OUT (3 products below 3.01): <pre><code>\u274c Renegade ES300i (GIN: 0445100880)               | Score: 2.99 (&lt; 3.01)\n\u274c Warrior 400i CC/CV 380 - 415V (GIN: 0465350884) | Score: 2.42 (&lt; 3.01)\n\u274c Warrior 500i CC/CV 380 - 415V (GIN: 0465350883) | Score: 2.40 (&lt; 3.01)\n</code></pre></p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#3-score-types-explained","title":"3. Score Types Explained","text":""},{"location":"THRESHOLD_FILTERING_ANALYSIS/#lucene-native-score-from-neo4j","title":"Lucene Native Score (from Neo4j)","text":"<ul> <li>Source: Neo4j fulltext index search</li> <li>Range: Typically 0.0 - 500.0+ (unbounded, higher = better match)</li> <li>Example: 223.0, 485.4 (as shown in user's screenshot)</li> <li>Storage: Stored in <code>product.specifications[\"lucene_score\"]</code></li> </ul>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#consolidated-score-after-resultconsolidator","title":"Consolidated Score (after ResultConsolidator)","text":"<ul> <li>Source: Weighted average from multiple search strategies</li> <li>Range: Typically 0.0 - 20.0 (for single-strategy searches, equals Lucene score normalized)</li> <li>Example: 13.75, 10.11, 2.52</li> <li>Usage: Used for threshold filtering and sorting</li> </ul>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#score-display-in-frontend","title":"Score Display in Frontend","text":"<ul> <li>Format: <code>\"Product Name (Score: X.X)\"</code></li> <li>Source: <code>consolidator._append_scores_to_names()</code> appends consolidated score to product name</li> <li>Example: <code>\"Warrior 400i CC/CV 380 - 415V (Score: 2.5)\"</code></li> </ul>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#4-why-user-sees-only-one-result","title":"4. Why User Sees Only ONE Result","text":""},{"location":"THRESHOLD_FILTERING_ANALYSIS/#users-screenshot-analysis","title":"User's Screenshot Analysis","text":"<p>Product Displayed: <code>\"Warrior 400i CC/CV 380-415V (Score: 223.0) (GIN: 0465350884)\"</code></p> <p>\u2705 ROOT CAUSE DISCOVERED (November 17, 2025 investigation):</p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#exact-match-boosting-100x-multiplier","title":"Exact Match Boosting (100x Multiplier)","text":"<ul> <li>User's search query closely matched product name (e.g., \"warrior 400i cc/cv\")</li> <li>Consolidator applies 100x boost for exact matches to prioritize relevant results</li> <li>Actual flow:</li> <li>Neo4j Lucene score: 2.23 (raw score)</li> <li>Exact match detected: \"warrior 400i cc/cv\" \u2192 Product name match</li> <li>100x boost applied: 2.23 \u00d7 100 = 222.96</li> <li>Formatted with 1 decimal place: 223.0 (displayed score)</li> <li>Threshold calculation: min_score = 222.96 \u00d7 0.20 = 44.59</li> <li>Other products (e.g., Warrior 500i with score 2.52) filtered out (&lt; 44.59)</li> </ul> <p>Backend Log Evidence (timestamp 03:02:23): <pre><code>\u2728 BOOSTED: 'Warrior 400i CC/CV 380 - 415V' (GIN: 0465350884)\n| Matched: 'warrior 400i cc/cv' (space-insensitive)\n| Score: 2.2296 \u2192 222.9562 (100x)\n\n\ud83d\udd0d THRESHOLD: Filtered 1 products below threshold\n| Top Score: 222.96 | Threshold: 80% | Min Score: 44.59 | Kept: 1/2\n\n\u274c FILTERED OUT (1 products):\n   1. Warrior 500i CC/CV 380 - 415V (GIN: 0465350883) | Score: 2.52 (&lt; 44.59)\n</code></pre></p> <p>Conclusion: - \u2705 No frontend/backend discrepancy - score display is working correctly - \u2705 100x boost is intentional feature for exact product name matches - \u26a0\ufe0f Side effect: When boost is applied, 80% threshold becomes even more aggressive   - Without boost: min_score = 2.52 \u00d7 0.20 = 0.50 (would keep most products)   - With boost: min_score = 222.96 \u00d7 0.20 = 44.59 (filters out all non-boosted products)</p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#5-search-flow-architecture","title":"5. Search Flow Architecture","text":""},{"location":"THRESHOLD_FILTERING_ANALYSIS/#complete-data-flow","title":"Complete Data Flow","text":"<pre><code>User Query: \"Warrior\"\n    \u2193\nSearchOrchestrator.search()\n    \u2193\nLuceneStrategy.search()\n    \u2193\nComponentSearchService.search_with_lucene()\n    \u2193\nNeo4j Lucene Fulltext Query\n    \u2193\n\ud83d\udcca RAW RESULTS (6 products with Lucene scores: 13.75, 13.69, 10.11, 4.78, 2.52, 2.46)\n    \u2193\nResultConsolidator.consolidate()\n    \u2193\n\ud83d\udcca PRE-THRESHOLD (6 products with consolidated scores appended to names)\n    \u2193\nResultConsolidator._apply_score_threshold()\n    \u2193\n\ud83d\udd0d THRESHOLD FILTERING (Top: 13.75, Threshold: 80%, Min: 2.75)\n    \u2193\n\u2705 FINAL RESULTS (4 products: scores 13.75, 13.69, 10.11, 4.78)\n\u274c FILTERED OUT (2 products: scores 2.52, 2.46)\n    \u2193\nSearchOrchestrator returns to API\n    \u2193\nFrontend displays products\n</code></pre>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#6-threshold-impact-analysis","title":"6. Threshold Impact Analysis","text":""},{"location":"THRESHOLD_FILTERING_ANALYSIS/#current-configuration-80-threshold","title":"Current Configuration (80% threshold)","text":"<ul> <li>Extremely Aggressive: Filters out 33-50% of results</li> <li>Use Case: When you want ONLY the very best matches</li> <li>Trade-off: Users miss potentially relevant products</li> </ul>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#comparison-table","title":"Comparison Table","text":"Threshold % Min Score (if top=15.0) Products Kept Aggressiveness 0% 0.00 All (6/6) None 20% 12.00 3/6 Low 50% 7.50 3/6 Moderate 80% 3.00 3/6 Very High 90% 1.50 4/6 Extreme"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#7-recommendations","title":"7. Recommendations","text":""},{"location":"THRESHOLD_FILTERING_ANALYSIS/#option-1-lower-the-threshold-recommended","title":"Option 1: Lower the Threshold (Recommended)","text":"<p>Change: <code>lucene_score_threshold_percent: 80</code> \u2192 <code>25</code> (default)</p> <p>Impact: - Top Score: 15.03, Threshold: 25%, Min Score: 11.27 - Would keep products scoring 11.27+ (top 75%) - Result: 1-2 products instead of 3-6</p> <p>Better Balance: Shows high-quality matches without being overly restrictive</p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#option-2-remove-threshold-completely","title":"Option 2: Remove Threshold Completely","text":"<p>Change: <code>lucene_score_threshold_percent: 0</code></p> <p>Impact: - Shows ALL Neo4j search results (6 products) - Users see full range of options - May include lower-relevance products</p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#option-3-implement-dynamic-threshold","title":"Option 3: Implement Dynamic Threshold","text":"<p>Logic: Adjust threshold based on result count <pre><code>if result_count &lt;= 3:\n    threshold = 0  # Show all results\nelif result_count &lt;= 10:\n    threshold = 50  # Moderate filtering\nelse:\n    threshold = 80  # Aggressive filtering for large result sets\n</code></pre></p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#option-4-add-threshold-explanation-to-frontend","title":"Option 4: Add Threshold Explanation to Frontend","text":"<p>UI Enhancement: Show filtered count <pre><code>\"Showing 4 of 6 PowerSources (2 filtered by relevance threshold)\"\n[Show all results] button\n</code></pre></p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#8-frontend-score-display-investigation","title":"8. Frontend Score Display Investigation","text":""},{"location":"THRESHOLD_FILTERING_ANALYSIS/#current-issue","title":"Current Issue","text":"<p>Screenshot shows: <code>\"Warrior 400i (Score: 223.0)\"</code> Backend logs show: Consolidated score = 2.52</p> <p>Hypothesis: Frontend may be displaying Lucene native score instead of consolidated score</p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#investigation-needed","title":"Investigation Needed","text":"<ol> <li>Check frontend code: How is score extracted and displayed?</li> <li>Check API response: Which score field is being sent?</li> <li>Verify consolidator: Is <code>_append_scores_to_names()</code> working correctly?</li> </ol>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#files-to-check","title":"Files to Check","text":"<ul> <li><code>src/frontend/common.js</code> - Product card rendering</li> <li><code>src/frontend/index.html</code> - Score display logic</li> <li><code>src/backend/app/services/search/consolidator.py</code> - Score appending (line 312-340)</li> </ul>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#9-configuration-files-reference","title":"9. Configuration Files Reference","text":""},{"location":"THRESHOLD_FILTERING_ANALYSIS/#threshold-configuration","title":"Threshold Configuration","text":"<p>File: <code>src/backend/app/config/component_types.json</code> Location: Lines ~50-60 in power_source definition <pre><code>\"power_source\": {\n  \"lucene_score_threshold_percent\": 80,\n  \"lucene_min_score\": 0.5,\n  ...\n}\n</code></pre></p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#filtering-logic","title":"Filtering Logic","text":"<p>File: <code>src/backend/app/services/search/consolidator.py</code> Method: <code>_apply_score_threshold()</code> (lines 341-429)</p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#debug-logging","title":"Debug Logging","text":"<p>File: <code>src/backend/server.log</code> Search for: - <code>\ud83d\udcca PRE-THRESHOLD</code> - Shows all products before filtering - <code>\ud83d\udd0d THRESHOLD</code> - Shows threshold calculation and filtering summary - <code>\u274c FILTERED OUT</code> - Lists products that were removed</p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#10-testing-commands","title":"10. Testing Commands","text":""},{"location":"THRESHOLD_FILTERING_ANALYSIS/#view-live-threshold-filtering","title":"View Live Threshold Filtering","text":"<pre><code># Monitor server logs for threshold filtering\ntail -f /Users/bharath/Desktop/Ayna_ESAB_Nov7/src/backend/server.log | grep -E \"(PRE-THRESHOLD|THRESHOLD|FILTERED)\"\n</code></pre>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#test-different-thresholds","title":"Test Different Thresholds","text":"<pre><code># Edit configuration\nnano /Users/bharath/Desktop/Ayna_ESAB_Nov7/src/backend/app/config/component_types.json\n\n# Change lucene_score_threshold_percent for power_source:\n# 80 \u2192 25 (moderate)\n# 80 \u2192 0 (no filtering)\n\n# Restart server to apply changes\n# Server auto-reloads with --reload flag\n</code></pre>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#debug-score-display","title":"Debug Score Display","text":"<pre><code># Check what scores are in API responses\ncurl -X POST http://localhost:8000/api/v1/configurator/message \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"message\": \"Warrior\", \"language\": \"en\"}' | python -m json.tool | grep -A 10 \"products\"\n</code></pre>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#11-summary","title":"11. Summary","text":"<p>\u2705 What's Working: - Neo4j Lucene search returns 6 PowerSource products - Threshold filtering is functioning as designed - Debug logging provides complete visibility</p> <p>\u26a0\ufe0f Current Behavior: - 80% threshold is very aggressive (keeps products scoring &gt; 20% of top) - Filters out 2-3 products (33-50% of results) - User sees only 1-4 products instead of all 6</p> <p>\ud83d\udd27 Recommended Action: - Lower threshold to 25% (default) for better user experience - Add \"Show all results\" option in frontend - Investigate score display discrepancy (223.0 vs 2.52)</p> <p>\ud83d\udcca Impact: - More products visible to users - Better balance between relevance and choice - Reduced confusion about \"missing\" products</p>"},{"location":"THRESHOLD_FILTERING_ANALYSIS/#status","title":"Status","text":"<p>\ud83d\udcc5 Date: November 17, 2025 \u2705 Investigation: Complete \ud83d\udccb Next Steps: Decide on threshold adjustment or UI enhancement</p>"},{"location":"operations/deployment-sizing-guide/","title":"Deployment and Operations Sizing Guide","text":"<p>ESAB Welding Equipment Configurator (Recommender_v2)</p> <p>This guide provides infrastructure sizing recommendations, deployment architecture, and operational procedures for production deployment.</p>"},{"location":"operations/deployment-sizing-guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Infrastructure Sizing</li> <li>Deployment Architecture</li> <li>Database Sizing and Configuration</li> <li>Server Specifications</li> <li>Network Architecture</li> <li>Deployment Procedures</li> <li>Monitoring and Observability</li> <li>Backup and Recovery</li> <li>Scaling Strategy</li> <li>Cost Optimization</li> <li>Security Hardening</li> <li>Maintenance Procedures</li> </ul>"},{"location":"operations/deployment-sizing-guide/#infrastructure-sizing","title":"Infrastructure Sizing","text":""},{"location":"operations/deployment-sizing-guide/#target-load-profile","title":"Target Load Profile","text":"<p>Baseline Requirements: - Concurrent Users: 10 active users - PostgreSQL Data: ~1 GB (session archives, logs, analytics) - Neo4j Data: 2-3 GB (product catalog, compatibility graph) - Expected Growth: 20% annually - Geographic Distribution: Single region deployment - Availability SLA: 99.5% (43.8 hours downtime/year)</p>"},{"location":"operations/deployment-sizing-guide/#performance-targets","title":"Performance Targets","text":"Metric Target Measurement API Response Time (p50) &lt; 200ms Median response time API Response Time (p95) &lt; 500ms 95<sup>th</sup> percentile API Response Time (p99) &lt; 1000ms 99<sup>th</sup> percentile Concurrent Sessions 10-15 Peak concurrent users Session Duration 5-15 min Average session length Database Query Time &lt; 100ms Neo4j compatibility queries LLM Response Time &lt; 2000ms OpenAI API calls Uptime 99.5% Monthly availability"},{"location":"operations/deployment-sizing-guide/#deployment-architecture","title":"Deployment Architecture","text":""},{"location":"operations/deployment-sizing-guide/#recommended-architecture-single-server","title":"Recommended Architecture (Single-Server)","text":"<p>For 10 concurrent users, single-server deployment is optimal:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Application Server                      \u2502\n\u2502                   (Ubuntu 22.04 LTS VM)                     \u2502\n\u2502                                                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502   Backend    \u2502  \u2502   Frontend   \u2502  \u2502    Redis     \u2502    \u2502\n\u2502  \u2502   (Port      \u2502  \u2502   (Port      \u2502  \u2502   (Port      \u2502    \u2502\n\u2502  \u2502    8000)     \u2502  \u2502    8080)     \u2502  \u2502    6379)     \u2502    \u2502\n\u2502  \u2502              \u2502  \u2502              \u2502  \u2502              \u2502    \u2502\n\u2502  \u2502  4 Workers   \u2502  \u2502   Nginx      \u2502  \u2502  256MB RAM   \u2502    \u2502\n\u2502  \u2502  4GB RAM     \u2502  \u2502   Static     \u2502  \u2502              \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502            PostgreSQL 14                          \u2502     \u2502\n\u2502  \u2502            (Port 5432)                            \u2502     \u2502\n\u2502  \u2502            2GB Storage, 1GB RAM                   \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Neo4j Aura (Cloud)                        \u2502\n\u2502                   OR                                         \u2502\n\u2502              Neo4j Community (Self-hosted)                  \u2502\n\u2502                                                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502            Neo4j Graph Database                   \u2502     \u2502\n\u2502  \u2502            Ports: 7474 (HTTP), 7687 (Bolt)       \u2502     \u2502\n\u2502  \u2502            4GB Storage, 2GB RAM                   \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n                            \u25bc\n                    External Services\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  OpenAI API (GPT-4)     \u2502   LangSmith (Optional)            \u2502\n\u2502  - Parameter Extraction  \u2502   - Observability                 \u2502\n\u2502  - Translation          \u2502   - Tracing                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#alternative-high-availability-architecture","title":"Alternative: High-Availability Architecture","text":"<p>For critical production (99.9% SLA, &gt; 25 concurrent users):</p> <pre><code>                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502 Load Balancer \u2502\n                        \u2502  (Nginx/HAProxy) \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                \u2502               \u2502               \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 App Server \u2502  \u2502 App Server \u2502 \u2502 App Server \u2502\n         \u2502     #1     \u2502  \u2502     #2     \u2502 \u2502     #3     \u2502\n         \u2502  (Active)  \u2502  \u2502  (Active)  \u2502 \u2502  (Standby) \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502               \u2502               \u2502\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502 Redis Cluster \u2502\n                        \u2502  (3 nodes)    \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                \u2502               \u2502               \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 PostgreSQL \u2502  \u2502   Neo4j    \u2502 \u2502   Backup   \u2502\n         \u2502  Primary   \u2502  \u2502   Cluster  \u2502 \u2502   Storage  \u2502\n         \u2502            \u2502  \u2502  (3 nodes) \u2502 \u2502            \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#database-sizing-and-configuration","title":"Database Sizing and Configuration","text":""},{"location":"operations/deployment-sizing-guide/#postgresql-configuration","title":"PostgreSQL Configuration","text":"<p>Database Size: ~1 GB (session archives, logs, analytics)</p>"},{"location":"operations/deployment-sizing-guide/#server-specifications","title":"Server Specifications","text":"<pre><code>PostgreSQL Version: 14.x or higher\nStorage:\n  Initial: 10 GB (10x data size for growth)\n  IOPS: 3000 (General Purpose SSD)\n  Type: SSD (gp3 on AWS, Premium SSD on Azure)\n\nMemory Allocation:\n  shared_buffers: 256 MB (25% of dedicated RAM)\n  effective_cache_size: 768 MB (75% of dedicated RAM)\n  work_mem: 16 MB\n  maintenance_work_mem: 128 MB\n\nConnections:\n  max_connections: 50 (10 users \u00d7 3 connections \u00d7 safety factor)\n  connection_pooling: PgBouncer (optional for &gt; 20 users)\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#recommended-postgresqlconf-settings","title":"Recommended postgresql.conf Settings","text":"<pre><code># Memory Configuration\nshared_buffers = 256MB              # 25% of 1GB RAM\neffective_cache_size = 768MB        # 75% of 1GB RAM\nwork_mem = 16MB                     # Per operation memory\nmaintenance_work_mem = 128MB        # VACUUM, CREATE INDEX\n\n# Connection Settings\nmax_connections = 50                # 10 users \u00d7 3 \u00d7 safety\nmax_prepared_transactions = 50      # Match max_connections\n\n# Write-Ahead Log (WAL)\nwal_buffers = 8MB\ncheckpoint_completion_target = 0.9\ncheckpoint_timeout = 10min\nmax_wal_size = 2GB\nmin_wal_size = 512MB\n\n# Query Planner\nrandom_page_cost = 1.1              # For SSD storage\neffective_io_concurrency = 200      # For SSD storage\n\n# Autovacuum (keep database healthy)\nautovacuum = on\nautovacuum_max_workers = 3\nautovacuum_naptime = 1min\n\n# Logging\nlog_destination = 'stderr'\nlogging_collector = on\nlog_directory = 'log'\nlog_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'\nlog_rotation_age = 1d\nlog_rotation_size = 100MB\nlog_min_duration_statement = 500    # Log slow queries (&gt; 500ms)\nlog_line_prefix = '%t [%p]: user=%u,db=%d,app=%a,client=%h '\nlog_checkpoints = on\nlog_connections = on\nlog_disconnections = on\nlog_lock_waits = on\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#database-schema","title":"Database Schema","text":"<p>Table: archived_sessions</p> <pre><code>CREATE TABLE archived_sessions (\n    id SERIAL PRIMARY KEY,\n    session_id VARCHAR(255) UNIQUE NOT NULL,\n    user_id VARCHAR(255) NOT NULL,\n    conversation_state JSONB NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    archived_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Indexes for performance\nCREATE INDEX idx_archived_sessions_user_id ON archived_sessions(user_id);\nCREATE INDEX idx_archived_sessions_created_at ON archived_sessions(created_at);\nCREATE INDEX idx_archived_sessions_session_id ON archived_sessions(session_id);\n\n-- GIN index for JSONB queries (if needed)\nCREATE INDEX idx_archived_sessions_state ON archived_sessions USING GIN (conversation_state);\n</code></pre> <p>Estimated Row Size: ~5 KB per session Estimated Rows: 200,000 sessions = ~1 GB</p>"},{"location":"operations/deployment-sizing-guide/#backup-configuration","title":"Backup Configuration","text":"<pre><code># Daily full backup (retention: 7 days)\npg_dump -U postgres -Fc pconfig &gt; /backup/pconfig_$(date +%Y%m%d).dump\n\n# Point-in-time recovery (archive WAL files)\narchive_mode = on\narchive_command = 'cp %p /backup/wal/%f'\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#neo4j-configuration","title":"Neo4j Configuration","text":"<p>Database Size: 2-3 GB (product catalog, compatibility relationships)</p>"},{"location":"operations/deployment-sizing-guide/#server-specifications_1","title":"Server Specifications","text":"<pre><code>Neo4j Version: 5.14.1 Community Edition (or Aura Professional)\nStorage:\n  Initial: 15 GB (5x data size for indexes + growth)\n  IOPS: 3000 (General Purpose SSD)\n  Type: SSD (mandatory for Neo4j performance)\n\nMemory Allocation:\n  Heap Memory (dbms.memory.heap.max_size): 1 GB\n  Page Cache (dbms.memory.pagecache.size): 1 GB\n  Total RAM Required: 2 GB dedicated\n\nJava Version: OpenJDK 17 (recommended)\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#recommended-neo4jconf-settings","title":"Recommended neo4j.conf Settings","text":"<pre><code># Memory Configuration\ndbms.memory.heap.initial_size=512m\ndbms.memory.heap.max_size=1g\ndbms.memory.pagecache.size=1g\n\n# Transaction Configuration\ndbms.transaction.timeout=60s\ndbms.lock.acquisition.timeout=60s\n\n# Query Configuration\ndbms.transaction.concurrent.maximum=100\ndb.transaction.bookmark_ready_timeout=30s\n\n# Security\ndbms.security.auth_enabled=true\ndbms.connector.bolt.enabled=true\ndbms.connector.http.enabled=true\n\n# Network Connectors\ndbms.connector.bolt.listen_address=0.0.0.0:7687\ndbms.connector.http.listen_address=0.0.0.0:7474\n\n# Performance\ndbms.cypher.parallel_runtime_support=all\ndbms.cypher.min_replan_interval=10s\n\n# Logging\ndbms.logs.query.enabled=true\ndbms.logs.query.threshold=1s          # Log queries &gt; 1 second\ndbms.logs.query.parameter_logging_enabled=true\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#graph-schema","title":"Graph Schema","text":"<p>Node Labels: - <code>PowerSource</code> (~50 nodes) - <code>Feeder</code> (~40 nodes) - <code>Cooler</code> (~30 nodes) - <code>Interconnector</code> (~25 nodes) - <code>Torch</code> (~60 nodes) - <code>Accessory</code> (~500 nodes)</p> <p>Total Nodes: ~705 nodes</p> <p>Relationships: - <code>COMPATIBLE_WITH</code> (~5,000 relationships) - Average degree: ~14 relationships per node</p> <p>Estimated Graph Size: 2.5 GB (nodes + relationships + indexes)</p>"},{"location":"operations/deployment-sizing-guide/#performance-indexes","title":"Performance Indexes","text":"<pre><code>-- Primary key indexes (created automatically with constraints)\nCREATE CONSTRAINT power_source_gin IF NOT EXISTS\nFOR (ps:PowerSource) REQUIRE ps.gin IS UNIQUE;\n\nCREATE CONSTRAINT feeder_gin IF NOT EXISTS\nFOR (f:Feeder) REQUIRE f.gin IS UNIQUE;\n\nCREATE CONSTRAINT cooler_gin IF NOT EXISTS\nFOR (c:Cooler) REQUIRE c.gin IS UNIQUE;\n\nCREATE CONSTRAINT interconnector_gin IF NOT EXISTS\nFOR (i:Interconnector) REQUIRE i.gin IS UNIQUE;\n\nCREATE CONSTRAINT torch_gin IF NOT EXISTS\nFOR (t:Torch) REQUIRE t.gin IS UNIQUE;\n\nCREATE CONSTRAINT accessory_gin IF NOT EXISTS\nFOR (a:Accessory) REQUIRE a.gin IS UNIQUE;\n\n-- Composite indexes for search performance\nCREATE INDEX power_source_search IF NOT EXISTS\nFOR (ps:PowerSource) ON (ps.category, ps.current_output);\n\nCREATE INDEX feeder_search IF NOT EXISTS\nFOR (f:Feeder) ON (f.category, f.cooling_type);\n\nCREATE INDEX accessory_search IF NOT EXISTS\nFOR (a:Accessory) ON (a.category, a.accessory_category);\n\n-- Full-text search indexes\nCALL db.index.fulltext.createNodeIndex(\n  'productNameSearch',\n  ['PowerSource', 'Feeder', 'Cooler', 'Interconnector', 'Torch', 'Accessory'],\n  ['item_name', 'description_catalogue']\n);\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#backup-configuration_1","title":"Backup Configuration","text":"<p>Neo4j Community Edition (Self-hosted):</p> <pre><code># Daily full backup (retention: 7 days)\nneo4j-admin database dump neo4j --to=/backup/neo4j_$(date +%Y%m%d).dump\n\n# Incremental backup (requires Enterprise Edition)\n# Not available in Community Edition\n</code></pre> <p>Neo4j Aura (Cloud): - Automatic daily backups (retention: 7 days) - Point-in-time recovery available - Managed by Neo4j Aura</p>"},{"location":"operations/deployment-sizing-guide/#redis-configuration","title":"Redis Configuration","text":"<p>Memory Size: 256 MB (session storage, product cache)</p>"},{"location":"operations/deployment-sizing-guide/#server-specifications_2","title":"Server Specifications","text":"<pre><code>Redis Version: 7.0.x or higher\nMemory:\n  maxmemory: 256mb\n  maxmemory-policy: allkeys-lru  # Evict least recently used keys\n\nPersistence:\n  RDB Snapshots: Disabled (session data is transient)\n  AOF (Append-Only File): Enabled (for safety)\n  AOF Rewrite: Auto\n\nConnections:\n  maxclients: 50                    # 10 users \u00d7 3 \u00d7 safety factor\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#recommended-redisconf-settings","title":"Recommended redis.conf Settings","text":"<pre><code># Memory Management\nmaxmemory 256mb\nmaxmemory-policy allkeys-lru        # Evict least recently used keys\n\n# Persistence (for session safety)\nappendonly yes\nappendfilename \"appendonly.aof\"\nappendfsync everysec                # Balance between safety and performance\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n# Disable RDB snapshots (not needed for session data)\nsave \"\"\n\n# Connection Settings\nmaxclients 50\ntimeout 300                         # Close idle connections after 5 min\ntcp-keepalive 60\n\n# Security\nrequirepass &lt;strong_password&gt;       # Set strong password\nprotected-mode yes\nbind 127.0.0.1                      # Bind to localhost only\n\n# Logging\nloglevel notice\nlogfile \"/var/log/redis/redis-server.log\"\n\n# Performance\nslowlog-log-slower-than 10000       # Log queries &gt; 10ms\nslowlog-max-len 128\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#session-ttl-configuration","title":"Session TTL Configuration","text":"<pre><code># src/backend/app/main.py\nCACHE_TTL = 3600  # 1 hour session timeout\n\n# Estimated session size: ~10 KB per session\n# Memory usage: 10 concurrent sessions \u00d7 10 KB = 100 KB\n# Safety margin: 256 MB allows for 25,600 sessions\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#server-specifications_3","title":"Server Specifications","text":""},{"location":"operations/deployment-sizing-guide/#application-server-single-server-deployment","title":"Application Server (Single-Server Deployment)","text":"<p>Recommended Configuration for 10 Concurrent Users:</p> Component Specification Justification Operating System Ubuntu 22.04 LTS Long-term support, stability vCPUs 4 cores 4 Uvicorn workers + background tasks RAM 8 GB Backend (4GB) + PostgreSQL (1GB) + Redis (256MB) + OS (2GB) + Buffer (1GB) Storage 50 GB SSD OS (10GB) + Logs (5GB) + PostgreSQL (10GB) + Backups (20GB) + Buffer (5GB) Network 1 Gbps Sufficient for 10 concurrent users IOPS 3000 General Purpose SSD performance"},{"location":"operations/deployment-sizing-guide/#cloud-provider-equivalents","title":"Cloud Provider Equivalents","text":"<p>AWS EC2: - Instance Type: <code>t3.medium</code> or <code>t3a.medium</code> - vCPUs: 2 vCPUs (4 threads with hyperthreading) - RAM: 4 GB (upgrade to <code>t3.large</code> with 8GB for production) - Storage: 50 GB gp3 SSD (3000 IOPS) - Estimated Cost: $30-50/month</p> <p>Recommended: <code>t3.large</code> (2 vCPU, 8GB RAM) for production stability</p> <p>Azure Virtual Machines: - Instance Type: <code>Standard_B2s</code> or <code>Standard_D2s_v3</code> - vCPUs: 2 vCPUs - RAM: 4-8 GB (choose <code>D2s_v3</code> with 8GB) - Storage: 50 GB Premium SSD (P10) - Estimated Cost: $40-60/month</p> <p>Recommended: <code>Standard_D2s_v3</code> (2 vCPU, 8GB RAM)</p> <p>Google Cloud Compute Engine: - Instance Type: <code>e2-standard-2</code> - vCPUs: 2 vCPUs - RAM: 8 GB - Storage: 50 GB SSD persistent disk - Estimated Cost: $35-55/month</p>"},{"location":"operations/deployment-sizing-guide/#on-premises-server","title":"On-Premises Server","text":"<p>Minimum Specifications: - CPU: Intel Xeon E3 or AMD Ryzen 5 (4 cores, 3.0+ GHz) - RAM: 8 GB DDR4 - Storage: 250 GB SSD (or 2\u00d7 500 GB in RAID 1) - Network: 1 Gbps Ethernet - Power: Redundant PSU (optional for HA)</p>"},{"location":"operations/deployment-sizing-guide/#neo4j-server-separate-server-recommended","title":"Neo4j Server (Separate Server Recommended)","text":"<p>Option 1: Neo4j Aura (Managed Cloud - Recommended)</p> Tier Specification Cost Use Case Aura Professional 2GB RAM, 8GB Storage ~$65/month Production (10 users) Aura Enterprise 4GB RAM, 16GB Storage ~$200/month High Availability (25+ users) <p>Advantages: - \u2705 Fully managed (automatic backups, updates, scaling) - \u2705 Built-in monitoring and alerting - \u2705 99.95% SLA (Enterprise tier) - \u2705 No server maintenance required</p> <p>Option 2: Self-Hosted Neo4j Community Edition</p> Component Specification Justification Operating System Ubuntu 22.04 LTS Recommended by Neo4j vCPUs 2 cores Graph database queries RAM 4 GB 1GB heap + 1GB page cache + 2GB OS Storage 20 GB SSD 3GB data + 5GB indexes + 10GB growth + 2GB logs Java OpenJDK 17 Required for Neo4j 5.x <p>Cloud Provider Equivalents: - AWS: <code>t3.medium</code> (2 vCPU, 4GB RAM) - $30/month - Azure: <code>Standard_B2s</code> (2 vCPU, 4GB RAM) - $35/month - GCP: <code>e2-medium</code> (2 vCPU, 4GB RAM) - $25/month</p> <p>Note: Neo4j Aura is recommended for production to avoid operational overhead.</p>"},{"location":"operations/deployment-sizing-guide/#network-architecture","title":"Network Architecture","text":""},{"location":"operations/deployment-sizing-guide/#firewall-configuration","title":"Firewall Configuration","text":"<p>Application Server (Ports to Open):</p> <pre><code># Inbound Rules\nPort 22    (SSH)         - Admin access only (restrict by IP)\nPort 8000  (Backend API) - Public or internal network\nPort 8080  (Frontend)    - Public access\nPort 6379  (Redis)       - Localhost only (block external)\nPort 5432  (PostgreSQL)  - Localhost only (block external)\n\n# Outbound Rules\nPort 443   (HTTPS)       - OpenAI API, LangSmith, package updates\nPort 7687  (Bolt)        - Neo4j connection (if external)\nPort 7474  (HTTP)        - Neo4j Browser (if external)\n</code></pre> <p>UFW Firewall Rules (Ubuntu):</p> <pre><code># Enable UFW\nsudo ufw enable\n\n# SSH (admin only - replace with your IP)\nsudo ufw allow from &lt;ADMIN_IP&gt; to any port 22\n\n# Application ports (public)\nsudo ufw allow 8000/tcp comment 'Backend API'\nsudo ufw allow 8080/tcp comment 'Frontend'\n\n# Block database ports from external access\nsudo ufw deny 6379/tcp comment 'Redis - localhost only'\nsudo ufw deny 5432/tcp comment 'PostgreSQL - localhost only'\n\n# Neo4j (if self-hosted on same server)\nsudo ufw deny 7474/tcp comment 'Neo4j HTTP - localhost only'\nsudo ufw deny 7687/tcp comment 'Neo4j Bolt - localhost only'\n\n# Allow outbound HTTPS\nsudo ufw allow out 443/tcp comment 'HTTPS outbound'\n\n# Check status\nsudo ufw status verbose\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#network-topology","title":"Network Topology","text":"<p>Single-Server Deployment:</p> <pre><code>Internet\n    \u2502\n    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Firewall / Security Group        \u2502\n\u2502  - Allow: 8000, 8080              \u2502\n\u2502  - Block: 5432, 6379, 7687        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Application Server               \u2502\n\u2502  (Private Network: 10.0.1.10)     \u2502\n\u2502                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  Backend + Frontend + DBs   \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Neo4j Aura (Cloud)               \u2502\n\u2502  - Encrypted Bolt connection      \u2502\n\u2502  - Managed firewall               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>High-Availability Deployment:</p> <pre><code>Internet\n    \u2502\n    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Load Balancer (Public)           \u2502\n\u2502  - HTTPS: 443 \u2192 8000              \u2502\n\u2502  - Health checks                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502               \u2502\n    \u25bc               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  App #1 \u2502   \u2502  App #2 \u2502\n\u2502 (Active)\u2502   \u2502 (Active)\u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n     \u2502             \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Private Network  \u2502\n    \u2502  (10.0.0.0/16)    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502               \u2502\n    \u25bc               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Redis  \u2502   \u2502PostgreSQL\u2502\n\u2502 Cluster \u2502   \u2502  Primary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#deployment-procedures","title":"Deployment Procedures","text":""},{"location":"operations/deployment-sizing-guide/#pre-deployment-checklist","title":"Pre-Deployment Checklist","text":"<pre><code># 1. Verify system requirements\npython --version          # Python 3.11+\njava -version             # OpenJDK 17 (for Neo4j)\npsql --version            # PostgreSQL 14+\nredis-server --version    # Redis 7.0+\n\n# 2. Create deployment directory\nsudo mkdir -p /opt/esab-recommender\nsudo chown $USER:$USER /opt/esab-recommender\ncd /opt/esab-recommender\n\n# 3. Clone repository\ngit clone &lt;repository_url&gt; .\n\n# 4. Create virtual environment\ncd src/backend\npython -m venv venv\nsource venv/bin/activate\n\n# 5. Install dependencies\npip install --upgrade pip\npip install -r requirements.txt\n\n# 6. Configure environment variables\ncp deployment/env/.env.production.example src/backend/.env\nnano src/backend/.env  # Edit with production values\n\n# 7. Initialize databases\n# PostgreSQL\nsudo -u postgres psql -c \"CREATE DATABASE pconfig;\"\nsudo -u postgres psql -c \"CREATE USER esab_user WITH PASSWORD '&lt;password&gt;';\"\nsudo -u postgres psql -c \"GRANT ALL PRIVILEGES ON DATABASE pconfig TO esab_user;\"\npsql -U esab_user -d pconfig -f deployment/database/postgres/init_schema.sql\n\n# Redis (already running, just verify)\nredis-cli ping  # Should return PONG\n\n# Neo4j (verify connection)\n# If using Aura: Test connection string from Aura console\n# If self-hosted: Start Neo4j service\ncypher-shell -u neo4j -p &lt;password&gt; \"RETURN 1;\"\n\n# 8. Run database migrations (if any)\n# cd src/backend\n# alembic upgrade head  # If using Alembic\n\n# 9. Test backend server\ncd src/backend\nuvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 1\n\n# Test health endpoint\ncurl http://localhost:8000/health\n\n# 10. Configure systemd services\nsudo cp deployment/systemd/esab-recommender.service /etc/systemd/system/\nsudo cp deployment/systemd/esab-recommender-frontend.service /etc/systemd/system/\nsudo systemctl daemon-reload\n\n# 11. Start services\nsudo systemctl start esab-recommender.target\nsudo systemctl enable esab-recommender.target\n\n# 12. Verify deployment\nsudo systemctl status esab-recommender.service\ncurl http://localhost:8000/health\ncurl http://localhost:8080  # Frontend\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#automated-deployment-script","title":"Automated Deployment Script","text":"<p>The repository includes an automated deployment script:</p> <pre><code># Run automated deployment\ncd deployment\nchmod +x deploy.sh\nsudo ./deploy.sh install\n\n# Deployment script handles:\n# - System dependencies\n# - Python environment\n# - Database initialization\n# - Systemd service setup\n# - Firewall configuration\n# - Log rotation\n</code></pre> <p>See deployment/README.md for detailed deployment instructions.</p>"},{"location":"operations/deployment-sizing-guide/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"operations/deployment-sizing-guide/#application-monitoring","title":"Application Monitoring","text":"<p>Metrics to Track:</p> Metric Tool Alert Threshold Action API Response Time (p95) Prometheus + Grafana &gt; 500ms Investigate slow queries Error Rate Application logs &gt; 1% Check error logs, rollback if needed Active Sessions Redis INFO &gt; 15 Scale up if sustained CPU Usage System metrics &gt; 80% Scale up or optimize Memory Usage System metrics &gt; 85% Increase RAM or optimize Disk Usage System metrics &gt; 80% Clean logs, expand storage Neo4j Query Time Neo4j logs &gt; 100ms Optimize Cypher queries PostgreSQL Connections pg_stat_activity &gt; 40 (of 50) Investigate connection leaks"},{"location":"operations/deployment-sizing-guide/#health-check-endpoint","title":"Health Check Endpoint","text":"<p>Endpoint: <code>GET /health</code></p> <p>Response Example:</p> <pre><code>{\n  \"status\": \"healthy\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"version\": \"2.0.0\",\n  \"components\": {\n    \"neo4j\": {\n      \"status\": \"healthy\",\n      \"response_time_ms\": 15\n    },\n    \"postgres\": {\n      \"status\": \"healthy\",\n      \"response_time_ms\": 8\n    },\n    \"redis\": {\n      \"status\": \"healthy\",\n      \"type\": \"redis\"\n    },\n    \"openai\": {\n      \"status\": \"healthy\"\n    }\n  }\n}\n</code></pre> <p>Monitoring Script:</p> <pre><code>#!/bin/bash\n# health-check.sh - Monitor application health\n\nAPI_URL=\"http://localhost:8000/health\"\nALERT_EMAIL=\"admin@example.com\"\n\n# Check health endpoint\nresponse=$(curl -s -o /dev/null -w \"%{http_code}\" $API_URL)\n\nif [ \"$response\" != \"200\" ]; then\n    echo \"ALERT: Health check failed (HTTP $response)\" | \\\n        mail -s \"ESAB Recommender Health Alert\" $ALERT_EMAIL\n    exit 1\nfi\n\n# Check individual components\nhealth_json=$(curl -s $API_URL)\nneo4j_status=$(echo $health_json | jq -r '.components.neo4j.status')\npostgres_status=$(echo $health_json | jq -r '.components.postgres.status')\nredis_status=$(echo $health_json | jq -r '.components.redis.status')\n\nif [ \"$neo4j_status\" != \"healthy\" ]; then\n    echo \"ALERT: Neo4j unhealthy\" | mail -s \"Neo4j Alert\" $ALERT_EMAIL\nfi\n\nif [ \"$postgres_status\" != \"healthy\" ]; then\n    echo \"ALERT: PostgreSQL unhealthy\" | mail -s \"PostgreSQL Alert\" $ALERT_EMAIL\nfi\n\nif [ \"$redis_status\" != \"healthy\" ]; then\n    echo \"ALERT: Redis unhealthy\" | mail -s \"Redis Alert\" $ALERT_EMAIL\nfi\n\nexit 0\n</code></pre> <p>Cron Job (check every 5 minutes):</p> <pre><code># Add to crontab\n*/5 * * * * /opt/esab-recommender/scripts/health-check.sh &gt;&gt; /var/log/health-check.log 2&gt;&amp;1\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#log-management","title":"Log Management","text":"<p>Log Files:</p> <pre><code># Application Logs\n/home/azureuser/esab_recommender-bh/logs/esab-recommender.log\n/home/azureuser/esab_recommender-bh/logs/esab-recommender-error.log\n\n# Systemd Journal\nsudo journalctl -u esab-recommender.service -f\n\n# PostgreSQL Logs\n/var/log/postgresql/postgresql-14-main.log\n\n# Neo4j Logs (self-hosted)\n/var/lib/neo4j/logs/neo4j.log\n/var/lib/neo4j/logs/query.log\n\n# Redis Logs\n/var/log/redis/redis-server.log\n\n# Nginx Logs (if used)\n/var/log/nginx/access.log\n/var/log/nginx/error.log\n</code></pre> <p>Log Rotation Configuration:</p> <pre><code># /etc/logrotate.d/esab-recommender\n\n/home/azureuser/esab_recommender-bh/logs/*.log {\n    daily\n    rotate 14\n    compress\n    delaycompress\n    notifempty\n    missingok\n    create 0640 azureuser azureuser\n    sharedscripts\n    postrotate\n        systemctl reload esab-recommender.service &gt; /dev/null 2&gt;&amp;1 || true\n    endscript\n}\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#performance-monitoring","title":"Performance Monitoring","text":"<p>Prometheus Metrics (Optional):</p> <pre><code># /etc/prometheus/prometheus.yml\n\nscrape_configs:\n  - job_name: 'esab-recommender'\n    static_configs:\n      - targets: ['localhost:8000']\n    metrics_path: '/metrics'\n    scrape_interval: 15s\n\n  - job_name: 'postgres'\n    static_configs:\n      - targets: ['localhost:9187']  # postgres_exporter\n\n  - job_name: 'redis'\n    static_configs:\n      - targets: ['localhost:9121']  # redis_exporter\n\n  - job_name: 'neo4j'\n    static_configs:\n      - targets: ['localhost:2004']  # Neo4j JMX exporter\n</code></pre> <p>Grafana Dashboards:</p> <ol> <li>Application Dashboard:</li> <li>Request rate, response time (p50, p95, p99)</li> <li>Error rate, active sessions</li> <li> <p>LLM API latency</p> </li> <li> <p>Database Dashboard:</p> </li> <li>PostgreSQL: Connections, query time, cache hit ratio</li> <li>Neo4j: Query time, heap usage, page cache</li> <li> <p>Redis: Memory usage, eviction rate, command rate</p> </li> <li> <p>System Dashboard:</p> </li> <li>CPU, memory, disk usage</li> <li>Network I/O</li> <li>Process count</li> </ol>"},{"location":"operations/deployment-sizing-guide/#backup-and-recovery","title":"Backup and Recovery","text":""},{"location":"operations/deployment-sizing-guide/#backup-strategy","title":"Backup Strategy","text":"<p>Backup Frequency:</p> Component Frequency Retention Method PostgreSQL Daily (3 AM) 7 days pg_dump Neo4j Aura Automatic 7 days Managed by Aura Neo4j Self-hosted Daily (3 AM) 7 days neo4j-admin dump Redis Not backed up N/A Session data is transient Application Code On deployment N/A Git repository Configuration Files Weekly 30 days File copy Logs Rotated daily 14 days logrotate"},{"location":"operations/deployment-sizing-guide/#postgresql-backup","title":"PostgreSQL Backup","text":"<p>Automated Backup Script:</p> <pre><code>#!/bin/bash\n# /opt/esab-recommender/scripts/backup-postgres.sh\n\nBACKUP_DIR=\"/backup/postgresql\"\nRETENTION_DAYS=7\nDB_NAME=\"pconfig\"\nDB_USER=\"postgres\"\n\n# Create backup directory\nmkdir -p $BACKUP_DIR\n\n# Generate backup filename\nBACKUP_FILE=\"$BACKUP_DIR/pconfig_$(date +%Y%m%d_%H%M%S).dump\"\n\n# Create backup\npg_dump -U $DB_USER -Fc -f $BACKUP_FILE $DB_NAME\n\n# Verify backup\nif [ $? -eq 0 ]; then\n    echo \"Backup successful: $BACKUP_FILE\"\n\n    # Delete old backups (older than retention period)\n    find $BACKUP_DIR -name \"pconfig_*.dump\" -mtime +$RETENTION_DAYS -delete\n\n    # Log backup size\n    du -h $BACKUP_FILE\nelse\n    echo \"Backup failed!\" | mail -s \"PostgreSQL Backup Failed\" admin@example.com\n    exit 1\nfi\n</code></pre> <p>Cron Job:</p> <pre><code># Add to crontab\n0 3 * * * /opt/esab-recommender/scripts/backup-postgres.sh &gt;&gt; /var/log/backup-postgres.log 2&gt;&amp;1\n</code></pre> <p>Restore Procedure:</p> <pre><code># List available backups\nls -lh /backup/postgresql/\n\n# Restore from backup\npg_restore -U postgres -d pconfig -c /backup/postgresql/pconfig_20240115_030000.dump\n\n# Verify restoration\npsql -U postgres -d pconfig -c \"SELECT COUNT(*) FROM archived_sessions;\"\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#neo4j-backup","title":"Neo4j Backup","text":"<p>Neo4j Aura (Managed): - Automatic daily backups (managed by Neo4j) - Point-in-time recovery available - Restore via Aura Console</p> <p>Neo4j Self-Hosted Backup:</p> <pre><code>#!/bin/bash\n# /opt/esab-recommender/scripts/backup-neo4j.sh\n\nBACKUP_DIR=\"/backup/neo4j\"\nRETENTION_DAYS=7\nNEO4J_HOME=\"/var/lib/neo4j\"\n\n# Stop Neo4j (for consistent backup)\nsudo systemctl stop neo4j\n\n# Create backup directory\nmkdir -p $BACKUP_DIR\n\n# Generate backup filename\nBACKUP_FILE=\"$BACKUP_DIR/neo4j_$(date +%Y%m%d_%H%M%S).dump\"\n\n# Create backup\nneo4j-admin database dump neo4j --to=$BACKUP_FILE\n\n# Start Neo4j\nsudo systemctl start neo4j\n\n# Verify backup\nif [ $? -eq 0 ]; then\n    echo \"Backup successful: $BACKUP_FILE\"\n\n    # Delete old backups\n    find $BACKUP_DIR -name \"neo4j_*.dump\" -mtime +$RETENTION_DAYS -delete\n\n    # Log backup size\n    du -h $BACKUP_FILE\nelse\n    echo \"Backup failed!\" | mail -s \"Neo4j Backup Failed\" admin@example.com\n    exit 1\nfi\n</code></pre> <p>Restore Procedure:</p> <pre><code># Stop Neo4j\nsudo systemctl stop neo4j\n\n# Load backup\nneo4j-admin database load neo4j --from=/backup/neo4j/neo4j_20240115_030000.dump --overwrite-destination\n\n# Start Neo4j\nsudo systemctl start neo4j\n\n# Verify restoration\ncypher-shell -u neo4j -p &lt;password&gt; \"MATCH (n) RETURN count(n);\"\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#disaster-recovery-plan","title":"Disaster Recovery Plan","text":"<p>Recovery Time Objective (RTO): 4 hours Recovery Point Objective (RPO): 24 hours (daily backups)</p> <p>Recovery Steps:</p> <ol> <li>Provision new server (30 minutes)</li> <li>Launch VM with same specifications</li> <li> <p>Install operating system and dependencies</p> </li> <li> <p>Restore application code (15 minutes)</p> </li> <li>Clone Git repository</li> <li>Install Python dependencies</li> <li> <p>Configure environment variables</p> </li> <li> <p>Restore PostgreSQL (1 hour)</p> </li> <li>Install PostgreSQL</li> <li>Restore latest backup</li> <li> <p>Verify data integrity</p> </li> <li> <p>Restore Neo4j (2 hours)</p> </li> <li>Option A: Connect to Neo4j Aura (no restore needed)</li> <li> <p>Option B: Restore Neo4j backup (if self-hosted)</p> </li> <li> <p>Configure and start services (30 minutes)</p> </li> <li>Configure systemd services</li> <li>Start application</li> <li> <p>Run health checks</p> </li> <li> <p>DNS/Load Balancer update (15 minutes)</p> </li> <li>Point domain to new server</li> <li>Verify public access</li> </ol> <p>Total Recovery Time: ~4 hours</p>"},{"location":"operations/deployment-sizing-guide/#scaling-strategy","title":"Scaling Strategy","text":""},{"location":"operations/deployment-sizing-guide/#vertical-scaling-scale-up","title":"Vertical Scaling (Scale Up)","text":"<p>When to Scale Up: - CPU usage consistently &gt; 80% - Memory usage consistently &gt; 85% - API response time (p95) &gt; 500ms - Active sessions &gt; 15 concurrent users</p> <p>Scaling Path:</p> Current Load Upgrade To Capacity t3.medium (2 vCPU, 4GB) 10 users t3.large (2 vCPU, 8GB) 20 users t3.large (2 vCPU, 8GB) 20 users t3.xlarge (4 vCPU, 16GB) 40 users t3.xlarge (4 vCPU, 16GB) 40 users t3.2xlarge (8 vCPU, 32GB) 80 users <p>PostgreSQL Scaling:</p> <pre><code>-- Increase connection pool as users grow\nmax_connections = 100           -- For 20+ users\nshared_buffers = 512MB          -- For 2GB RAM\neffective_cache_size = 1536MB   -- For 2GB RAM\n</code></pre> <p>Neo4j Scaling:</p> <pre><code># Increase heap and page cache\ndbms.memory.heap.max_size=2g      # For 4GB RAM\ndbms.memory.pagecache.size=2g     # For 4GB RAM\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#horizontal-scaling-scale-out","title":"Horizontal Scaling (Scale Out)","text":"<p>When to Scale Out: - &gt; 50 concurrent users - Geographic distribution required - High availability (99.9% SLA) needed</p> <p>Load Balancer Configuration:</p> <pre><code># /etc/nginx/nginx.conf\n\nupstream esab_backend {\n    least_conn;  # Route to server with fewest connections\n    server 10.0.1.10:8000;\n    server 10.0.1.11:8000;\n    server 10.0.1.12:8000 backup;  # Standby server\n}\n\nserver {\n    listen 80;\n    server_name api.esab.example.com;\n\n    location / {\n        proxy_pass http://esab_backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n        # Health check\n        proxy_next_upstream error timeout http_500 http_502 http_503;\n        proxy_connect_timeout 5s;\n    }\n}\n</code></pre> <p>Redis Cluster (for &gt; 50 users):</p> <pre><code># Setup Redis Cluster (3 masters + 3 replicas)\n# Ensures session persistence across multiple app servers\n\n# Master nodes\nredis-server --port 7000 --cluster-enabled yes\nredis-server --port 7001 --cluster-enabled yes\nredis-server --port 7002 --cluster-enabled yes\n\n# Create cluster\nredis-cli --cluster create \\\n    10.0.1.10:7000 10.0.1.11:7001 10.0.1.12:7002 \\\n    --cluster-replicas 1\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#cost-optimization","title":"Cost Optimization","text":""},{"location":"operations/deployment-sizing-guide/#monthly-cost-estimate-10-concurrent-users","title":"Monthly Cost Estimate (10 Concurrent Users)","text":"<p>Cloud Hosting (AWS):</p> Component Service Specification Cost/Month Application Server EC2 t3.large 2 vCPU, 8GB RAM, 50GB SSD $60 Neo4j Database Aura Professional 2GB RAM, 8GB Storage $65 PostgreSQL RDS db.t3.micro 1 vCPU, 1GB RAM, 20GB $15 Redis ElastiCache t3.micro 1 vCPU, 0.5GB RAM $12 Data Transfer Outbound ~100 GB/month $9 Backups S3 Standard 10 GB (7-day retention) $0.23 Load Balancer ALB (optional) Not needed for 10 users $0 Total ~$161/month <p>Cost-Saving Options:</p> <ol> <li>Self-Hosted Neo4j (saves $40/month):</li> <li>Use Neo4j Community Edition</li> <li>Run on same server as application</li> <li> <p>Total Cost: ~$121/month</p> </li> <li> <p>Reserved Instances (save 30-40%):</p> </li> <li>1-year commitment: ~$113/month</li> <li> <p>3-year commitment: ~$96/month</p> </li> <li> <p>Spot Instances (save 70%, with interruption risk):</p> </li> <li>Dev/Test environments only</li> <li>Not recommended for production</li> </ol> <p>Total Annual Cost (Estimate): - Production (AWS): 1,932/year (161/month) - With Reserved Instances: 1,356/year (113/month) - Self-Hosted Neo4j: 1,452/year (121/month)</p>"},{"location":"operations/deployment-sizing-guide/#on-premises-cost-estimate","title":"On-Premises Cost Estimate","text":"<p>Initial Hardware Investment:</p> Component Specification Cost Server Dell PowerEdge T340 (4 cores, 16GB RAM, 1TB SSD) $1,200 UPS APC Smart-UPS 1500VA $400 Networking Switch, cables, rack $200 Total Initial $1,800 <p>Recurring Costs: - Electricity: ~20/month (240/year) - Internet: ~50/month (600/year) - Maintenance: ~$100/year</p> <p>Total Annual Cost (On-Prem): - Year 1: $2,740 (includes hardware) - Year 2+: $940/year</p> <p>Break-Even Point: ~18 months</p>"},{"location":"operations/deployment-sizing-guide/#security-hardening","title":"Security Hardening","text":""},{"location":"operations/deployment-sizing-guide/#system-security","title":"System Security","text":"<p>1. Operating System Hardening:</p> <pre><code># Keep system updated\nsudo apt update &amp;&amp; sudo apt upgrade -y\n\n# Configure automatic security updates\nsudo apt install unattended-upgrades\nsudo dpkg-reconfigure -plow unattended-upgrades\n\n# Disable root login\nsudo sed -i 's/PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config\nsudo systemctl restart sshd\n\n# Configure SSH key-only authentication\nsudo sed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config\nsudo systemctl restart sshd\n\n# Install and configure fail2ban\nsudo apt install fail2ban\nsudo systemctl enable fail2ban\n</code></pre> <p>2. Application Security:</p> <pre><code># src/backend/.env\n\n# Strong secret keys (generate with: openssl rand -hex 32)\nSECRET_KEY=&lt;64-character-hex-string&gt;\nJWT_SECRET_KEY=&lt;64-character-hex-string&gt;\n\n# Database passwords (minimum 16 characters, mixed case, numbers, symbols)\nPOSTGRES_PASSWORD=&lt;strong-password&gt;\nREDIS_PASSWORD=&lt;strong-password&gt;\nNEO4J_PASSWORD=&lt;strong-password&gt;\n\n# API keys (rotate every 90 days)\nOPENAI_API_KEY=sk-...\nLANGSMITH_API_KEY=ls-...\n</code></pre> <p>3. Database Security:</p> <p>PostgreSQL:</p> <pre><code># Edit /etc/postgresql/14/main/pg_hba.conf\n# Allow local connections only\nlocal   all             all                                     md5\nhost    all             all             127.0.0.1/32            md5\nhost    all             all             ::1/128                 md5\n\n# Disable external connections\n# Comment out or remove:\n# host    all             all             0.0.0.0/0               md5\n\n# Restart PostgreSQL\nsudo systemctl restart postgresql\n</code></pre> <p>Neo4j:</p> <pre><code># neo4j.conf\n\n# Enable authentication\ndbms.security.auth_enabled=true\n\n# Bind to localhost only (if on same server)\ndbms.connector.bolt.listen_address=127.0.0.1:7687\ndbms.connector.http.listen_address=127.0.0.1:7474\n\n# Use strong password (16+ characters)\n# Change default password immediately after installation\n</code></pre> <p>Redis:</p> <pre><code># redis.conf\n\n# Require password\nrequirepass &lt;strong-password&gt;\n\n# Bind to localhost only\nbind 127.0.0.1\n\n# Disable dangerous commands\nrename-command FLUSHDB \"\"\nrename-command FLUSHALL \"\"\nrename-command CONFIG \"\"\n</code></pre> <p>4. TLS/SSL Configuration:</p> <pre><code># Install Let's Encrypt certificate (for public-facing deployments)\nsudo apt install certbot python3-certbot-nginx\n\n# Obtain certificate\nsudo certbot --nginx -d api.esab.example.com\n\n# Auto-renewal\nsudo systemctl enable certbot.timer\n</code></pre> <p>Nginx TLS Configuration:</p> <pre><code>server {\n    listen 443 ssl http2;\n    server_name api.esab.example.com;\n\n    ssl_certificate /etc/letsencrypt/live/api.esab.example.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/api.esab.example.com/privkey.pem;\n\n    # Strong TLS settings\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    ssl_prefer_server_ciphers on;\n\n    # HSTS header\n    add_header Strict-Transport-Security \"max-age=31536000\" always;\n\n    location / {\n        proxy_pass http://localhost:8000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#security-checklist","title":"Security Checklist","text":"<p>Pre-Production Security Audit:</p> <ul> <li> All default passwords changed</li> <li> SSH key-only authentication enabled</li> <li> Firewall configured (UFW or Security Groups)</li> <li> Database ports blocked from external access</li> <li> TLS/SSL certificates installed</li> <li> Secret keys rotated and stored securely</li> <li> Automatic security updates enabled</li> <li> Fail2ban configured for SSH protection</li> <li> Log monitoring enabled</li> <li> Backup encryption enabled</li> <li> API rate limiting configured</li> <li> CORS properly configured</li> <li> Environment variables not committed to Git</li> <li> Security headers configured (HSTS, CSP)</li> <li> Redis password set and dangerous commands disabled</li> </ul>"},{"location":"operations/deployment-sizing-guide/#maintenance-procedures","title":"Maintenance Procedures","text":""},{"location":"operations/deployment-sizing-guide/#daily-maintenance","title":"Daily Maintenance","text":"<p>Automated (via cron):</p> <pre><code># Health check (every 5 minutes)\n*/5 * * * * /opt/esab-recommender/scripts/health-check.sh\n\n# Log rotation (daily at midnight)\n0 0 * * * /usr/sbin/logrotate /etc/logrotate.d/esab-recommender\n\n# Disk cleanup (daily at 2 AM)\n0 2 * * * /opt/esab-recommender/scripts/cleanup-old-logs.sh\n</code></pre> <p>Manual (5 minutes/day):</p> <pre><code># Check application status\nsudo systemctl status esab-recommender.service\n\n# Check error logs for anomalies\ntail -n 100 /home/azureuser/esab_recommender-bh/logs/esab-recommender-error.log\n\n# Check disk space\ndf -h\n\n# Check database health\ncurl -s http://localhost:8000/health | jq\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#weekly-maintenance","title":"Weekly Maintenance","text":"<p>Automated (via cron):</p> <pre><code># PostgreSQL VACUUM (Sunday at 3 AM)\n0 3 * * 0 psql -U postgres -d pconfig -c \"VACUUM ANALYZE;\"\n\n# Configuration backup (Sunday at 4 AM)\n0 4 * * 0 /opt/esab-recommender/scripts/backup-config.sh\n</code></pre> <p>Manual (30 minutes/week):</p> <pre><code># Review application logs for patterns\nsudo journalctl -u esab-recommender.service --since \"1 week ago\" | grep ERROR\n\n# Check PostgreSQL slow queries\npsql -U postgres -d pconfig -c \"\n    SELECT query, calls, total_exec_time/1000 as total_time_sec\n    FROM pg_stat_statements\n    ORDER BY total_exec_time DESC\n    LIMIT 10;\n\"\n\n# Check Neo4j slow queries (if self-hosted)\ngrep \"SLOW QUERY\" /var/lib/neo4j/logs/query.log\n\n# Review Redis memory usage\nredis-cli INFO memory\n\n# Check for security updates\nsudo apt update\nsudo apt list --upgradable\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#monthly-maintenance","title":"Monthly Maintenance","text":"<p>Automated (via cron):</p> <pre><code># Security updates (first Sunday at 5 AM)\n0 5 1-7 * 0 /opt/esab-recommender/scripts/security-updates.sh\n</code></pre> <p>Manual (2 hours/month):</p> <pre><code># Review and update dependencies\ncd /opt/esab-recommender/src/backend\nsource venv/bin/activate\npip list --outdated\n\n# Review backup integrity\nls -lh /backup/postgresql/\nls -lh /backup/neo4j/\n\n# Review and rotate API keys (every 90 days)\n# - OpenAI API key\n# - LangSmith API key\n# - Application secret keys\n\n# Review access logs and usage patterns\n# Analyze user behavior, peak usage times, error rates\n\n# Capacity planning review\n# - Check if current resources are sufficient\n# - Plan for scaling if needed\n\n# Security audit\n# - Review firewall rules\n# - Check for unauthorized access attempts\n# - Review SSL certificate expiration\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#quarterly-maintenance","title":"Quarterly Maintenance","text":"<p>Automated: - None (manual review required)</p> <p>Manual (1 day/quarter):</p> <pre><code># Full system audit\n# - Review all configurations\n# - Update documentation\n# - Review disaster recovery plan\n# - Test backup restoration\n\n# Performance testing\n# - Load testing with expected peak load\n# - Benchmark database queries\n# - Optimize slow queries\n\n# Security review\n# - Penetration testing (external)\n# - Dependency vulnerability scan\n# - Access control audit\n\n# Capacity planning\n# - Review growth trends\n# - Plan infrastructure upgrades\n# - Budget review\n</code></pre>"},{"location":"operations/deployment-sizing-guide/#appendix","title":"Appendix","text":""},{"location":"operations/deployment-sizing-guide/#a-configuration-file-templates","title":"A. Configuration File Templates","text":"<p>See deployment/env/ for production configuration templates.</p>"},{"location":"operations/deployment-sizing-guide/#b-systemd-service-files","title":"B. Systemd Service Files","text":"<p>See deployment/systemd/ for service definitions.</p>"},{"location":"operations/deployment-sizing-guide/#c-database-schema-scripts","title":"C. Database Schema Scripts","text":"<p>See deployment/database/ for initialization scripts.</p>"},{"location":"operations/deployment-sizing-guide/#d-monitoring-scripts","title":"D. Monitoring Scripts","text":"<p>See deployment/scripts/ for health check and monitoring scripts.</p>"},{"location":"operations/deployment-sizing-guide/#e-troubleshooting-guide","title":"E. Troubleshooting Guide","text":"<p>See docs/deployment/troubleshooting.md for common issues and solutions.</p>"},{"location":"operations/deployment-sizing-guide/#f-api-documentation","title":"F. API Documentation","text":"<p>See CLAUDE.md for complete API reference and architecture documentation.</p>"},{"location":"operations/deployment-sizing-guide/#revision-history","title":"Revision History","text":"Version Date Author Changes 1.0 2024-01-15 DevOps Team Initial deployment and sizing guide <p>For questions or support, contact: devops@esab.example.com</p>"},{"location":"operations/scripts/","title":"Operational Scripts","text":"<p>This directory contains operational and maintenance scripts for the ESAB Welding Equipment Configurator.</p>"},{"location":"operations/scripts/#available-scripts","title":"Available Scripts","text":""},{"location":"operations/scripts/#health-monitoring","title":"Health Monitoring","text":"<p><code>health-check.sh</code> - Application health monitoring script</p> <p>Purpose: Monitors the application health endpoint and component status.</p> <p>Usage: <pre><code># Basic usage (logs only)\n./health-check.sh\n\n# With email alerts\n./health-check.sh --email admin@example.com\n\n# Custom health URL\n./health-check.sh --url http://production-server:8000/health\n</code></pre></p> <p>Cron Schedule: <pre><code># Check every 5 minutes\n*/5 * * * * /opt/esab-recommender/scripts/health-check.sh &gt;&gt; /var/log/health-check.log 2&gt;&amp;1\n</code></pre></p> <p>Configuration: - <code>API_URL</code>: Health endpoint URL (default: http://localhost:8000/health) - <code>ALERT_EMAIL</code>: Email address for alerts (default: admin@example.com) - <code>ENABLE_EMAIL_ALERTS</code>: Enable email notifications (default: false) - <code>LOG_FILE</code>: Log file location (default: /var/log/esab-health-check.log)</p> <p>Requirements: - <code>curl</code> - HTTP client - <code>jq</code> - JSON processor - <code>mail</code> command (optional, for email alerts)</p>"},{"location":"operations/scripts/#database-backups","title":"Database Backups","text":"<p><code>backup-postgres.sh</code> - PostgreSQL backup script</p> <p>Purpose: Creates compressed PostgreSQL backups with automatic rotation.</p> <p>Usage: <pre><code># Run backup manually\n./backup-postgres.sh\n\n# With custom configuration\nBACKUP_DIR=/custom/backup/path RETENTION_DAYS=14 ./backup-postgres.sh\n</code></pre></p> <p>Cron Schedule: <pre><code># Daily backup at 3 AM\n0 3 * * * /opt/esab-recommender/scripts/backup-postgres.sh &gt;&gt; /var/log/backup-postgres.log 2&gt;&amp;1\n</code></pre></p> <p>Configuration: - <code>BACKUP_DIR</code>: Backup directory (default: /backup/postgresql) - <code>RETENTION_DAYS</code>: Days to retain backups (default: 7) - <code>DB_NAME</code>: Database name (default: pconfig) - <code>DB_USER</code>: PostgreSQL user (default: postgres) - <code>DB_HOST</code>: Database host (default: localhost) - <code>DB_PORT</code>: Database port (default: 5432)</p> <p>Backup Format: - Compressed custom format (<code>-Fc</code>) for space efficiency - Filename: <code>pconfig_YYYYMMDD_HHMMSS.dump</code> - Includes integrity verification</p> <p>Restore Procedure: <pre><code># List available backups\nls -lh /backup/postgresql/\n\n# Restore from backup\npg_restore -U postgres -d pconfig -c /backup/postgresql/pconfig_20240115_030000.dump\n\n# Verify restoration\npsql -U postgres -d pconfig -c \"SELECT COUNT(*) FROM archived_sessions;\"\n</code></pre></p> <p><code>backup-neo4j.sh</code> - Neo4j backup script (Community Edition)</p> <p>Purpose: Creates Neo4j database backups with automatic rotation (self-hosted only).</p> <p>Usage: <pre><code># Run backup manually\n./backup-neo4j.sh\n\n# With custom configuration\nBACKUP_DIR=/custom/backup/path RETENTION_DAYS=14 ./backup-neo4j.sh\n</code></pre></p> <p>Cron Schedule: <pre><code># Daily backup at 3 AM\n0 3 * * * /opt/esab-recommender/scripts/backup-neo4j.sh &gt;&gt; /var/log/backup-neo4j.log 2&gt;&amp;1\n</code></pre></p> <p>Configuration: - <code>BACKUP_DIR</code>: Backup directory (default: /backup/neo4j) - <code>RETENTION_DAYS</code>: Days to retain backups (default: 7) - <code>NEO4J_HOME</code>: Neo4j installation directory (default: /var/lib/neo4j) - <code>NEO4J_SERVICE</code>: Systemd service name (default: neo4j) - <code>DB_NAME</code>: Database name (default: neo4j)</p> <p>Backup Process: 1. Stops Neo4j service for consistent backup 2. Creates backup using <code>neo4j-admin database dump</code> 3. Restarts Neo4j service 4. Deletes old backups based on retention policy</p> <p>Note: This script is only needed for self-hosted Neo4j Community Edition. If using Neo4j Aura (cloud), backups are managed automatically.</p> <p>Restore Procedure: <pre><code># Stop Neo4j\nsudo systemctl stop neo4j\n\n# Load backup\nneo4j-admin database load neo4j --from=/backup/neo4j/neo4j_20240115_030000.dump --overwrite-destination\n\n# Start Neo4j\nsudo systemctl start neo4j\n\n# Verify restoration\ncypher-shell -u neo4j -p &lt;password&gt; \"MATCH (n) RETURN count(n);\"\n</code></pre></p>"},{"location":"operations/scripts/#log-management","title":"Log Management","text":"<p><code>cleanup-old-logs.sh</code> - Log cleanup and compression script</p> <p>Purpose: Removes old log files, compresses recent logs, and manages disk space.</p> <p>Usage: <pre><code># Run cleanup manually\n./cleanup-old-logs.sh\n\n# With custom configuration\nLOG_DIR=/custom/log/path RETENTION_DAYS=30 ./cleanup-old-logs.sh\n</code></pre></p> <p>Cron Schedule: <pre><code># Daily cleanup at 2 AM\n0 2 * * * /opt/esab-recommender/scripts/cleanup-old-logs.sh &gt;&gt; /var/log/esab-cleanup.log 2&gt;&amp;1\n</code></pre></p> <p>Configuration: - <code>LOG_DIR</code>: Main log directory (default: /home/azureuser/esab_recommender-bh/logs) - <code>BACKUP_LOG_DIR</code>: Backup log directory (default: /var/log) - <code>RETENTION_DAYS</code>: Days to retain logs (default: 14) - <code>COMPRESS_AGE_DAYS</code>: Compress logs older than this (default: 7)</p> <p>Cleanup Process: 1. Deletes log files older than retention period 2. Compresses log files older than 7 days (but newer than retention) 3. Cleans up backup log directory 4. Vacuums systemd journal logs (keeps last 30 days) 5. Reports disk usage</p>"},{"location":"operations/scripts/#installation","title":"Installation","text":""},{"location":"operations/scripts/#make-scripts-executable","title":"Make Scripts Executable","text":"<pre><code># Navigate to scripts directory\ncd /opt/esab-recommender/deployment/scripts\n\n# Make all scripts executable\nchmod +x *.sh\n\n# Or individually\nchmod +x health-check.sh\nchmod +x backup-postgres.sh\nchmod +x backup-neo4j.sh\nchmod +x cleanup-old-logs.sh\n</code></pre>"},{"location":"operations/scripts/#setup-cron-jobs","title":"Setup Cron Jobs","text":"<pre><code># Edit crontab\ncrontab -e\n\n# Add scheduled tasks (example for production)\n*/5 * * * * /opt/esab-recommender/scripts/health-check.sh --email admin@example.com &gt;&gt; /var/log/health-check.log 2&gt;&amp;1\n0 3 * * * /opt/esab-recommender/scripts/backup-postgres.sh &gt;&gt; /var/log/backup-postgres.log 2&gt;&amp;1\n0 3 * * * /opt/esab-recommender/scripts/backup-neo4j.sh &gt;&gt; /var/log/backup-neo4j.log 2&gt;&amp;1\n0 2 * * * /opt/esab-recommender/scripts/cleanup-old-logs.sh &gt;&gt; /var/log/esab-cleanup.log 2&gt;&amp;1\n</code></pre>"},{"location":"operations/scripts/#create-backup-directories","title":"Create Backup Directories","text":"<pre><code># Create backup directories\nsudo mkdir -p /backup/postgresql\nsudo mkdir -p /backup/neo4j\n\n# Set permissions\nsudo chown $USER:$USER /backup/postgresql\nsudo chown $USER:$USER /backup/neo4j\n</code></pre>"},{"location":"operations/scripts/#email-alerts-setup","title":"Email Alerts Setup","text":"<p>For email alerts to work, you need to configure a mail transfer agent (MTA).</p>"},{"location":"operations/scripts/#option-1-using-gmail-smtp-via-msmtp","title":"Option 1: Using Gmail SMTP (via msmtp)","text":"<pre><code># Install msmtp and mailutils\nsudo apt install msmtp msmtp-mta mailutils\n\n# Configure msmtp\nsudo nano /etc/msmtprc\n</code></pre> <p>msmtp configuration: <pre><code># Default values\ndefaults\nauth           on\ntls            on\ntls_trust_file /etc/ssl/certs/ca-certificates.crt\nlogfile        ~/.msmtp.log\n\n# Gmail account\naccount        gmail\nhost           smtp.gmail.com\nport           587\nfrom           your-email@gmail.com\nuser           your-email@gmail.com\npassword       your-app-password\n\n# Set a default account\naccount default : gmail\n</code></pre></p> <p>Set permissions: <pre><code>sudo chmod 600 /etc/msmtprc\n</code></pre></p> <p>Test email: <pre><code>echo \"Test email\" | mail -s \"Test Subject\" admin@example.com\n</code></pre></p>"},{"location":"operations/scripts/#option-2-using-sendgrid-api","title":"Option 2: Using SendGrid API","text":"<p>For production, consider using SendGrid or similar email service with API.</p>"},{"location":"operations/scripts/#monitoring-dashboard-optional","title":"Monitoring Dashboard (Optional)","text":"<p>For advanced monitoring, integrate with monitoring tools:</p>"},{"location":"operations/scripts/#prometheus-integration","title":"Prometheus Integration","text":"<pre><code># /etc/prometheus/prometheus.yml\n\nscrape_configs:\n  - job_name: 'esab-recommender'\n    static_configs:\n      - targets: ['localhost:8000']\n    metrics_path: '/metrics'\n</code></pre>"},{"location":"operations/scripts/#grafana-dashboards","title":"Grafana Dashboards","text":"<p>Import pre-built dashboards for: - Application metrics (requests, errors, latency) - Database metrics (connections, query time) - System metrics (CPU, memory, disk)</p>"},{"location":"operations/scripts/#troubleshooting","title":"Troubleshooting","text":""},{"location":"operations/scripts/#health-check-fails","title":"Health Check Fails","text":"<p>Symptoms: Health check returns non-200 status or unhealthy components</p> <p>Solutions: 1. Check if application is running: <code>systemctl status esab-recommender.service</code> 2. Check application logs: <code>sudo journalctl -u esab-recommender.service -n 100</code> 3. Test health endpoint manually: <code>curl http://localhost:8000/health | jq</code> 4. Check database connectivity:    - Neo4j: <code>cypher-shell -u neo4j -p &lt;password&gt; \"RETURN 1;\"</code>    - PostgreSQL: <code>psql -U postgres -d pconfig -c \"SELECT 1;\"</code>    - Redis: <code>redis-cli ping</code></p>"},{"location":"operations/scripts/#backup-fails","title":"Backup Fails","text":"<p>PostgreSQL Backup Issues: - Check disk space: <code>df -h /backup/postgresql</code> - Check PostgreSQL service: <code>systemctl status postgresql</code> - Check user permissions: <code>sudo -u postgres pg_dump --version</code> - Check backup directory permissions: <code>ls -ld /backup/postgresql</code></p> <p>Neo4j Backup Issues: - Check disk space: <code>df -h /backup/neo4j</code> - Check Neo4j service: <code>systemctl status neo4j</code> - Check neo4j-admin access: <code>neo4j-admin version</code> - Verify NEO4J_HOME: <code>ls -l /var/lib/neo4j</code></p>"},{"location":"operations/scripts/#cron-jobs-not-running","title":"Cron Jobs Not Running","text":"<p>Check cron service: <pre><code>sudo systemctl status cron\n</code></pre></p> <p>Check cron logs: <pre><code>sudo journalctl -u cron -n 50\n</code></pre></p> <p>Verify crontab: <pre><code>crontab -l\n</code></pre></p> <p>Test script manually: <pre><code>/opt/esab-recommender/scripts/health-check.sh\n</code></pre></p>"},{"location":"operations/scripts/#email-alerts-not-working","title":"Email Alerts Not Working","text":"<p>Check mail command: <pre><code>which mail\n</code></pre></p> <p>Test mail directly: <pre><code>echo \"Test email body\" | mail -s \"Test Subject\" admin@example.com\n</code></pre></p> <p>Check msmtp logs (if using msmtp): <pre><code>tail -f ~/.msmtp.log\n</code></pre></p>"},{"location":"operations/scripts/#security-best-practices","title":"Security Best Practices","text":"<ol> <li> <p>Secure Scripts:    <pre><code># Set restrictive permissions\nchmod 750 /opt/esab-recommender/scripts/*.sh\nchown root:root /opt/esab-recommender/scripts/*.sh\n</code></pre></p> </li> <li> <p>Protect Backup Data:    <pre><code># Encrypt backups\ngpg --encrypt --recipient admin@example.com backup_file.dump\n\n# Set restrictive permissions on backup directory\nchmod 700 /backup\n</code></pre></p> </li> <li> <p>Secure Email Configuration:</p> </li> <li>Use app-specific passwords for Gmail</li> <li>Store credentials in protected configuration files</li> <li> <p>Use SMTP TLS/SSL for encryption</p> </li> <li> <p>Audit Logging:</p> </li> <li>All scripts log to <code>/var/log/esab-*.log</code></li> <li>Configure log rotation to prevent disk filling</li> <li>Review logs regularly for anomalies</li> </ol>"},{"location":"operations/scripts/#additional-resources","title":"Additional Resources","text":"<ul> <li>Deployment and Sizing Guide</li> <li>Operations Runbook</li> <li>Troubleshooting Guide</li> <li>Main Deployment Guide</li> </ul>"},{"location":"operations/scripts/#support","title":"Support","text":"<p>For questions or issues with operational scripts: - Check logs in <code>/var/log/esab-*.log</code> - Review Troubleshooting Guide - Contact DevOps team: devops@esab.example.com</p>"}]}